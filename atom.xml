<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Qi Tang's Blog]]></title>
  <subtitle><![CDATA[你不能把这个世界，让给你所鄙视的人]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://itangqi.me/"/>
  <updated>2016-04-19T08:52:18.000Z</updated>
  <id>http://itangqi.me/</id>
  
  <author>
    <name><![CDATA[Qi Tang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[UICollectionView 学习笔记]]></title>
    <link href="http://itangqi.me/2016/04/19/the-notes-of-learning-uicollectionview/"/>
    <id>http://itangqi.me/2016/04/19/the-notes-of-learning-uicollectionview/</id>
    <published>2016-04-18T16:00:00.000Z</published>
    <updated>2016-04-19T08:52:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近计划着开个新项目，前期工作准备先撸个图片选择器出来。当然核心肯定是 PhotoKit (ASsetsLibrary) 啦，不过那些会在稍后文章中介绍，今天的主角则是 <strong>UICollectionView</strong>。</p>
<a id="more"></a> 
<hr>
<h2 id="简介">简介</h2><p>首先看苹果官方文档 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionView_class/" target="_blank" rel="external">UICollectionView Class Reference</a> 的介绍:</p>
<blockquote>
<p>The UICollectionView class manages an ordered collection of data items and presents them using customizable layouts. Collection views provide the same general function as table views except that a collection view is able to support more than just single-column layouts. Collection views support customizable layouts that can be used to implement multi-column grids, tiled layouts, circular layouts, and many more. You can even change the layout of a collection view dynamically if you want.</p>
</blockquote>
<p>一句话总结就是：<strong>UICollectionView 与 UITableView 相似，却提供了可自定义多列网格（Grild）的功能。</strong></p>
<hr>
<h2 id="核心">核心</h2><ul>
<li><p><strong>Cells</strong>：单元格，用于展示内容的主体</p>
</li>
<li><p><strong>Supplementary Views</strong>：追加视图，相当于 UITableView 中每个 Section 的 Header 或 Footer</p>
</li>
<li><p><strong>Decoration Views</strong>：装饰视图，用于装饰整个 UICollectionView</p>
</li>
</ul>
<p>UICollectionView 最常见的使用场景，想必就是相册（照片墙）的实现与展示了，下面通过一张图来直观地认识 CollectionView 各部分的构成：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-001.png" alt=""></p>
<hr>
<h2 id="实现">实现</h2><p>如果你在之前有了解及使用过 UITableView 的话，那么恭喜你，你将会快速上手 UICollectionView。</p>
<h3 id="UICollectionViewDataSource">UICollectionViewDataSource</h3><p>UICollectionViewDataSource - 负责提供展示的数据，实现下面两个必须的委托方法，其实 UITableView 并无二意，所以在此不做过多介绍了。</p>
<ul>
<li><p><strong>numberOfItemsInSection</strong>：某个 section 里有多少个 item</p>
</li>
<li><p><strong>cellForItemAtIndexPath</strong>：对于某个位置应该显示什么样的 cell，里面会涉及到 cell 的复用，可参见 TableView</p>
</li>
</ul>
<p>其实到这里，CollectionView 就可以正常显示了，对吧，就是这么简单：）</p>
<h3 id="UICollectionViewDelegate">UICollectionViewDelegate</h3><p>UICollectionViewDelegate - 负责用户的交互、Cell 的外形，委托方法和 TableView 相似，可以选择性实现以下委托方法。</p>
<ul>
<li><p><strong>collectionView:shouldHighlightItemAtIndexPath</strong>：是否支持高亮？</p>
</li>
<li><p><strong>collectionView:didHighlightItemAtIndexPath</strong>：如果支持高亮，那么高亮；</p>
</li>
<li><p><strong>collectionView:shouldSelectItemAtIndexPath</strong>：询问是否可以被选中？</p>
</li>
<li><p><strong>collectionView:didUnhighlightItemAtIndexPath</strong>：如果支持高亮，那么现在取消高亮；</p>
</li>
<li><p><strong>collectionView:didSelectItemAtIndexPath</strong>：如果支持可以被选中，那么选中 cell；</p>
</li>
</ul>
<p>下面再通过几张图来更加清晰地理解：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-002.jpg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-003.jpg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-004.jpg" alt=""></p>
<h3 id="UICollectionViewLayout">UICollectionViewLayout</h3><p>在布局上，与 UITableView 直接使用系统提供的样式不同，UICollectionView 使用的是 UICollectionViewLayout 来自定义布局样式。</p>
<p>在苹果官方文档：<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/" target="_blank" rel="external">UICollectionViewLayout Class Reference</a> 中对其做了如下解释:</p>
<blockquote>
<p>The UICollectionViewLayout class is an abstract base class that you subclass and use to generate layout information for a collection view. The job of a layout object is to determine the placement of cells, supplementary views, and decoration views inside the collection view’s bounds and to report that information to the collection view when asked. The collection view then applies the provided layout information to the corresponding views so that they can be presented onscreen.</p>
</blockquote>
<p>这里做下简短的总结：</p>
<ol>
<li><p>UICollectionViewLayout 是一个抽象基类，你需要继承自他，来为 CollectionView 生成 Layout 信息。Layout 对象的作用是决定 Cells，Supplementary Views 和 Decoration Views 在 CollectionView 中的布局位置。当然啦，如果你不想折腾，苹果也贴心的为你准备了 UICollectionViewFlowLayout - 流水式布局效果。</p>
</li>
<li><p>UICollectionView 的显示效果几乎全部由 UICollectionViewLayout 负责，而真正存储着每一个 Cell 的位置、大小等属性的是 UICollectionViewLayoutAttributes 。每一个 Cell 对应着一个属于自己的 UICollectionViewLayoutAttributes，而 UICollectionViewLayout 正是利用 UICollectionViewLayoutAttributes 里存在的信息对每一个 Cell 进行布局。</p>
</li>
</ol>
<p>下面通过一张图来了解 UICollectionView 的构成：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-005.jpg" alt=""></p>
<h2 id="总结">总结</h2><p>可以说 UICollectionView 是 iOS 开发中必不可少的 UIKit 控件之一。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionView_class/" target="_blank" rel="external">UICollectionView Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/" target="_blank" rel="external">UICollectionViewLayout Class Reference</a></li>
<li><a href="http://www.appcoda.com/ios-programming-uicollectionview-tutorial/" target="_blank" rel="external">Create Grid Layout Using UICollectionView in iOS 6</a></li>
<li><a href="http://my.oschina.net/sunqichao/blog/182623" target="_blank" rel="external">UICollectionView 使用 介绍</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>最近计划着开个新项目，前期工作准备先撸个图片选择器出来。当然核心肯定是 PhotoKit (ASsetsLibrary) 啦，不过那些会在稍后文章中介绍，今天的主角则是 <strong>UICollectionView</strong>。</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《图解 HTTP》读书笔记（二）]]></title>
    <link href="http://itangqi.me/2016/04/05/the-notes-of-learning-illustrating-http-two/"/>
    <id>http://itangqi.me/2016/04/05/the-notes-of-learning-illustrating-http-two/</id>
    <published>2016-04-04T16:00:00.000Z</published>
    <updated>2016-04-20T02:27:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="第_4_章_返回结果的_HTTP_状态码">第 4 章 返回结果的 HTTP 状态码</h2><a id="more"></a> 
<h3 id="4-1_状态码告知从服务器端返回的请求结果">4.1  状态码告知从服务器端返回的请求结果</h3><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-4.1.1.jpg" alt=""></p>
<p>数字中的第一位定义了响应类别，后两位无分类。响应类别有以下 5 种：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">类别</th>
<th style="text-align:center">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1XX</td>
<td style="text-align:center">Informational（信息性状态码）</td>
<td style="text-align:center">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:center">2XX</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:center">3XX</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">需求进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:center">4XX</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:center">5XX</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<p>只要遵守状态码类别的定义，即使改变 <a href="https://datatracker.ietf.org/doc/rfc2616/" target="_blank" rel="external">RFC2616</a> 中定义的状态码，或服务器端自行创建状态码都没问题。</p>
<h4 id="2XX_成功">2XX 成功</h4><p>200 OK：表示从客户端发来的请求在服务器端被正常处理了</p>
<p>204 No Content：请求处理成功，但是没有资源返回</p>
<p>206 Partial Content：请求处理成功，返回部分内容，响应报文中包含 Content-Range 指定范围的实体内容</p>
<h4 id="3XX_重定向">3XX 重定向</h4><p>301 Moved Permanently：永久性重定向</p>
<p>302 Found：临时性重定向</p>
<p>303 See Other：表示请求的资源存在着另一个 URL，应使用 GET 方法定向获取请求的资源</p>
<p>304 Not Modified：表示请求的资源没有改变，可以使用客户端上未过期的资源</p>
<p>307 Temporary Redirect：临时性重定向，不会从 POST 变成 GET</p>
<h4 id="4XX_客户端错误">4XX 客户端错误</h4><p>400 Bad Request：表示请求报文中存在语法错误</p>
<p>401 Unauthorized：表示发送的请求需要有通过 HTTP 认证</p>
<p>403 Forbidden：表示请求资源的访问被服务器拒绝了</p>
<p>404 Not Found：表示服务器上没有请求的资源</p>
<h4 id="5XX_服务器错误">5XX 服务器错误</h4><p>500 Internal Server Error：表示服务器在执行请求时发生了错误</p>
<p>503 Service Unavailable：表示服务器暂时处于超负载或者正在进行停机维护，现在无法处理请求</p>
<hr>
<h2 id="第_5_章_与_HTTP_协作的_Web_服务器">第 5 章 与 HTTP 协作的 Web 服务器</h2><h3 id="5-1_用单台虚拟主机实现多个域名">5.1  用单台虚拟主机实现多个域名</h3><p>HTTP / 1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。这是利用虚拟主机（Virtual Host，又称虚拟服务器）的功能。</p>
<p>在互联网上，域名通过 DNS 服务映射到 IP 地址之后访问目标网站。可见，当请求发送到服务器时，已经是以 IP 地址形式访问了。所以，当一台托管了两个域名的服务器接收到请求时就需要弄清楚究竟要访问哪个域名。<br>在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。</p>
<h3 id="5-2_通信数据转发程序：代理、网关、隧道">5.2 通信数据转发程序：代理、网关、隧道</h3><h4 id="5-2-1_代理">5.2.1 代理</h4><p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-5.2.1.jpg" alt=""></p>
<p>每次通过代理服务器转发请求或响应式，会追加写入via首部信息。</p>
<p>使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。</p>
<p>代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文：</p>
<ul>
<li>缓存代理：代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上</li>
<li>透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理。反之，对 报文内容进行加工的代理被成为非透明代理</li>
</ul>
<h4 id="5-2-2_网关">5.2.2 网关</h4><p>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。 </p>
<p>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-5.2.2.jpg" alt=""></p>
<h4 id="5-2-3_隧道">5.2.3 隧道</h4><p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。</p>
<p>隧道本身不会去解析 HTTP 请求。请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-5.2.3.jpg" alt=""></p>
<h3 id="5-3_保存资源的缓存">5.3 保存资源的缓存</h3><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，节省通信流量和时间。</p>
<p>缓存服务器是代理服务器的一种。当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。</p>
<p>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。</p>
<h4 id="5-3-1_缓存的有效期限">5.3.1 缓存的有效期限</h4><p>对于缓存服务器和客户端浏览器，当判定缓存过期或客户端要求，会向源服务器确认资源的有效性。若失效，浏览器会再次请求新资源。</p>
<h4 id="5-3-2_客户端的缓存">5.3.2 客户端的缓存</h4><p>缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以 Internet Explorer 程序为例，把客户端缓存称为临时网络文件（Temporary Internet File）。</p>
<hr>
<h2 id="第_6_章_HTTP_首部">第 6 章 HTTP 首部</h2><h3 id="6-1_HTTP_首部字段">6.1 HTTP 首部字段</h3><h4 id="6-1-1_HTTP_首部字段传递重要信息">6.1.1 HTTP 首部字段传递重要信息</h4><p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
<h4 id="6-1-2_4_种_HTTP_首部字段类型">6.1.2 4 种 HTTP 首部字段类型</h4><ol>
<li>通用首部字段（General Header Fields）</li>
<li>请求首部字段（Request Header Fields）</li>
<li>响应首部字段（Response Header Fields）</li>
<li>实体首部字段（Entity Header Fields）</li>
</ol>
<h4 id="6-1-3_HTTP_/_1-1_首部字段一览">6.1.3 HTTP / 1.1 首部字段一览</h4><p><strong>通用首部字段</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Cache-Control</td>
<td style="text-align:center">控制缓存的行为</td>
</tr>
<tr>
<td style="text-align:center">Connection</td>
<td style="text-align:center">逐跳首部、连接的管理</td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">创建报文日期时间</td>
</tr>
<tr>
<td style="text-align:center">Pragma</td>
<td style="text-align:center">报文指令</td>
</tr>
<tr>
<td style="text-align:center">Trailer</td>
<td style="text-align:center">报文末端的首部一览</td>
</tr>
<tr>
<td style="text-align:center">Transfer-Encoding</td>
<td style="text-align:center">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td style="text-align:center">Upgrade</td>
<td style="text-align:center">升级为其他协议</td>
</tr>
<tr>
<td style="text-align:center">Via</td>
<td style="text-align:center">代理服务器的相关信息</td>
</tr>
<tr>
<td style="text-align:center">Warning</td>
<td style="text-align:center">错误通知</td>
</tr>
</tbody>
</table>
<ol>
<li>Cache-Control 的 no-cache 指令代表不缓存过期的资源，而不是不缓存。no-store 才是真正不进行缓存。</li>
<li>Connection 首部字段的值为 close 时，代表服务器想明确断开连接（HTTP / 1.1默认都是持久连接）</li>
</ol>
<p><strong>请求首部字段</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept</td>
<td style="text-align:center">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td style="text-align:center">Accept-Charset</td>
<td style="text-align:center">优先的字符集</td>
</tr>
<tr>
<td style="text-align:center">Accept-Encoding</td>
<td style="text-align:center">优先的内容编码</td>
</tr>
<tr>
<td style="text-align:center">Accept-Language</td>
<td style="text-align:center">优先的语言</td>
</tr>
<tr>
<td style="text-align:center">Authorization</td>
<td style="text-align:center">Web 认证信息</td>
</tr>
<tr>
<td style="text-align:center">Expect</td>
<td style="text-align:center">期待服务器的特定行为</td>
</tr>
<tr>
<td style="text-align:center">From</td>
<td style="text-align:center">用户的电子邮件地址</td>
</tr>
<tr>
<td style="text-align:center">Host</td>
<td style="text-align:center">请求资源所在服务器</td>
</tr>
<tr>
<td style="text-align:center">If-Match</td>
<td style="text-align:center">比较实体标记（ETag）</td>
</tr>
<tr>
<td style="text-align:center">If-Modified-Since</td>
<td style="text-align:center">比较资源的更新时间</td>
</tr>
<tr>
<td style="text-align:center">If-None-Match</td>
<td style="text-align:center">比较实体标记（与If-Match相反）</td>
</tr>
<tr>
<td style="text-align:center">If-Range</td>
<td style="text-align:center">资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td style="text-align:center">If-Unmodified-Since</td>
<td style="text-align:center">比较资源的更新时间（与 If-Modified-Since 相反）</td>
</tr>
<tr>
<td style="text-align:center">Max-Forwards</td>
<td style="text-align:center">最大传输逐跳数</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Authorization</td>
<td style="text-align:center">代理服务器要求客户端的认真信息</td>
</tr>
<tr>
<td style="text-align:center">Range</td>
<td style="text-align:center">实体的字节范围请求</td>
</tr>
<tr>
<td style="text-align:center">Referer</td>
<td style="text-align:center">对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td style="text-align:center">TE</td>
<td style="text-align:center">传输编码的优先级</td>
</tr>
<tr>
<td style="text-align:center">User-Agent</td>
<td style="text-align:center">HTTP 客户端程序的信息</td>
</tr>
</tbody>
</table>
<ol>
<li>该表的 Accept* 字段都可以指定权重 q 值（0-1）。当服务器提供多种内容时，将会首先返回权重最高的</li>
<li>If-xxx 请求首部字段都称为条件请求，服务器接收到附带条件的请求后，只有判断指定条件为真时，才回执行请求</li>
<li>Referer 的正确拼写应该是 Referrer。当直接在浏览器的地址栏输入 URI 时，或处于安全考虑时，可不发该首部字段</li>
</ol>
<p><strong>响应首部字段</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept-Ranges</td>
<td style="text-align:center">是否接受字节范围请求</td>
</tr>
<tr>
<td style="text-align:center">Age</td>
<td style="text-align:center">推算资源创建经过时间</td>
</tr>
<tr>
<td style="text-align:center">ETag</td>
<td style="text-align:center">资源的匹配信息</td>
</tr>
<tr>
<td style="text-align:center">Location</td>
<td style="text-align:center">令客户端重定向至指定的 URI</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Authentication</td>
<td style="text-align:center">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:center">Retry-After</td>
<td style="text-align:center">对再次发起请求的时机要求</td>
</tr>
<tr>
<td style="text-align:center">Server</td>
<td style="text-align:center">HTTP 服务器的安装信息</td>
</tr>
<tr>
<td style="text-align:center">Vary</td>
<td style="text-align:center">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td style="text-align:center">WWW-Authenticate</td>
<td style="text-align:center">服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<p>几乎所有浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p>
<p><strong>实体首部字段</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Allow</td>
<td style="text-align:center">资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td style="text-align:center">Content-Encoding</td>
<td style="text-align:center">实体主体适用的编码方式</td>
</tr>
<tr>
<td style="text-align:center">Content-Language</td>
<td style="text-align:center">实体主体的自然语言</td>
</tr>
<tr>
<td style="text-align:center">Content-Length</td>
<td style="text-align:center">实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td style="text-align:center">Content-Location</td>
<td style="text-align:center">替代对应资源的 URI</td>
</tr>
<tr>
<td style="text-align:center">Content-MD5</td>
<td style="text-align:center">实体主体的报文摘要</td>
</tr>
<tr>
<td style="text-align:center">Content-Range</td>
<td style="text-align:center">实体主体的位置范围</td>
</tr>
<tr>
<td style="text-align:center">Content-Type</td>
<td style="text-align:center">实体主体的媒体类型</td>
</tr>
<tr>
<td style="text-align:center">Expires</td>
<td style="text-align:center">实体主体过期的日期时间</td>
</tr>
<tr>
<td style="text-align:center">Last-Modified</td>
<td style="text-align:center">资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<p><strong>Cookie 相关首部字段</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">首部类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Set-Cookie</td>
<td style="text-align:center">服务器端返回给客户端存储的 Cookie 信息</td>
<td style="text-align:center">响应首部字段</td>
</tr>
<tr>
<td style="text-align:center">Cookie</td>
<td style="text-align:center">客户端向服务器端发送 Cookie 信息</td>
<td style="text-align:center">请求首部字段</td>
</tr>
</tbody>
</table>
<p><strong>Set-Cookie 字段的属性</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NAME=VALUE</td>
<td style="text-align:center">赋予 Cookie 的名称和其值（必须项）</td>
</tr>
<tr>
<td style="text-align:center">expires=DATE</td>
<td style="text-align:center">Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td>
</tr>
<tr>
<td style="text-align:center">path=Path</td>
<td style="text-align:center">将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录）</td>
</tr>
<tr>
<td style="text-align:center">domain=域名</td>
<td style="text-align:center">作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）</td>
</tr>
<tr>
<td style="text-align:center">Secure</td>
<td style="text-align:center">仅在 HTTPS 安全通信时才会发送 Cookie</td>
</tr>
<tr>
<td style="text-align:center">HttpOnly</td>
<td style="text-align:center">加以限制，使 Cookie 不能被 JavaScript 脚本访问</td>
</tr>
</tbody>
</table>
<ol>
<li>expires：一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显示删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作</li>
<li>path：用来指定 cookie 被发送到服务器的哪一个目录路径下（即被服务器哪个路径接收 cookie），其中”/“指的是站点根目录，可在同一台服务器（即使有多个应用）内共享该 cookie</li>
</ol>
<p><strong>其他首部字段</strong></p>
<ul>
<li>X-Frame-Options</li>
<li>X-XSS-Protection</li>
<li>DNT</li>
<li>P3P</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="第_4_章_返回结果的_HTTP_状态码">第 4 章 返回结果的 HTTP 状态码</h2>]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://itangqi.me/tags/HTTP/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="HTTP" scheme="http://itangqi.me/categories/HTTP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《图解 HTTP》读书笔记（一）]]></title>
    <link href="http://itangqi.me/2016/04/04/the-notes-of-learning-illustrating-http-one/"/>
    <id>http://itangqi.me/2016/04/04/the-notes-of-learning-illustrating-http-one/</id>
    <published>2016-04-03T16:00:00.000Z</published>
    <updated>2016-04-19T08:59:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>由于最近一段时间在找实习，所以陆陆续续面试了几家公司，可结果都跪了….</p>
<p>总结失败的原因有很多，如果要进行个排名的话，<strong>网络</strong>一定能进前三。每每被面试官问到网络相关知识的时候，我都是一脸懵逼样，支支吾吾说不出个所以然。</p>
<p>现在想想，做移动端也有些日子了，可网络知识这块居然只知胜少，究其原因就是自己不求上进，直到找工作的时候被现实打脸了才恍然醒悟。于是，痛定思痛，决定恶补下网络知识，一番 Google 后，决定以《图解 HTTP》作为入门书籍。当然好记性不如烂笔头，读书笔记是少不了的。</p>
<a id="more"></a> 
<hr>
<h2 id="第_1_章_了解_Web_及网络基础">第 1 章 了解 Web 及网络基础</h2><h3 id="1-1_使用_HTTP_协议访问_Web">1.1  使用 HTTP 协议访问 Web</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-1.1.jpg" alt=""></p>
<h4 id="1-1-1_从输入_URL_到页面加载完成的过程中都发生了什么事情？">1.1.1 从输入 URL 到页面加载完成的过程中都发生了什么事情？</h4><ol>
<li>在浏览器里输入网址</li>
<li>浏览器查找域名的 IP 地址</li>
<li>浏览器给 Web 服务器发送一个 HTTP 请求</li>
<li>Facebook 服务的永久重定向响应</li>
<li>浏览器跟踪重定向地址</li>
<li>服务器「处理」请求</li>
<li>服务器发回一个 HTML 响应</li>
<li>浏览器开始显示HTML</li>
<li>浏览器发送获取嵌入在 HTML 中的对象</li>
<li>浏览器发送异步（AJAX）请求</li>
</ol>
<p>详情参见：</p>
<ul>
<li><a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="external">当···时发生了什么？</a></li>
<li><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="external">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></li>
<li><a href="https://www.zhihu.com/question/34873227" target="_blank" rel="external">当在浏览器地址栏输入一个URL后回车，将会发生的事情？</a></li>
</ul>
<h3 id="1-2_HTTP_历史">1.2  HTTP 历史</h3><h4 id="1-2-1_HTTP_1-0_vs_HTTP_1-1">1.2.1  HTTP 1.0 vs HTTP 1.1</h4><ol>
<li>可扩展性</li>
<li>缓存</li>
<li>带宽优化</li>
<li>长连接</li>
<li>消息传递</li>
<li>Host 头域</li>
<li>错误提示</li>
<li>内容协商</li>
</ol>
<p>详情参见：</p>
<ul>
<li><a href="http://stackoverflow.com/questions/246859/http-1-0-vs-1-1" target="_blank" rel="external">HTTP 1.0 vs 1.1</a></li>
<li><a href="http://blog.csdn.net/forgotaboutgirl/article/details/6936982" target="_blank" rel="external">HTTP/1.1与HTTP/1.0的区别</a></li>
</ul>
<h4 id="1-2-2_HTTP_2-0">1.2.2  HTTP 2.0</h4><ol>
<li>二进制分帧</li>
<li>首部压缩</li>
<li>多路复用</li>
<li>并行双向字节流的请求和响应</li>
<li>请求优先级</li>
<li>服务器推送</li>
</ol>
<p>详情参见：</p>
<ul>
<li><a href="https://www.zhihu.com/question/34074946" target="_blank" rel="external">HTTP/2.0 相比1.0有哪些重大改进？</a></li>
<li><a href="http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/" target="_blank" rel="external">HTTP 2.0 的奇妙日常</a></li>
</ul>
<h3 id="1-3_网络基础_TCP/IP">1.3  网络基础 TCP/IP</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-1.3.jpg" alt=""></p>
<p>图：TCP/IP 是互联网相关的各类协议族的总称</p>
<h4 id="1-3-1_TCP/IP_的分层管理">1.3.1 TCP/IP 的分层管理</h4><ul>
<li><p>应用层：决定了向用户提供应用服务时通信的活动</p>
</li>
<li><p>传输层：对上层应用层，提供处于网络连接中的两台计算机之间的数据传输</p>
</li>
<li><p>网络层（又名网络互连层）：用来处理在网络上流动的数据包</p>
</li>
<li><p>链路层（又名数据链路层，网络接口层）：用来处理连接网络的硬件部分</p>
</li>
</ul>
<h4 id="1-3-2_TCP/IP_通信传输流">1.3.2  TCP/IP 通信传输流</h4><p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-1.3.2.jpg" alt=""></p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。</p>
<h3 id="1-4_与_HTTP_关系密切的协议：IP、TCP_和_DNS">1.4  与 HTTP 关系密切的协议：IP、TCP 和 DNS</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-1.4.1.jpg" alt=""></p>
<h4 id="1-4-1_负责传输的_IP_协议">1.4.1  负责传输的 IP 协议</h4><p>在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</p>
<h4 id="1-4-2_确保可靠性的_TCP_协议">1.4.2  确保可靠性的 TCP 协议</h4><p>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-1.4.2.jpg" alt=""></p>
<h5 id="1-4-2-1_为何要三次握手">1.4.2.1  为何要三次握手</h5><ol>
<li><p>为了防止已失效的连接请求报文段（上一个 TCP 连接）突然又传送到了服务端，因而产生错误（服务端白白等待）</p>
</li>
<li><p>也可假设想场景：两个人打电话</p>
</li>
</ol>
<h5 id="1-4-2-2_为何要四次分手">1.4.2.2 为何要四次分手</h5><ol>
<li><p>保证 TCP 协议的全双工连接能够可靠关闭</p>
</li>
<li><p>保证这次连接的重复数据段从网络中消失</p>
</li>
<li><p>TCP 连接是全双工的，这就意味着，当主机 1 发出 FIN 报文段时，只是表示主机 1 已经没有数据要发送了，但是，这个时候主机 1 还是可以接受来自主机 2 的数据；当主机 2 返回 ACK 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可以发送数据到主机 1 的；当主机 2 也发送了 FIN 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接</p>
</li>
</ol>
<p>详情参见：</p>
<ul>
<li><a href="http://www.jellythink.com/archives/705" target="_blank" rel="external">简析TCP的三次握手与四次分手</a></li>
</ul>
<h5 id="1-4-2-3_为什么最后还要等待两个时间周期呢？">1.4.2.3 为什么最后还要等待两个时间周期呢？</h5><h3 id="1-5_负责域名解析的_DNS_服务">1.5  负责域名解析的 DNS 服务</h3><p>DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。</p>
<h3 id="1-6_各种协议与_HTTP_协议的关系">1.6 各种协议与 HTTP 协议的关系</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-1.6.jpg" alt=""></p>
<h3 id="1-7_URI_和_URL">1.7  URI 和 URL</h3><p>URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。<br>URL 是 URI 的子集。<br>区别就是 URI 定义资源，而 URL 不单定义这个资源，还定义了如何找到这个资源（既访问资源的方式）。</p>
<p>详情参见：</p>
<ul>
<li><a href="http://www.cnblogs.com/youmeng/p/4891788.html" target="_blank" rel="external">Http权威指南笔记(一) URI URL URN 关系</a></li>
</ul>
<hr>
<h2 id="第_2_章_简单的_HTTP_协议">第 2 章  简单的 HTTP 协议</h2><h3 id="2-1_HTTP_请求和响应报文格式">2.1  HTTP 请求和响应报文格式</h3><p>HTTP 请求报文由请求行、请求头部、空行和请求包体 4 个部分组成，如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-2.1.1.jpg" alt=""></p>
<p>HTTP 响应报文由状态行、响应头部、空行和响应包体 4 个部分组成，如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-2.1.2.jpg" alt=""></p>
<p>详情参见：</p>
<ul>
<li><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/28/2612910.html" target="_blank" rel="external">HTTP请求报文和HTTP响应报文</a></li>
</ul>
<h3 id="2-2_告知服务器意图的_HTTP_方法">2.2  告知服务器意图的 HTTP 方法</h3><p>表 2-1：HTTP/1.0 和 HTTP/1.1 支持的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">支持的 HTTP 协议版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td style="text-align:center">获取资源</td>
<td style="text-align:center">1.0、1.1</td>
</tr>
<tr>
<td>POST</td>
<td style="text-align:center">传输实体主体</td>
<td style="text-align:center">1.0、1.1</td>
</tr>
<tr>
<td>PUT</td>
<td style="text-align:center">传输文件</td>
<td style="text-align:center">1.0、1.1</td>
</tr>
<tr>
<td>HEAD</td>
<td style="text-align:center">获得报文首部</td>
<td style="text-align:center">1.0、1.1</td>
</tr>
<tr>
<td>DELETE</td>
<td style="text-align:center">删除文件</td>
<td style="text-align:center">1.0、1.1</td>
</tr>
<tr>
<td>OPTIONS</td>
<td style="text-align:center">询问支持的方法</td>
<td style="text-align:center">1.1</td>
</tr>
<tr>
<td>TRACE</td>
<td style="text-align:center">追踪路径</td>
<td style="text-align:center">1.1</td>
</tr>
<tr>
<td>CONNECT</td>
<td style="text-align:center">要求用隧道协议连接代理</td>
<td style="text-align:center">1.1</td>
</tr>
<tr>
<td>LINK</td>
<td style="text-align:center">建立和资源之间的联系</td>
<td style="text-align:center">1.0</td>
</tr>
<tr>
<td>UNLINK</td>
<td style="text-align:center">断开连接关系</td>
<td style="text-align:center">1.0</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="第_3_章_HTTP_报文内的_HTTP_信息">第 3 章  HTTP 报文内的 HTTP 信息</h2><h3 id="3-1_编码提升传输速率">3.1  编码提升传输速率</h3><h4 id="3-1-1_压缩传输的内容编码">3.1.1  压缩传输的内容编码</h4><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-3.1.1.jpg" alt=""></p>
<p>常用的内容编码有以下几种：</p>
<ol>
<li>gzip（GNU zip）</li>
<li>compress（UNIX 系统的标准压缩）</li>
<li>deflate（zlib）</li>
<li>identity（不进行编码）</li>
</ol>
<h4 id="3-1-2_分割发送的分块传输编码">3.1.2  分割发送的分块传输编码</h4><p>在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-3.1.2.jpg" alt=""></p>
<h3 id="3-2_获取部分内容的范围请求">3.2  获取部分内容的范围请求</h3><p>执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。</p>
<p>针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>由于最近一段时间在找实习，所以陆陆续续面试了几家公司，可结果都跪了….</p>
<p>总结失败的原因有很多，如果要进行个排名的话，<strong>网络</strong>一定能进前三。每每被面试官问到网络相关知识的时候，我都是一脸懵逼样，支支吾吾说不出个所以然。</p>
<p>现在想想，做移动端也有些日子了，可网络知识这块居然只知胜少，究其原因就是自己不求上进，直到找工作的时候被现实打脸了才恍然醒悟。于是，痛定思痛，决定恶补下网络知识，一番 Google 后，决定以《图解 HTTP》作为入门书籍。当然好记性不如烂笔头，读书笔记是少不了的。</p>]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://itangqi.me/tags/HTTP/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="HTTP" scheme="http://itangqi.me/categories/HTTP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从 NSURLConnection 到 NSURLSession]]></title>
    <link href="http://itangqi.me/2016/04/01/from-nsurlconnection-to-nsurlsession/"/>
    <id>http://itangqi.me/2016/04/01/from-nsurlconnection-to-nsurlsession/</id>
    <published>2016-03-31T16:00:00.000Z</published>
    <updated>2016-04-19T08:53:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>现如今的移动应用开发，网络模块几乎成了标配。如果你是早期 iOS 开发者的话，那么你对 <code>NSURLConnection</code>一定不会陌生。但其操作起来有许多不便，这也使得大家更愿意使用第三方库的解决方案，比如大名鼎鼎的 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a> 你一定有所耳闻。正是因为这一点，苹果随着 iOS 7 的发布，也为开发者带来了改进后的原生网络库支持，那就是 NSURLSession。</p>
<p>今天，就让我来给你道一道从 <code>NSURLConnection</code> 到 <code>NSURLSession</code> 那些你知道和不知道的事。 </p>
<a id="more"></a>
<hr>
<h2 id="NSURLConnection">NSURLConnection</h2><p><code>NSURLConnection</code> 作为 Core Foundation / CFNetwork 框架的 API 之上的一个抽象，在 2003 年，随着第一版的 Safari 的发布就发布了。<code>NSURLConnection</code> 这个名字，实际上是指代的 Foundation 框架的 URL 加载系统中一系列相关联的组件：<code>NSURLRequest</code>、<code>NSURLResponse</code>、<code>NSURLProtocol</code>、 <code>NSURLCache</code>、 <code>NSHTTPCookieStorage</code>、<code>NSURLCredentialStorage</code> 以及同名类 <code>NSURLConnection</code>。</p>
<p><code>NSURLRequest</code> 被传递给 <code>NSURLConnection</code>。被委托对象（遵守以前的非正式协议 <code>&lt;NSURLConnectionDelegate&gt;</code> 和 <code>&lt;NSURLConnectionDataDelegate&gt;</code>）异步地返回一个 <code>NSURLResponse</code> 以及包含服务器返回信息的 <code>NSData</code>。</p>
<p>在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据策略（policy）以及可用性（availability）的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应以便将来的请求可以使用。</p>
<p>在把请求发送给服务器的过程中，服务器可能会发出鉴权查询（authentication challenge），这可以由共享的 cookie 或机密存储（credential storage）来自动响应，或者由被委托对象来响应。发送中的请求也可以被注册的 <code>NSURLProtocol</code> 对象所拦截，以便在必要的时候无缝地改变其加载行为。</p>
<h3 id="使用步骤">使用步骤</h3><h4 id="概览">概览</h4><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/from-nsurlconnection-to-nsurlsession-003.png" alt="">（<a href="http://hayageek.com/ios-nsurlsession-example/" target="_blank" rel="external">图片来自</a>）</p>
<h4 id="NSURL">NSURL</h4><p>创建一个 <code>NSURL</code> 对象，设置请求路径：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"协议://主机地址/路径?参数&amp;参数"</span>];</span><br></pre></td></tr></table></figure>
<p>解释如下：</p>
<ul>
<li>协议：不同的协议，代表着不同的资源查找方式、资源传输方式，比如常用的 HTTP、FTP 等</li>
<li>主机地址：存放资源的主机的 IP 地址（域名）</li>
<li>路径：资源在主机中的具体位置</li>
<li>参数：参数可有可无，也可以多个。如果带参数的话，用 “?” 号后面接参数，多个参数的话之间用 “&amp;” 隔开</li>
</ul>
<h4 id="NSURLRequest">NSURLRequest</h4><p>创建一个 <code>NSURLRequest</code> 对象并传入 <code>NSURL</code>，设置请求头和请求体：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url cachePolicy:<span class="built_in">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class="number">15.0</span>];</span><br></pre></td></tr></table></figure>
<p>参数解释如下：</p>
<ul>
<li>requestWithURL：资源路径</li>
<li>cachePolicy：缓存策略（无论使用哪种缓存策略，都会在本地缓存数据），类型为枚举类型，取值如下：<ul>
<li>NSURLRequestUseProtocolCachePolicy = 0 // 默认的缓存策略，使用协议的缓存策略</li>
<li>NSURLRequestReloadIgnoringLocalCacheData = 1 // 每次都从网络加载</li>
<li>NSURLRequestReturnCacheDataElseLoad = 2 // 返回缓存否则加载，很少使用</li>
<li>NSURLRequestReturnCacheDataDontLoad = 3 // 只返回缓存，没有也不加载，很少使用</li>
</ul>
</li>
<li>timeoutInterval：超时时长，默认 60s</li>
</ul>
<p>另外，还可以设置其它一些信息，比如请求头，请求体等等，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 告诉服务器数据为 JSON 类型</span></span><br><span class="line">[request setValue:<span class="string">@"application/json"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>]; </span><br><span class="line"><span class="comment">// 设置请求体（JSON类型）</span></span><br><span class="line"><span class="built_in">NSData</span> *jsonData = [<span class="built_in">NSJSONSerialization</span> dataWithJSONObject:@&#123;<span class="string">@"userid"</span>:<span class="string">@"123456"</span>&#125; options:<span class="built_in">NSJSONWritingPrettyPrinted</span> error:<span class="literal">nil</span>];</span><br><span class="line">request<span class="variable">.HTTPBody</span> = jsonData;</span><br></pre></td></tr></table></figure>
<p>注意，上面的 request 应为 <code>NSMutableURLRequest</code>，即可变类型。（使用 POST 请求的话，那么就必须的使用 <code>NSMutableURLRequest</code>）</p>
<h4 id="NSURLConnection-1">NSURLConnection</h4><p>使用 <code>NSURLConnection</code> 发送请求，通过返回 <code>NSURLResponse</code> 实例和 <code>NSError</code> 实例分析结果，接受服务器返回数据。</p>
<p><code>NSURLConnection</code> 默认的请求类型为 GET，下面分异步和同步介绍 GET 的使用（POST 会在 <code>NSURLSession</code> 中介绍）。</p>
<h5 id="异步请求">异步请求</h5><p>异步是指：在发送请求之后，一边在子线程中接收返回数据，一边执行之后的代码，当返回数据接收完毕后，采用回调的方式通知主线程做处理。同时，异步请求有两种实现方式。</p>
<p>1.使用 block：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[[<span class="built_in">NSOperationQueue</span> alloc] init] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">    <span class="comment">// 有的时候，服务器访问正常，但是会没有数据</span></span><br><span class="line">    <span class="comment">// 以下的 if 是比较标准的错误处理代码</span></span><br><span class="line">    <span class="keyword">if</span> (connectionError != <span class="literal">nil</span> || data == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//给用户的提示信息</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"网络不给力"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>参数说明如下：</p>
<ul>
<li>completionHandler:请求响应后（或者请求超时）执行的代码，queue 为代码添加到的队列，即 block执行的线程<ul>
<li>NSURLResponse 为服务器的响应，真实类型为 NSHTTPURLResponse，通常只在「下载」功能时，才会使用；下面是协议头的参数：<ul>
<li>URL：响应的 URL，有的时候，访问一个 URL 地址，服务器可能会出现重定向，会定位到新的地址</li>
<li>MIMEType（Content-Type）：服务器告诉客户端，可以用什么软件打开二进制数据。网络之所以丰富多采，是因为有丰富的客户端软件。栗子：Windows 上提示安装 Flash 插件</li>
<li>expectedContentLength：预期的内容长度，要下载的文件长度，下载文件时非常有用</li>
<li>suggestedFilename：「建议」的文件名，方便用户直接保存，很多时候，用户并不关心要保存成什么名字</li>
<li>textEncodingName：文本的编码名称 @”UTF8”，大多数都是 UTF8</li>
<li>statusCode：状态码，在做下载操作的时候，需要判断一下</li>
<li>allHeaderFields：所有的响应头字典时候，用户并不关心要保存成什么名字</li>
</ul>
</li>
</ul>
</li>
<li>NSData：服务器返回的数据，例如：JSON、XML</li>
<li>NSError：网络访问错误码</li>
</ul>
<p>2.使用代理（Delegate）:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()&lt;<span class="title">NSURLConnectionDataDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> * url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://itangqi.me"</span>];</span><br><span class="line"><span class="built_in">NSURLRequest</span> * request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line">[<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>];</span><br></pre></td></tr></table></figure>
<p>使用代理可以监测下载过程：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    <span class="comment">// 开始接收数据</span></span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="comment">// 正在接收数据(会调用多次)</span></span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    <span class="comment">// 接收数据失败</span></span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection &#123;</span><br><span class="line">    <span class="comment">// 接收数据完成(成功|失败)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="同步">同步</h5><p>同步是指：数据的请求在主线程来执行，一旦发送同步请求，直至服务器返回数据完成，才可以进行下一步操作，而网络数据加载需要一个时间过程，这样的话就会堵塞主线程，当然这种使用场景很少。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步请求，代码会阻塞在这里一直等待服务器返回，如果 data 为 nil 则请求失败，当获取少量数据时可以使用此方法。</span></span><br><span class="line"><span class="comment">// request 参数同上。</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="NSURLSession">NSURLSession</h2><p>不管怎样，<code>NSURLConnection</code> 作为网络基础架构，已经服务了成千上万的 iOS 和 Mac OS 程序，并且做的还算相当不错。但是这些年，一些用例——尤其是在 iPhone 和 iPad 上面——已经对 <code>NSURLConnection</code> 的几个核心概念提出了挑战，让苹果有理由对它进行重构。</p>
<p>在 2013 的 WWDC 上，苹果推出了 <code>NSURLConnection</code> 的继任者：<code>NSURLSession</code>。</p>
<p>和 <code>NSURLConnection</code> 一样，<code>NSURLSession</code> 指的也不仅是同名类 <code>NSURLSession</code>，还包括一系列相互关联的类。<code>NSURLSession</code> 包括了与之前相同的组件，<code>NSURLRequest</code> 与 <code>NSURLCache</code>，但是把 <code>NSURLConnection</code> 替换成了 <code>NSURLSession</code>、<code>NSURLSessionConfiguration</code> 以及 <code>NSURLSessionTask</code> 的 3 个子类：<code>NSURLSessionDataTask</code>，<code>NSURLSessionUploadTask</code>，<code>NSURLSessionDownloadTask</code>。</p>
<p>与 <code>NSURLConnection</code> 相比，<code>NSURLsession</code> 最直接的改进就是可以配置每个 session 的缓存，协议，cookie，以及证书策略（credential policy），甚至跨程序共享这些信息。这将允许程序和网络基础框架之间相互独立，不会发生干扰。每个 <code>NSURLSession</code> 对象都由一个 <code>NSURLSessionConfiguration</code> 对象来进行初始化，后者指定了刚才提到的那些策略以及一些用来增强移动设备上性能的新选项。</p>
<p><code>NSURLSession</code> 中另一大块就是 session task。它负责处理数据的加载以及文件和数据在客户端与服务端之间的上传和下载。<code>NSURLSessionTask</code> 与 <code>NSURLConnection</code> 最大的相似之处在于它也负责数据的加载，最大的不同之处在于所有的 task 共享其创造者 <code>NSURLSession</code> 这一公共委托者（common delegate）。</p>
<p>我们先来深入探讨 task，过后再来讨论 <code>NSURLSessionConfiguration</code>。</p>
<h3 id="概览-1">概览</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/from-nsurlconnection-to-nsurlsession-002.png" alt="">（<a href="http://hayageek.com/ios-nsurlsession-example/" target="_blank" rel="external">图片来自</a>）</p>
<h3 id="Sessions">Sessions</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用静态的 sharedSession 的方法，该类使用共享的 seesion，该 seesion 使用全局的 Cache，Cookie 和证书</span></span><br><span class="line">+ (<span class="built_in">NSURLSession</span> *)sharedSession;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 NSURLSessionConfiguration 创建对应配置的 seesion</span></span><br><span class="line">+ (<span class="built_in">NSURLSession</span> *)sessionWithConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 也是根据 NSURLSessionConfiguration 创建对应配置的 seesion，并且可以指定 seesion 的委托和委托所处的队列</span></span><br><span class="line">+ (<span class="built_in">NSURLSession</span> *)sessionWithConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration delegate:(<span class="keyword">id</span> &lt;<span class="built_in">NSURLSessionDelegate</span>&gt;)delegate delegateQueue:(<span class="built_in">NSOperationQueue</span> *)queue;</span><br></pre></td></tr></table></figure>
<h3 id="NSURLSessionTask">NSURLSessionTask</h3><p><code>NSURLSession</code> 本身是不会进行请求的，而是通过创建 task 的形式进行网络请求，同一个 NSURLSession 可以创建多个 task，并且这些 task 之间的 cache 和 cookie 是共享的。那么我们就来看看 NSURLSession 都能创建哪些 task 吧。</p>
<p>Task 可以翻译为任务，那么在和网络请求相关的任务中，我们可以理解为：数据请求任务、下载任务、上传任务等。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/from-nsurlconnection-to-nsurlsession-001.png" alt=""></p>
<p>其实从类名就能猜出它们各自的用途：</p>
<ol>
<li><p><code>NSURLSessionDataTask</code>：使用这个 task 来调用 HTTP GET 方式请求，从服务器获取数据到内存。返回的数据格式是 NSData，可根据需要自行转换成 XML、JSON 等数据格式</p>
</li>
<li><p><code>NSURLSessionUploadTask</code>：使用这个 task 来上传磁盘文件到 web 服务器，典型地通过 HTTP POST 或者 PUT 方式</p>
</li>
<li><p><code>NSURLSessionDownloadTask</code>：使用这个 task 来从远程服务器下载文件到临时文件地址</p>
</li>
<li><p><code>NSURLSessionStreamTask</code>：使用这个 task 来执行异步的读和写</p>
</li>
</ol>
<p>你也能暂停，恢复（开始）和取消 tasks。</p>
<h4 id="NSURLSessionDataTask_POST">NSURLSessionDataTask POST</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  简单 Post 请求，POST 和 GET 请求在于对 request 的处理不同，其余和 GET 相同</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)postWithSharedSession &#123;</span><br><span class="line">  <span class="comment">// 获取默认 Session</span></span><br><span class="line">  <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line">  <span class="comment">// 创建 URL</span></span><br><span class="line">  <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://120.25.226.186:32812/login"</span>];</span><br><span class="line">  <span class="comment">// 创建 request</span></span><br><span class="line">  <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">  <span class="comment">// 请求方法</span></span><br><span class="line">  request<span class="variable">.HTTPMethod</span> = <span class="string">@"POST"</span>;</span><br><span class="line">  <span class="comment">// 请求体</span></span><br><span class="line">  request<span class="variable">.HTTPBody</span> = [<span class="string">@"username=1234&amp;pwd=4321"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">  <span class="comment">// 创建任务 task</span></span><br><span class="line">  <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">  <span class="comment">// 获取数据后解析并输出</span></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="comment">// 启动任务</span></span><br><span class="line">  [task resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NSURLSessionDataDelegate_代理方法">NSURLSessionDataDelegate 代理方法</h4><p><code>NSURLSession</code> 提供了 block 的方式处理返回的数据，但是如果我们想要在接收数据的过程中处理数据，我们可以使用 <code>NSURLSessionDataDelegate</code> 的代理方法，分为接收响应、接收数据和请求完成三个阶段。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)sessionDataDelegate &#123;</span><br><span class="line"> <span class="comment">// 创建带有代理方法的自定义 session</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 创建任务</span></span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://120.25.226.186:32812/login?username=1234&amp;pwd=4321"</span>]]];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 启动任务</span></span><br><span class="line">[task resume];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1. 接受到服务器的响应</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"任务完成"</span>);</span><br><span class="line">  <span class="comment">// 必须设置对响应进行允许处理才会执行后面两个操作。</span></span><br><span class="line">  completionHandler(<span class="built_in">NSURLSessionResponseAllow</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2. 接收到服务器的数据（可能调用多次）</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">  <span class="comment">// 处理每次接收的数据</span></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3. 请求成功或者失败（如果失败，error有值）</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    <span class="comment">// 请求完成,成功或者失败的处理</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"SessionTask %s"</span>,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSURLSessionConfiguration">NSURLSessionConfiguration</h3><p><code>NSURLSessionConfiguration</code> 对象用于对 <code>NSURLSession</code> 对象进行初始化。从指定可用网络，到 cookie，安全性，缓存策略，再到使用自定义协议，启动事件的设置，以及用于移动设备优化的几个新属性，你会发现使用 <code>NSURLSessionConfiguration</code> 可以找到几乎任何你想要进行配置的选项。其有三个类工厂方法：</p>
<ol>
<li><p>默认模式（+defaultSessionConfiguration）：返回一个标准的 configuration，工作模式类似于 NSURLConnection，可以使用缓存的 Cache，Cookie，证书（credential）</p>
</li>
<li><p>及时模式（+ephemeralSessionConfiguration）: 临时 session 配置，与默认配置相比，这个配置不会使用缓存的 Cache，Cookie，证书，只会存在内存里，所以当程序退出时，所有的数据都会消失，这对于实现像秘密浏览这种功能来说是很理想的</p>
</li>
<li><p>后台模式（+backgroundSessionConfiguration）：它会创建一个后台 session。后台 session 不同于常规的，普通的 session，它甚至可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程（daemon）提供上下文</p>
</li>
</ol>
<p>除了这三种预设的模式之外 <code>NSURLSessionConfiguration</code> 还可以进行很多的配置。 <code>timeoutIntervalForRequest</code> 和 <code>timeoutIntervalForResource</code> 可以控制网络操作的超时时间。 <code>allowsCellularAccess</code> 属性可以控制是否允许使用无线网络。<code>HTTPAdditionalHeaders</code> 可以指定 HTTP 请求头。</p>
<p><code>NSURLSessionConfiguration</code> 几乎可以完成网络操作的大多数配置功能，并且这些配置都绑定到当前的 Session 中，我们一旦用配置好的 <code>NSURLSessionConfiguration</code> 初始化 <code>NSURLSession</code> 实例后，就不能修改这个 <code>NSURLSession</code> 相关的配置了。所以，一切的配置操作都放在初始化 <code>NSURLSession</code> 之前。</p>
<hr>
<h2 id="iOS_9">iOS 9</h2><ol>
<li><p>在 iOS 7 后，苹果推荐使用 <code>NSURLSession</code>，并在 iOS 9 中废弃了 <code>NSURLConnection</code> </p>
</li>
<li><p>iOS 9 所有网络连接默认为 HTTPS 服务，为此推出 App Transport Security，详情可参见：<a href="https://developer.apple.com/videos/play/wwdc2015/711/" target="_blank" rel="external">Networking with NSURLSession</a></p>
</li>
</ol>
<hr>
<h2 id="NSURLConnection_vs-_NSURLSession">NSURLConnection vs. NSURLSession</h2><ol>
<li><p>后台上传和下载：只需在创建 <code>NSURLSession</code> 的时候配置一个选项，就能得到后台网络的所有好处。这样可以延长电池寿命，并且还支持 UIKit 的多 task，在进程间使用相同的委托模型</p>
</li>
<li><p>能够暂停和恢复网络操作：使用 NSURLSession API 能够暂停，停止，恢复所有的网络任务，再也完全不需要子类化 NSOperation</p>
</li>
<li><p>可配置的容器：对于 <code>NSURLSession</code> 里面的 requests 来说，每个<code>NSURLSession</code> 都是可配置的容器。举个例来说，假如你需要设置 HTTP header 选项，你只用做一次，session 里面的每个 request 就会有同样的配置</p>
</li>
<li><p>提高认证处理：认证是在一个指定的连接基础上完成的。在使用 <code>NSURLConnection</code> 时，如果发出一个访问，会返回一个任意的 request。此时，你就不能确切的知道哪个 request 收到了访问。而在 NSURLSession 中，就能用代理处理认证</p>
</li>
<li><p>丰富的代理模式：在处理认证的时候，<code>NSURLConnection</code> 有一些基于异步的 block 方法，但是它的代理方法就不能处理认证，不管请求是成功或是失败。在 <code>NSURLSession</code> 中，可以混合使用代理和 block 方法处理认证</p>
</li>
<li><p>上传和下载通过文件系统：它鼓励将数据（文件内容）从元数据（URL 和 settings）中分离出来</p>
</li>
</ol>
<h2 id="要点">要点</h2><ol>
<li><p>请求的缓存策略使用 <code>NSURLRequestReloadIgnoringCacheData</code>，忽略本地缓存</p>
</li>
<li><p>服务器响应结束后，要记录 Etag，服务器内容和本地缓存对比是否变化的重要依据</p>
</li>
<li><p>在发送请求时，设置 If-None-Match，并且传入 etag</p>
</li>
<li><p>连接结束后，要判断响应头的状态码，如果是 304，说明本地缓存内容没有发生变化，此时可以使用本地缓存来加载数据，如果缓存文件被意外删除，程序依然运行但会报错，加载数据也失败</p>
</li>
<li><p>GET 缓存的数据会保存在 Cache 目录中 /bundleId 下，Cache.db 中</p>
</li>
</ol>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLConnection_Class/" target="_blank" rel="external">NSURLConnection Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/" target="_blank" rel="external">NSURLSession Class Reference</a></li>
<li><a href="https://www.objc.io/issues/5-ios7/from-nsurlconnection-to-nsurlsession/" target="_blank" rel="external">From NSURLConnection to NSURLSession</a></li>
<li><a href="http://www.cnblogs.com/mddblog/p/5134783.html" target="_blank" rel="external">iOS网络1——NSURLConnection使用详解</a></li>
<li><a href="http://blog.qiji.tech/archives/6454" target="_blank" rel="external">[iOS] NSURLSession</a></li>
<li><a href="http://swiftcafe.io/2015/12/20/nsurlsession/" target="_blank" rel="external">NSURLSession 网络库 - 原生系统送给我们的礼物</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>现如今的移动应用开发，网络模块几乎成了标配。如果你是早期 iOS 开发者的话，那么你对 <code>NSURLConnection</code>一定不会陌生。但其操作起来有许多不便，这也使得大家更愿意使用第三方库的解决方案，比如大名鼎鼎的 <a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a> 你一定有所耳闻。正是因为这一点，苹果随着 iOS 7 的发布，也为开发者带来了改进后的原生网络库支持，那就是 NSURLSession。</p>
<p>今天，就让我来给你道一道从 <code>NSURLConnection</code> 到 <code>NSURLSession</code> 那些你知道和不知道的事。 </p>]]>
    
    </summary>
    
      <category term="NSURLConnection" scheme="http://itangqi.me/tags/NSURLConnection/"/>
    
      <category term="NSURLSession" scheme="http://itangqi.me/tags/NSURLSession/"/>
    
      <category term="Networking" scheme="http://itangqi.me/tags/Networking/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 多线程编程之 NSOperation]]></title>
    <link href="http://itangqi.me/2016/03/28/the-notes-of-learning-nsoperation/"/>
    <id>http://itangqi.me/2016/03/28/the-notes-of-learning-nsoperation/</id>
    <published>2016-03-27T16:00:00.000Z</published>
    <updated>2016-04-19T08:48:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>我们在<a href="http://itangqi.me/2016/03/15/the-notes-of-learning-of-gcd/">《Objective-C 高级编程》读书笔记之 GCD</a> 中，已经学习了多线程编程技术之一 GCD，其简洁易用的特性，我相信你一定深有体会。但即使这样，GCD 也很难满足现实中所有的需求。不过你不用担心，苹果早已为我们提供了另一多线程编程技术，那就是 NSOperation。</p>
<a id="more"></a> 
<hr>
<h2 id="NSOperation">NSOperation</h2><p>以下摘自苹果官方文档：</p>
<blockquote>
<p>The NSOperation class is an abstract class you use to encapsulate the code and data associated with a single task. Because it is abstract, you do not use this class directly but instead subclass or use one of the system-defined subclasses (NSInvocationOperation or NSBlockOperation) to perform the actual task…</p>
</blockquote>
<p>这里只摘录了部分，更详细的内容请移步：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/" target="_blank" rel="external">NSOperation Class Reference</a>。</p>
<p><code>NSOperation</code> 是一个抽象类，你可以用它来封装一个任务的相关代码和数据。因为它是个抽象类，所以你不能直接使用它，而是需要继承并实现其子类或者使用系统内置的两个子类（<code>NSInvocationOperation</code> 和 <code>NSBlockOperation</code>）来执行实际的线程任务。</p>
<p>一个操作（operation）对象是一个<strong>一次性</strong>对象，也就是说，它包含的任务只能执行一次，执行完毕之后就不能再执行了。通常情况下，你只需要把需要执行的 operations 加入到一个操作队列（operation queue - 它是 <code>NSOperationQueue</code> 类的一个实例）即可执行。一个 operation queue 要么直接在二级线程（secondary threads）执行 operations，要么间接的使用 libdispatch 库（熟知的 GCD）来执行 operations。</p>
<p>如果不想使用 operation queue，你也可以在代码中通过直接调用 <code>Operation</code> 自己的 <code>start</code> 方法来执行。手动执行 operations 通常会加重代码负担，因为执行一个不在准备状态（ready state）的 operation 会触发异常，这个 <code>ready</code> 属性就是来反应这个 operation 是否准备就绪的。</p>
<hr>
<h2 id="NSOperationQueue">NSOperationQueue</h2><p>以下摘自苹果官方文档：</p>
<blockquote>
<p>The NSOperationQueue class regulates the execution of a set of NSOperation objects. After being added to a queue, an operation remains in that queue until it is explicitly canceled or finishes executing its task. Operations within the queue (but not yet executing) are themselves organized according to priority levels and inter-operation object dependencies and are executed accordingly. An application may create multiple operation queues and submit operations to any of them…</p>
</blockquote>
<p>更详细的内容请移步：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperationQueue_class/" target="_blank" rel="external">NSOperationQueue Class Reference</a>。</p>
<p><code>NSOperationQueue</code> 类管理着一组 <code>NSOperation</code> 对象的执行，当一个 operation 对象被加入到队列后，它会始终保留在队列中，直到它已经明确的被取消或者完成执行任务。Operations 在队列内（但尚未执行），它们是根据优先级和互相依赖进行组织的，相应的去执行。一个应用可以创建多个操作队列（operation queues）并提交操作（operations）到其中任何一个中。</p>
<p>我相信，熟悉 GCD 的同学，一定不会对<strong>队列</strong>感到陌生，现在看 <code>NSOperationQueue</code> 有木有很亲切~哈哈</p>
<h2 id="使用">使用</h2><p>NSOperation 的基本使用非常简单和易于理解：</p>
<ol>
<li>创建 NSOperation 对象（使用子类），定义需要的操作</li>
<li>创建 NSOperationQueue 对象（操作队列）</li>
<li>将任务添加到操作队列中</li>
</ol>
<p>此时，操作队列会立刻在一条新线程中开始自动执行操作。</p>
<p>创建操作队列和添加任务：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建操作队列</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"><span class="comment">// 添加任务</span></span><br><span class="line">[queue addOperation:operation];</span><br><span class="line"><span class="comment">// 直接添加任务到队列</span></span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="comment">// 任务</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> <code>NSOperation</code> 类自身有个 <code>– (void)start</code> 方法，调用后也会执行操作，但是它会默认在当前线程同步执行，一般我们不会这么使用，而是添加到 <code>NSOperationQueue</code> 中。</p>
<h3 id="NSInvocationOperation">NSInvocationOperation</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 NSInvocationOperation 对象，task 为调用方法，object 为方法参数</span></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *invocationOperation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)task&#123;</span><br><span class="line">    <span class="comment">// 具体操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSBlockOperation">NSBlockOperation</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 NSBlockOperation 对象</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="comment">// 具体操作</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>NSBlockOperation 拥有一个 <code>addExecutionBlock:</code> 的实例方法，可以给指定的 NSBlockOperation 对象添加多个执行用 Block，这些 Block 将会并发执行（其他线程中执行）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 addExecutionBlock: 方法添加操作</span></span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">    <span class="comment">// 具体操作</span></span><br><span class="line">&#125;];</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">    <span class="comment">// 具体操作</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="NSOperation_vs-_GCD">NSOperation vs. GCD</h2><p>GCD 是一个低层次的 C API，能让开发者并行执行任务。与之相对，Operation queues 是对队列模型的高层级抽象，NSOperation 是在 Cocoa 框架下基于 GCD 的封装，相对于 GCD 来说可控性更强，并且加入了一些方便的功能（取消任务、设置依赖、设置最大并发等等）。GCD 中的关键概念 —— 任务和队列，正好对应了 <code>NSOperation</code> 和 <code>NSOperationQueue</code> 两个类，因此在开始 NSOperation 的学习之前，我建议先对 GCD 的基本思想和核心概念有所掌握。</p>
<p>同时，我也知道，NSOperation 是对 GCD 更高层次的封装，所以它有着一些 GCD 无法实现（或者至少说很难实现）的特性，下面就让我们一起来看一看：</p>
<h3 id="取消任务">取消任务</h3><p>当一个 operation 开始执行后，它会一直执行它的任务直到完成或被取消为止。我们可以在任意时间点取消一个 operation ，甚至是在它还未开始执行之前。为了让我们自定义的 operation 能够支持取消事件，我们需要在代码中定期地检查 isCancelled 方法的返回值，一旦检查到这个方法返回 YES ，我们就需要立即停止执行接下来的任务。根据苹果官方的说法，isCancelled 方法本身是足够轻量的，所以就算是频繁地调用它也不会给系统带来太大的负担。</p>
<blockquote>
<p>The isCancelled method itself is very lightweight and can be called frequently without any significant performance penalty.</p>
</blockquote>
<p>通常来说，当我们自定义一个 operation 类时，我们需要考虑在以下几个关键点检查 isCancelled 方法的返回值：</p>
<ul>
<li>在真正开始执行任务之前；</li>
<li>至少在每次循环中检查一次，而如果一次循环的时间本身就比较长的话，则需要检查得更加频繁；</li>
<li>在任何相对来说比较容易中止 operation 的地方。</li>
</ul>
<p>看到这里，我想你应该可以意识到一点，那就是尽管 operation 是支持取消操作的，但却并不是立即取消的，而是在你调用了 operation 的 cancel 方法之后的下一个 isCancelled 的检查点取消的。</p>
<p>也就是说，通过调用 NSOperation 类的 cancel 方法来实现对 operation 的取消。你取消任何 operation 的时候，会是下面三种场景之一：</p>
<ol>
<li>你的 operation 已经完成了，这种情况下 cancel 方法没有任何效果</li>
<li>你的 operation 正在被执行的过程中，这种情况下系统不会强制停止你的 operation 代码，而是将 cancelled 属性置为 true</li>
<li>你的 operation 还在队列中等待被执行，这种情况下你的 operation 就不会被执行</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///  支持取消操作</span></span><br><span class="line">- (<span class="keyword">void</span>)main &#123;</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Start executing %@ with data: %@, mainThread: %@, currentThread: %@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd), <span class="keyword">self</span><span class="variable">.data</span>, [<span class="built_in">NSThread</span> mainThread], [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Loop %@"</span>, @(i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Finish executing %@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span>(<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Exception: %@"</span>, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置依赖">设置依赖</h3><p>通过依赖我们可以设置不同任务间的关系，并确定它们的执行顺序。不过需要注意的是，不正确地设置依赖关系，很可能会出现循环依赖，导致死锁。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> 假设现在有 2 个下载任务：downloadOperation1、downloadOperation2</span><br><span class="line"> 另有一编辑任务：editOperation</span><br><span class="line"> 编辑任务需要等所有下载完成后开始执行，那么可以进行如下设置</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 依赖关系如下设置</span></span><br><span class="line">[editOperation addDependency:downloadOperation1];</span><br><span class="line">[editOperation addDependency:downloadOperation2];</span><br></pre></td></tr></table></figure>
<p>既然可以设置依赖，当然也可以移除依赖，只要使用<code>removeDependency:</code> 方法即可。</p>
<h3 id="设置优先级">设置优先级</h3><p>在 GCD 中，队列具有优先级（共有 4 级），而任务（block）则没有优先级的概念。NSOperation 则正好与之相反，我们可以设置 operation 的优先级。</p>
<p><code>NSOperation</code> 有一个 <code>NSOperationQueuePriority</code> 枚举类型的属性 <code>queuePriority</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSOperationQueuePriority</span>) &#123;</span><br><span class="line">true<span class="built_in">NSOperationQueuePriorityVeryLow</span> = -<span class="number">8</span>L,</span><br><span class="line">true<span class="built_in">NSOperationQueuePriorityLow</span> = -<span class="number">4</span>L,</span><br><span class="line">true<span class="built_in">NSOperationQueuePriorityNormal</span> = <span class="number">0</span>,</span><br><span class="line">true<span class="built_in">NSOperationQueuePriorityHigh</span> = <span class="number">4</span>,</span><br><span class="line">true<span class="built_in">NSOperationQueuePriorityVeryHigh</span> = <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSOperationQueuePriority</span> queuePriority;</span><br></pre></td></tr></table></figure>
<h3 id="设置并发数">设置并发数</h3><p>NSOperationQueue 的属性表示当前队列中最多可运行的线程数。默认为 -1，即不限数，由系统内存和 CPU 决定线程数量。设为 1 的话就相当于 GCD 的串行队列。如需自定义，作为移动端开发，一般以 3 以内为宜，因为虽然任务是在子线程进行处理的，但是 CPU 处理这些过多的子线程可能会影响 UI，让 UI 变卡。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置最大并发数为 5</span></span><br><span class="line">[queue setMaxConcurrentOperationCount:<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="补充">补充</h2><h3 id="任务完成回调">任务完成回调</h3><p>如果我们想在一个 NSOperation 任务执行完毕后做一些后续操作，可以调用 NSOperation 的 <code>completionBlock</code> 属性来实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点语法</span></span><br><span class="line">operation<span class="variable">.completionBlock</span> = ^() &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"任务执行完毕"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 消息语法</span></span><br><span class="line">[operation setCompletionBlock:^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"任务执行完毕"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="-_(void)start;"><code>- (void)start;</code></h3><p>官方文档中有提到过，当我们不想使用 <code>NSOperationQueue</code> 执行任务时，可以调用 <code>- (void)start;</code> 方法（尽管并不建议这么做），但仍然有些要点需要你知道：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;        </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Execute task one in %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Execute task two in %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Execute task three in %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Execute task four in %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">[blockOperation start];</span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3.0</span>];</span><br></pre></td></tr></table></figure>
<p>以上代码会得到这样的执行结果：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Execute task one <span class="keyword">in</span> &lt;<span class="built_in">NSThread</span>: <span class="number">0x100606090</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">Execute task four <span class="keyword">in</span> &lt;<span class="built_in">NSThread</span>: <span class="number">0x100100730</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">Execute task two <span class="keyword">in</span> &lt;<span class="built_in">NSThread</span>: <span class="number">0x100102370</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line">Execute task three <span class="keyword">in</span> &lt;<span class="built_in">NSThread</span>: <span class="number">0x100104630</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>所以，通过直接调用 <code>- (void)start;</code> 方法所执行的 operation，其任务会在<strong>主线程</strong>中执行，而随后通过 <code>addExecutionBlock:</code> 方法添加的任务（block）则是并发执行的。</p>
<h3 id="Block_循环引用">Block 循环引用</h3><p>通常，我们在控制器中会声明并延迟加载一个 NSOperationQueue 对象而非在需要时临时创建（这样可能会多次创建影响性能）。这时如果以 Block 的方式定制任务，比如下面代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span><span class="variable">.queue</span> addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="comment">// 定义任务</span></span><br><span class="line">    <span class="comment">// 返回主队列执行更新 UI 操作</span></span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">        [<span class="keyword">self</span> update<span class="built_in">UIOperation</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>self 即控制器，其对 Block 产生了强引用，而 Block 中由于调用了 self 的方法也指向了 self，这样就出现了循环引用的问题。</p>
<p>我们的解决方案是使用 <code>__weak</code> 创建一个 self 的弱指针对象：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 self 即控制器的弱指针对象，避免 Block 中的循环引用</span></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.queue</span> addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="comment">// 定义任务</span></span><br><span class="line">    <span class="comment">// 返回主队列执行更新UI操作</span></span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">        [weakSelf update<span class="built_in">UIOperation</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这里要特别提到 <code>completionBlock</code> 这个 Block，前面介绍到它是当 NSOperation 对象执行完毕时调用，此时 NSOperation 对象已经从 self 指向的队列中移除，自然也不会出现循环引用。所以在 <code>completionBlock</code> 中请使用 self 而非它的弱指针对象。</p>
<h3 id="mainQueue">mainQueue</h3><p>通过</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [<span class="built_in">NSOperationQueue</span> mainQueue];</span><br></pre></td></tr></table></figure>
<p>方式创建的 queue 是<strong>串行</strong>的。</p>
<h3 id="Operation_Queue_vs-_Dispatch_Queue">Operation Queue vs. Dispatch Queue</h3><p>与 GCD 不同的是，Operation Queues 并不遵循先进先出（FIFO）的顺序。以下是 Operation Queues 和 Dispatch Queues 的不同：</p>
<ol>
<li><p>不遵循 FIFO（先进先出）：在 Operation Queues 中，你可以设置 operation（操作）的执行优先级，并且可以在 operation 之间添加依赖，这意味着你可以定义某些 operation，使得它们可以在另外一些 operation 执行完毕之后再被执行。这就是为什么它们不遵循先进先出的顺序。</p>
</li>
<li><p>默认情况下 Operation Queues 是并发执行：虽然你不能将其改成串行队列，但还是有一种方法，通过在 operation 之间添加相依性来让 Operation Queues 中的任务按序执行。</p>
</li>
<li><p>Operation Queues 是 NSOperationQueue 类的实例，任务被封装在 NSOperation 的实例中。</p>
</li>
</ol>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/" target="_blank" rel="external">NSOperation Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperationQueue_class/" target="_blank" rel="external">NSOperationQueue Class Reference</a></li>
<li><a href="http://www.appcoda.com/ios-concurrency/" target="_blank" rel="external">iOS Concurrency: Getting Started with NSOperation and Dispatch Queues</a></li>
<li><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></li>
<li><a href="http://blog.qiji.tech/archives/3713" target="_blank" rel="external">iOS中的多线程及NSOperation介绍</a></li>
<li><a href="https://bestswifter.com/multithreadconclusion/" target="_blank" rel="external">iOS多线程编程——GCD与NSOperation总结</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>我们在<a href="http://itangqi.me/2016/03/15/the-notes-of-learning-of-gcd/">《Objective-C 高级编程》读书笔记之 GCD</a> 中，已经学习了多线程编程技术之一 GCD，其简洁易用的特性，我相信你一定深有体会。但即使这样，GCD 也很难满足现实中所有的需求。不过你不用担心，苹果早已为我们提供了另一多线程编程技术，那就是 NSOperation。</p>]]>
    
    </summary>
    
      <category term="NSOperation" scheme="http://itangqi.me/tags/NSOperation/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SDWebImage 源码阅读笔记（二）]]></title>
    <link href="http://itangqi.me/2016/03/21/the-notes-of-learning-sdwebimage-two/"/>
    <id>http://itangqi.me/2016/03/21/the-notes-of-learning-sdwebimage-two/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2016-04-19T08:30:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>我们在第一篇文章<a href="">《SDWebImage 源码阅读笔记（一）》</a>中，已经了解到，当我们调用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[cell<span class="variable">.imageView</span> sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</span><br><span class="line">                  placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]];</span><br></pre></td></tr></table></figure>
<p>时，其实是通过 <code>SDWebImageManager</code> 类进行协调，调用 <code>SDImageCache</code> 与 <code>SDWebImageDownloader</code> 来实现图片的缓存查询与网络下载的。那么今天在第二篇中，就让我们来对 <code>SDImageCache</code> 一探究竟吧：）</p>
<a id="more"></a> 
<hr>
<h2 id="SDImageCache">SDImageCache</h2><p>在 <code>SDImageCache.h</code> 中你可以看到关于 SDImageCache 的描述：</p>
<blockquote>
<p>SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed asynchronous so it doesn’t add unnecessary latency to the UI.</p>
</blockquote>
<p>该类维护了一个内存缓存与一个可选的磁盘缓存。同时，磁盘缓存的写操作是异步的，所以它不会对 UI 造成不必要的影响。</p>
<p>每次查询图片时，首先会根据图片的 URL 对应的 key 值先检查内存中是否有对应的图片，如果有则直接返回；如果没有则在 ioQueue 中去磁盘中查找，其 key 是根据 URL 生成的 MD5 值，找到之后先将图片缓存在内存中，然后在把图片返回：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSOperation</span> *)queryDiskCacheForKey:(<span class="built_in">NSString</span> *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    <span class="keyword">if</span> (!doneBlock) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        doneBlock(<span class="literal">nil</span>, SDImageCacheTypeNone);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先检查内存缓存（查询是同步的），如果查找到，则直接回调 doneBlock 并返回</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (operation<span class="variable">.isCancelled</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建自动释放池，内存及时释放</span></span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        	<span class="comment">// 检查磁盘缓存（查询是异步的），如果查找到，则将其放到内存缓存，并调用 doneBlock 回调</span></span><br><span class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</span><br><span class="line">            <span class="keyword">if</span> (diskImage) &#123;</span><br><span class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                <span class="comment">// 缓存至内存（NSCache）中</span></span><br><span class="line">                [<span class="keyword">self</span><span class="variable">.memCache</span> setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line">truetruetrue<span class="comment">// 返回主线程设置图片</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="NSCache">NSCache</h3><blockquote>
<p>An NSCache object is a collection-like container, or cache, that stores key-value pairs, similar to the NSDictionary class. </p>
</blockquote>
<p>NSCache 是苹果官方提供的缓存类，用法与 NSMutableDictionary 的用法很相似，在 SDWebImage 和 AFNetworking 中，使用它来管理缓存。同样是以 key-value 的形式进行存储，那么 NSCache 与 NSMutableDictionary 等集合类的区别或者说优势又是哪些呢？</p>
<ol>
<li><p>NSCache 类结合了各种<strong>自动删除</strong>策略，以确保不会占用过多的系统内存。如果其它应用需要内存时，系统自动执行这些策略。当调用这些策略时，会从缓存中删除一些对象，以最大限度减少内存的占用</p>
</li>
<li><p>NSCache 是<strong>线程安全</strong>的，我们可以在不同的线程中添加、删除和查询缓存中的对象，而不需要锁定缓存区域</p>
</li>
<li><p>不像 NSMutableDictionary 对象，NSCache 对象并不会拷贝键（key），而是会强引用它</p>
</li>
</ol>
<h4 id="要点">要点</h4><ol>
<li><p>在开发者自己不编写加锁代码的前提下，多个线程便可以同时访问 NSCache</p>
</li>
<li><p>NSCache 对象不拷贝键的原因在于：很多时候，键都是由不支持拷贝操作的对象来充当的。所以说，在键不支持拷贝操作的情况下，该类用起来比字典更方便</p>
</li>
<li><p>可以给 NSCache 对象设置上限，用以限制缓存中的对象总个数及「总成本」，而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的「硬限制」，它们仅对 NSCache 起指导作用 </p>
</li>
<li><p>将 NSPurgeableData 与 NSCache 搭配使用，可实现自动清除数据的功能，也就是说，当 NSPurgeableData 对象所占内存为系统所丢弃时，该对象自身也会从缓存中移除</p>
</li>
<li><p>如果缓存使用得当，那么应用程序的响应速度就能提高。只有那种「重新计算起来很费事的」数据，才值得放入缓存，比如那些需要从网络获取或者从磁盘读取的数据</p>
</li>
<li><p>内存查询是同步，磁盘查询是异步</p>
</li>
</ol>
<hr>
<h3 id="磁盘">磁盘</h3><p>磁盘缓存的处理则是使用 NSFileManager 对象来实现的。默认以 <code>com.hackemist.SDWebImageCache.default</code> 为磁盘的缓存命名空间，程序运行后，可以在应用程序的文件夹 <code>Library/Caches/default/com.hackemist.SDWebImageCache.default</code> 下看到一些缓存文件。另外，SDImageCache 还定义了一个串行队列，来异步存储图片。</p>
<p>在磁盘查询的时候，会在后台将 NSData 转成 UIImage，并完成相关的解码工作:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)diskImageForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> sd_imageWithData:data];</span><br><span class="line">        image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldDecompressImages</span>) &#123;</span><br><span class="line">            image = [<span class="built_in">UIImage</span> decodedImageWithImage:image];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="要点-1">要点</h4><ol>
<li>为何要进行 decode，参见：<a href="http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/" target="_blank" rel="external">Avoiding Image Decompression Sickness</a></li>
</ol>
<hr>
<h3 id="存储图片">存储图片</h3><p>当下载完图片后，会先将图片保存到 NSCache 中，并把图片像素大小作为该对象的 cost 值，同时如果需要保存到硬盘，会先判断图片的格式，PNG 或者 JPEG，并保存对应的 NSData 到缓存路径中，文件名为 URL 的 MD5 值：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)storeImage:(<span class="built_in">UIImage</span> *)image recalculateFromImage:(<span class="built_in">BOOL</span>)recalculate imageData:(<span class="built_in">NSData</span> *)imageData forKey:(<span class="built_in">NSString</span> *)key toDisk:(<span class="built_in">BOOL</span>)toDisk &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 内存缓存，将其存入 NSCache 中，同时传入图片的消耗值，cost 为像素值（当内存受限或者所有缓存对象的总代价超过了最大允许的值时，缓存会移除其中的一些对象）</span></span><br><span class="line">  [<span class="keyword">self</span><span class="variable">.memCache</span> setObject:image forKey:key cost:image<span class="variable">.size</span><span class="variable">.height</span> * image<span class="variable">.size</span><span class="variable">.width</span> * image<span class="variable">.scale</span> * image<span class="variable">.scale</span>];</span><br><span class="line">  <span class="keyword">if</span> (toDisk) &#123;</span><br><span class="line">    <span class="comment">// 如果确定需要磁盘缓存，则将缓存操作作为一个任务放入 ioQueue 中</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^&#123;</span><br><span class="line">      <span class="comment">// 构建一个 data，用来存储到 disk 中，默认值为 imageData</span></span><br><span class="line">      <span class="built_in">NSData</span> *data = imageData;</span><br><span class="line">      <span class="keyword">if</span> (image &amp;&amp; (recalculate || !data)) &#123;</span><br><span class="line"><span class="preprocessor">#if TARGET_OS_IPHONE</span></span><br><span class="line">        <span class="comment">// 需要确定图片是 PNG 还是 JPEG。PNG 图片容易检测，因为有一个唯一签名。PNG 图像的前 8 个字节总是包含以下值：137 80 78 71 13 10 26 10</span></span><br><span class="line">        <span class="comment">// 在 imageData 为 nil 的情况下假定图像为 PNG。我们将其当作 PNG 以避免丢失透明度。而当有图片数据时，我们检测其前缀，确定图片的类型</span></span><br><span class="line">        <span class="built_in">BOOL</span> imageIsPng = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">if</span> ([imageData length] &gt;= [kPNGSignatureData length]) &#123;</span><br><span class="line">          imageIsPng = ImageDataHasPNGPreffix(imageData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 image 是 PNG 格式，就是用 UIImagePNGRepresentation 将其转化为 NSData，否则按照 JPEG 格式转化，并且压缩质量为 1，即无压缩</span></span><br><span class="line">        <span class="keyword">if</span> (imageIsPng) &#123;</span><br><span class="line">          data = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          data = <span class="built_in">UIImageJPEGRepresentation</span>(image, (<span class="built_in">CGFloat</span>)<span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="preprocessor">#else</span></span><br><span class="line">        data = [<span class="built_in">NSBitmapImageRep</span> representationOfImageRepsInArray:image<span class="variable">.representations</span> usingType: <span class="built_in">NSJPEGFileType</span> properties:<span class="literal">nil</span>];</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建缓存文件并存储图片（使用 fileManager）</span></span><br><span class="line">      <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">          [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存 data 到指定的路径中</span></span><br><span class="line">        [_fileManager createFileAtPath:[<span class="keyword">self</span> defaultCachePathForKey:key] contents:data attributes:<span class="literal">nil</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="清理图片">清理图片</h3><p>SDImageCache 会在系统发出低内存警告时释放内存，并且在程序进入 UIApplicationWillTerminateNotification 时，清理<strong>磁盘缓存</strong>，清理磁盘的机制是：</p>
<ol>
<li><p>删除过期的图片，默认 7 天过期，可以通过 maxCacheAge 修改过期天数。</p>
</li>
<li><p>如果缓存的数据大小超过设置的最大缓存 maxCacheSize，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间，可以通过修改 maxCacheSize 来改变最大缓存大小。</p>
</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span><span class="variable">.diskCachePath</span> isDirectory:<span class="literal">YES</span>];</span><br><span class="line">        <span class="built_in">NSArray</span> *resourceKeys = @[<span class="built_in">NSURLIsDirectoryKey</span>, <span class="built_in">NSURLContentModificationDateKey</span>, <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该枚举器预先获取缓存文件的有用的属性</span></span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></span><br><span class="line">                                                                 errorHandler:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSDate</span> *expirationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-<span class="keyword">self</span><span class="variable">.maxCacheAge</span>];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *cacheFiles = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="built_in">NSUInteger</span> currentCacheSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举缓存文件夹中所有文件，该迭代有两个目的：移除比过期日期更老的文件；存储文件属性以备后面执行基于缓存大小的清理操作 </span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *urlsToDelete = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过文件夹 </span></span><br><span class="line">            <span class="keyword">if</span> ([resourceValues[<span class="built_in">NSURLIsDirectoryKey</span>] boolValue]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除早于有效期的老文件</span></span><br><span class="line">            <span class="built_in">NSDate</span> *modificationDate = resourceValues[<span class="built_in">NSURLContentModificationDateKey</span>];</span><br><span class="line">            <span class="keyword">if</span> ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储文件的引用并计算所有文件的总大小，以备后用 </span></span><br><span class="line">            <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">            currentCacheSize += [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line">            [cacheFiles setObject:resourceValues forKey:fileURL];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</span><br><span class="line">            [_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果磁盘缓存的大小大于我们配置的最大大小，则执行基于文件大小的清理，我们首先删除最早的文件 </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.maxCacheSize</span> &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span><span class="variable">.maxCacheSize</span>) &#123;</span><br><span class="line">            <span class="comment">// 以设置的最大缓存大小的一半作为清理目标</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span><span class="variable">.maxCacheSize</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按照最后修改时间来排序剩下的缓存文件 </span></span><br><span class="line">            <span class="built_in">NSArray</span> *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></span><br><span class="line">                                                            usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</span><br><span class="line">                                                                <span class="keyword">return</span> [obj1[<span class="built_in">NSURLContentModificationDateKey</span>] compare:obj2[<span class="built_in">NSURLContentModificationDateKey</span>]];</span><br><span class="line">                                                            &#125;];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除文件，直到缓存总大小降到我们期望的大小</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</span><br><span class="line">                    <span class="built_in">NSDictionary</span> *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">                    currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>关于 <code>SDImageCache</code> 的内容大致就这么多，接下来就让我们一起来看一下 <code>SDWebImageDownloader</code> 中都暗藏了哪些玄机吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>我们在第一篇文章<a href="">《SDWebImage 源码阅读笔记（一）》</a>中，已经了解到，当我们调用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[cell<span class="variable">.imageView</span> sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</span><br><span class="line">                  placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]];</span><br></pre></td></tr></table></figure>
<p>时，其实是通过 <code>SDWebImageManager</code> 类进行协调，调用 <code>SDImageCache</code> 与 <code>SDWebImageDownloader</code> 来实现图片的缓存查询与网络下载的。那么今天在第二篇中，就让我们来对 <code>SDImageCache</code> 一探究竟吧：）</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="SDWebImage" scheme="http://itangqi.me/tags/SDWebImage/"/>
    
      <category term="Source code" scheme="http://itangqi.me/tags/Source-code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SDWebImage 源码阅读笔记（一）]]></title>
    <link href="http://itangqi.me/2016/03/19/the-notes-of-learning-sdwebimage-one/"/>
    <id>http://itangqi.me/2016/03/19/the-notes-of-learning-sdwebimage-one/</id>
    <published>2016-03-18T16:00:00.000Z</published>
    <updated>2016-04-19T08:29:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>说来惭愧，我之前从事 Android 开发，用过许多著名的第三方库，不过仅仅停留在简单的调用 API 阶段，从未涉及到源码的阅读以了解其背后的实现原理，所以一直处于「知其然，而不知所以然」的状态。</p>
<p>如今转投 iOS 怀抱的我，决定将阅读优秀项目的源码作为学习的一部分，而且是带着<strong>疑问</strong>去阅读。由于在项目中使用及考虑到 SDWebImage 的普及程度，其顺理成章的成为了我第一个阅读的项目。</p>
<p>话不多说，让我们开始吧！</p>
<a id="more"></a> 
<hr>
<h2 id="简介">简介</h2><blockquote>
<p>Asynchronous image downloader with cache support as a UIImageView category.</p>
</blockquote>
<p>言简意赅：SDWebImage 以 UIImageView category（分类）的形式，来支持图片的异步下载与缓存。</p>
<p>其提供了以下功能：</p>
<ol>
<li>以 UIImageView 的分类，来支持网络图片的加载与缓存管理</li>
<li>一个异步的图片加载器</li>
<li>一个异步的内存 + 磁盘图片缓存</li>
<li>支持 GIF </li>
<li>支持 WebP</li>
<li>后台图片解压缩处理</li>
<li>确保同一个 URL 的图片不被多次下载</li>
<li>确保虚假的 URL 不会被反复加载</li>
<li>确保下载及缓存时，主线程不被阻塞</li>
<li>使用 GCD 与 ARC</li>
<li>支持 Arm64</li>
</ol>
<hr>
<h2 id="UIImageView+WebCache">UIImageView+WebCache</h2><p>首先，SDWebImage 最常见的使用场景想必如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;SDWebImage/UIImageView+WebCache.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *MyIdentifier = <span class="string">@"MyIdentifier"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];</span><br><span class="line">    <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</span><br><span class="line">        cell = [[[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span></span><br><span class="line">                                       reuseIdentifier:MyIdentifier] autorelease];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里，我们使用 UIImageView 分类提供的 sd_setImageWithURL: 方法来加载网络图片</span></span><br><span class="line">    [cell<span class="variable">.imageView</span> sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</span><br><span class="line">                      placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]];</span><br><span class="line"></span><br><span class="line">    cell<span class="variable">.textLabel</span><span class="variable">.text</span> = <span class="string">@"My Text"</span>;</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在使用 UITableView 时，往往需要在 Cell 上显示来自网络的图片，这里最关键的一行代码便是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[cell<span class="variable">.imageView</span> sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</span><br><span class="line">                  placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]];</span><br></pre></td></tr></table></figure>
<p>于是我们「CMD + 左键」来到了 <code>UIImageView+WebCache</code> 查看具体的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 根据 url、placeholder 与 custom options 为 imageview 设置 image</span><br><span class="line"> *</span><br><span class="line"> * 下载是异步的，并且被缓存的</span><br><span class="line"> *</span><br><span class="line"> * @param url            网络图片的 url 地址</span><br><span class="line"> * @param placeholder    用于预显示的图片</span><br><span class="line"> * @param options        一些定制化选项</span><br><span class="line"> * @param progressBlock  下载时的 Block，其定义为：typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize);</span><br><span class="line"> * @param completedBlock 下载完成时的 Block，其定义为：typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage *image, NSData *data, NSError *error, BOOL finished);</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="built_in">NSURL</span> *)url placeholderImage:(<span class="built_in">UIImage</span> *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</span><br><span class="line">    [<span class="keyword">self</span> sd_cancelCurrentImageLoad];</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.image</span> = placeholder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager<span class="variable">.sharedManager</span> downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                    wself<span class="variable">.image</span> = image;</span><br><span class="line">                    [wself setNeedsLayout];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">                        wself<span class="variable">.image</span> = placeholder;</span><br><span class="line">                        [wself setNeedsLayout];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:-<span class="number">1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</span><br><span class="line">            <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">                completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然代码只有几十行，但其中涉及到的知识点却可不少哦，不要急，让我们将迷雾一层层剥开：</p>
<hr>
<h2 id="UIView+WebCacheOperation">UIView+WebCacheOperation</h2><p>首先来看：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> sd_cancelCurrentImageLoad];</span><br></pre></td></tr></table></figure>
<p>「CMD + 左键」后带我们来到了 <code>UIView+WebCacheOperation</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sd_cancelImageLoadOperationWithKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">// 取消正在进行的下载队列</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *operationDictionary = [<span class="keyword">self</span> operationDictionary];</span><br><span class="line">    <span class="keyword">id</span> operations = [operationDictionary objectForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (operations) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([operations isKindOfClass:[<span class="built_in">NSArray</span> class]]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation <span class="keyword">in</span> operations) &#123;</span><br><span class="line">                <span class="keyword">if</span> (operation) &#123;</span><br><span class="line">                    [operation cancel];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([operations conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)])</span>&#123;</span><br><span class="line">            [(<span class="keyword">id</span>&lt;SDWebImageOperation&gt;) operations cancel];</span><br><span class="line">        &#125;</span><br><span class="line">        [operationDictionary removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>框架中的所有操作实际上都是通过一个 operationDictionary（具体查看 UIView+WebCacheOperation）来管理的，而这个 Dictionary 实际上是通过动态的方式（详情可参见：<a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="external">Objective-C Associated Objects 的实现原理</a>）添加到 UIView 上的一个属性，至于为什么添加到 UIView 上, 主要是因为这个 operationDictionary 需要在 UIButton 和 UIImageView 上重用，所以需要添加到它们的根类上。</p>
<p>当执行 <code>sd_setImageWithURL:</code> 函数时，首先会 cancel 掉 operationDictionary 中已经存在的 operation，并重新创建一个新的 SDWebImageCombinedOperation 对象来获取 image，该 operation 会被存入 operationDictionary 中。</p>
<p>这样来保证每个 UIImageView 对象中永远只存在一个 operation，当前只允许一个图片网络请求，该 operation 负责从缓存中获取 image 或者是重新下载 image。</p>
<p><strong><code>SDWebImageCombinedOperation</code> 的 cancel 操作同时会 cacel 掉缓存查询的 operation 以及 downloader 的 operation</strong></p>
<hr>
<h2 id="dispatch_main_sync_safe_&amp;_dispatch_main_async_safe_宏定义">dispatch_main_sync_safe &amp; dispatch_main_async_safe 宏定义</h2><p>再来看：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_main_async_safe(^&#123;</span><br><span class="line">           <span class="keyword">self</span><span class="variable">.image</span> = placeholder;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码中的 <code>dispatch_main_sync_safe</code> 与 <code>dispatch_main_async_safe</code> 均为宏定义, 点进去一看发现宏是这样定义的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#define dispatch_main_sync_safe(block)\</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> isMainThread]) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;\</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define dispatch_main_async_safe(block)\</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> isMainThread]) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;\</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>相信你通过这两个宏的名字就能猜到它们的作用了: 因为图像的绘制只能在主线程完成，所以<code>dispatch_main_sync_safe</code> 与 <code>dispatch_main_async_safe</code> 就是为了保证 block 能在主线程中执行。</p>
<hr>
<h2 id="SDWebImageManager">SDWebImageManager</h2><p>在 <code>SDWebImageManager.h</code> 中你可以看到关于 SDWebImageManager 的描述：</p>
<blockquote>
<p>The SDWebImageManager is the class behind the UIImageView+WebCache category and likes. It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache). You can use this class directly to benefit from web image downloading with caching in another context than a UIView.</p>
</blockquote>
<p>这个类就是隐藏在 <code>UIImageView+WebCache</code> 背后，用于处理异步下载和图片缓存的类，当然你也可以直接使用 SDWebImageManager 的上述方法 <code>downloadImageWithURL:options:progress:completed:</code> 来直接下载图片：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 如果在缓存中则直接返回，否则根据所给的 URL 下载图片</span><br><span class="line"> * </span><br><span class="line"> * @param url            网络图片的 url 地址</span><br><span class="line"> * @param options        一些定制化选项</span><br><span class="line"> * @param progressBlock  下载时的 Block，其定义为：typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize);</span><br><span class="line"> * @param completedBlock 下载完成时的 Block，其定义为：typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage *image, NSData *data, NSError *error, BOOL finished);</span><br><span class="line"> * @return 				 返回 SDWebImageOperation 的实例</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 前面省略 n 行，主要作了如下处理：</span><br><span class="line">     * 1. 判断 url 的合法性  </span><br><span class="line">     * 2. 创建 SDWebImageCombinedOperation 对象  </span><br><span class="line">     * 3. 查看 url 是否是之前下载失败过的  </span><br><span class="line">     * 4. 如果 url 为 nil，或者在不可重试的情况下是一个下载失败过的 url，则直接返回操作对象并调用完成回调 </span><br><span class="line">    */</span></span><br><span class="line">    <span class="comment">// 根据 URL 生成对应的 key，没有特殊处理为 [url absoluteString];</span></span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</span><br><span class="line">    <span class="comment">// 去缓存中查找图片（参见 SDImageCache）</span></span><br><span class="line">    operation<span class="variable">.cacheOperation</span> = [<span class="keyword">self</span><span class="variable">.imageCache</span> queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">/* ... */</span></span><br><span class="line">       <span class="comment">// 如果在缓存中没有找到图片，或者采用的 SDWebImageRefreshCached 选项，则从网络下载</span></span><br><span class="line">        <span class="keyword">if</span> ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span><span class="variable">.delegate</span> respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span><span class="variable">.delegate</span> imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                  <span class="comment">// 如果图片找到了，但是采用的 SDWebImageRefreshCached 选项，通知获取到了图片，并再次从网络下载，使 NSURLCache 重新刷新</span></span><br><span class="line">                     completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 下载选项设置 */</span> </span><br><span class="line">            <span class="comment">// 使用 imageDownloader 开启网络下载</span></span><br><span class="line">            <span class="keyword">id</span> &lt;SDWebImageOperation&gt; subOperation = [<span class="keyword">self</span><span class="variable">.imageDownloader</span> downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                <span class="comment">/* ... */</span></span><br><span class="line">               <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                     <span class="comment">// 下载完成后，先将图片保存到缓存中，然后主线程返回</span></span><br><span class="line">                     [<span class="keyword">self</span><span class="variable">.imageCache</span> storeImage:downloadedImage recalculateFromImage:<span class="literal">NO</span> imageData:data forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                        &#125;</span><br><span class="line">                     dispatch_main_sync_safe(^&#123;</span><br><span class="line">                            <span class="keyword">if</span> (!weakOperation<span class="variable">.isCancelled</span>) &#123;</span><br><span class="line">                                completedBlock(downloadedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">          <span class="comment">/* ... */</span></span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</span><br><span class="line">          <span class="comment">// 在缓存中找到图片了，直接返回</span></span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                <span class="keyword">if</span> (!weakOperation<span class="variable">.isCancelled</span>) &#123;</span><br><span class="line">                    completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更详细的注解可参见：<a href="http://www.jianshu.com/p/6ae6f99b6c4c" target="_blank" rel="external">SDWebImage源码解析之SDWebImageManager的注解</a></p>
<h3 id="要点">要点</h3><ol>
<li><p>在 SDWebImageManager 中管理了一个 failedURLs 的 NSMutableSet，里面下载失败的 url 会被存储下来。同时，可以通过 SDWebImageRetryFailed 来强制继续重试下载</p>
</li>
<li><p>查找缓存，若缓存中没有 image 则通过 SDWebImageDownloader 来进行下载，下载完成后通过 SDImageCache 进行缓存，会同时缓存到 memCache 和 diskCache 中</p>
</li>
</ol>
<hr>
<p>可以看到 SDWebImageManager 这个类的主要作用就是为 UIImageView+WebCache 和 SDWebImageDownloader，SDImageCache 之间构建一个桥梁，使它们能够更好的协同工作，在接下来的系列文章中，就让我们一探究竟：它是如何协调异步下载和图片缓存的？</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>说来惭愧，我之前从事 Android 开发，用过许多著名的第三方库，不过仅仅停留在简单的调用 API 阶段，从未涉及到源码的阅读以了解其背后的实现原理，所以一直处于「知其然，而不知所以然」的状态。</p>
<p>如今转投 iOS 怀抱的我，决定将阅读优秀项目的源码作为学习的一部分，而且是带着<strong>疑问</strong>去阅读。由于在项目中使用及考虑到 SDWebImage 的普及程度，其顺理成章的成为了我第一个阅读的项目。</p>
<p>话不多说，让我们开始吧！</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="SDWebImage" scheme="http://itangqi.me/tags/SDWebImage/"/>
    
      <category term="Source code" scheme="http://itangqi.me/tags/Source-code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Objective-C 高级编程》读书笔记之 GCD]]></title>
    <link href="http://itangqi.me/2016/03/15/the-notes-of-learning-gcd/"/>
    <id>http://itangqi.me/2016/03/15/the-notes-of-learning-gcd/</id>
    <published>2016-03-14T16:00:00.000Z</published>
    <updated>2016-04-17T03:53:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文作为《Objective-C 高级编程》读书笔记的第三篇，也是最后一篇，给大家带来的是关于 Grand Central Dispatch (GCD) 的知识点总结。</p>
<a id="more"></a> 
<hr>
<h2 id="概念">概念</h2><p>Grand Central Dispatch (GCD) 是异步执行任务的技术之一。开发者只需要定义想执行的任务并追加到适当的 Dispatch Queue 中，GCD 就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率。</p>
<p>以下摘自苹果的官方文档：</p>
<blockquote>
<p>Grand Central Dispatch (GCD) comprises language features, runtime libraries, and system enhancements that provide systemic, comprehensive improvements to the support for concurrent code execution on multicore hardware in iOS and OS X.</p>
<p>The BSD subsystem, CoreFoundation, and Cocoa APIs have all been extended to use these enhancements to help both the system and your application to run faster, more efficiently, and with improved responsiveness. </p>
</blockquote>
<p>一句话总结就是：<strong>GCD 用我们难以置信的非常简洁的记述方法，实现了极为复杂繁琐的多线程编程，可以说这是一项划时代的技术。</strong></p>
<hr>
<h2 id="多线程编程">多线程编程</h2><p>在讲多线程之前，首先来复习下相关概念：</p>
<ul>
<li><p><strong>进程</strong>：一个具有一定独立功能的程序关于某个数据集合的一次运行活动，进程是系统进行资源分配和调度的一个独立单位，可以理解成一个运行中的应用程序。</p>
</li>
<li><p><strong>线程</strong>：进程的一个实体，是 CPU 调度和分派的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
</li>
<li><p><strong>上下文切换（Context Switch）</strong>：当一个进程中有多个线程来回切换时，Context Switch 用来记录执行状态，这样的进程和一般的多线程进程没有太大差别，但会产生一些额外的开销。</p>
</li>
</ul>
<p>由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上去就好像 1 个 CPU 核能够并列地执行多个线程一样。而且在具有多个 CPU 核的情况下，就不是「看上去像」了，而是真的提供了多个 CPU 核并行执行多个线程的技术。</p>
<p>这种利用多线程编程的技术就被称为「多线程编程」。</p>
<h3 id="多线程编程的问题">多线程编程的问题</h3><p>但是，多线程编程实际上是一种易发生各种问题的编程技术。比如多个线程更新相同的资源会导致数据的不一致（数据竞争）、停止等待事件的线程会导致多个线程相互持续等待（死锁）、使用太多线程会消耗大量内存等。如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-gcd-001.png" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-gcd-002.png" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-gcd-003.png" alt=""></p>
<h3 id="多线程编程的优点">多线程编程的优点</h3><p>尽管极易发生各种问题，也应当使用多线程编程。这是为什么呢？因为使用多线程编程可以保证应用程序的响应性能。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-gcd-004.png" alt=""></p>
<p>使用多线程编程，在执行长时间的处理时仍可保证用户界面的响应性能。</p>
<p>GCD 大大简化了偏于复杂的多线程编程的实现。接下来我们就来看下 GCD 的 API。</p>
<hr>
<h2 id="GCD_的_API">GCD 的 API</h2><p>关于 GCD 相关 API 的详细讲解与使用案例，可以直接参见官方文档或者其他博客，本文仅对我在学习 GCD 过程中觉得难以理解的知识点进行简单总结。</p>
<h3 id="Dispatch_Queue">Dispatch Queue</h3><p>首先回顾一下苹果官方对 GCD 的说明：<strong>开发者要做的只是定义想执行的任务并追加到适当的 Dispatch Queue 中。</strong></p>
<p>那么「Dispatch Queue」是什么呢？</p>
<p>如其名称所示，是执行处理的等待队列。应用程序编程人员通过 dispatch_async 函数等 API，在 Block 语法中记述想执行的处理并将其追加到 Dispatch Queue 中。<strong>Dispatch Queue</strong> 按照追加的顺序（先进先出 FIFO，First-In-First-Out）执行处理。</p>
<p>GCD 提供两种 Dispatch Queue:</p>
<table>
<thead>
<tr>
<th>Dispatch Queue 的种类</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial Dispatch Queue</td>
<td style="text-align:center">等待现在执行中处理结束</td>
<td style="text-align:center">多个线程更新相同资源导致数据竞争时 </td>
</tr>
<tr>
<td>Concurrent Dispatch Queue</td>
<td style="text-align:center">不等待现在执行中处理结束</td>
<td style="text-align:center">并行执行不发生数据竞争等问题的处理时</td>
</tr>
</tbody>
</table>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-gcd-005.png" alt=""></p>
<h3 id="dispatch_sync/dispatch_async">dispatch_sync/dispatch_async</h3><p>关于同步异步、串行并行和线程的关系，下面通过一个表格来总结：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">同步</th>
<th style="text-align:center">异步</th>
</tr>
</thead>
<tbody>
<tr>
<td>主队列</td>
<td style="text-align:center">在主线程中执行</td>
<td style="text-align:center">在主线程中执行 </td>
</tr>
<tr>
<td>串行队列</td>
<td style="text-align:center">在当前线程中执行</td>
<td style="text-align:center">新建线程执行</td>
</tr>
<tr>
<td>并发队列</td>
<td style="text-align:center">在当前线程中执行</td>
<td style="text-align:center">新建线程执行</td>
</tr>
</tbody>
</table>
<h3 id="dispatch_queue_create/dispatch_retain/dispatch_release">dispatch_queue_create/dispatch_retain/dispatch_release</h3><p>Dispatch Queue 也像 Objective-C 的引用计数式内存管理一样，需要通过 dispatch_retain 函数和 dispatch_release 函数的引用计数来管理内存。</p>
<p><strong>如果你部署的最低目标低于 iOS 6.0 or Mac OS X 10.8</strong></p>
<ul>
<li>你应该自己管理 GCD 对象,使用 dispatch_retain/dispatch_release</li>
</ul>
<p><strong>如果你部署的最低目标是 iOS 6.0 or Mac OS X 10.8 或者更高</strong></p>
<ul>
<li>ARC 已经能够管理 GCD 对象了，这时候 GCD 对象就如同普通的 OC 对象一样，不用再 dispatch_retain/dispatch_release  </li>
</ul>
<h3 id="Main_Dispatch_Queue/Global_Dispatch_Queue">Main Dispatch Queue/Global Dispatch Queue</h3><p>实际上不用特意生成 Dispatch Queue 系统也会给我们提供几个，那就是 Main Dispatch Queue 和 Global Dispatch Queue：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">Dispatch Queue 的种类</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Main Dispatch Queue</td>
<td style="text-align:center">Serial Dispatch Queue</td>
<td style="text-align:center">主线程执行</td>
</tr>
<tr>
<td>Global Dispatch Queue（High Priority）</td>
<td style="text-align:center">Concurrent Dispatch Queue</td>
<td style="text-align:center">执行优先级：高（最高优先）</td>
</tr>
<tr>
<td>Global Dispatch Queue（Default Priority）</td>
<td style="text-align:center">Concurrent Dispatch Queue</td>
<td style="text-align:center">执行优先级：默认</td>
</tr>
<tr>
<td>Global Dispatch Queue（Low Priority）</td>
<td style="text-align:center">Concurrent Dispatch Queue</td>
<td style="text-align:center">执行优先级：低</td>
</tr>
<tr>
<td>Global Dispatch Queue（Background Priority）</td>
<td style="text-align:center">Concurrent Dispatch Queue</td>
<td style="text-align:center">执行优先级：后台</td>
</tr>
</tbody>
</table>
<h3 id="dispatch_set_target_queue">dispatch_set_target_queue</h3><p>将 Dispatch Queue 指定为 dispatch_set_target_queue 函数的参数，不仅可以变更 Dispatch Queue 的执行优先级。还可以作成 Dispatch Queue 的执行阶层。如果在多个 Serial Dispatch Queue 中用 dispatch_set_target_queue 函数指定目标为某一个 Serial Dispatch Queue，那么原先本应并行执行的多个 Serial Dispatch Queue，在目标 Serial Dispatch Queue 上只能同时执行一个处理。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-gcd-006.png" alt=""></p>
<p>在必须将可不并行执行的处理追加到多个 Serial Dispatch Queue 中时，如果使用 dispatch_set_target_queue 函数将目标指定为某一个 Serial Dispatch Queue，即可防止处理并行执行。</p>
<h3 id="dispatch_barrier_async">dispatch_barrier_async</h3><p>dispatch_barrier_async 函数会等待追加到 Concurrent Dispatch Queue 上的并行执行的处理全部结束后，再将指定的处理追加到该 Concurrent Dispatch Queue 中。然后在由 dispatch_barrier_async 函数追加的处理执行完毕后，Concurrent Dispatch Queue 才恢复为一般的动作，追加到该 Concurrent Dispatch Queue 的处理又开始并行执行。</p>
<p>使用方法非常简单，如图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-gcd-007.png" alt=""></p>
<h3 id="Dispatch_Semaphore">Dispatch Semaphore</h3><p>Dispatch Semaphore 是持有计数的信号，该计数是多线程编程中的计数类型信号。所谓信号，类似于过马路时常用的手旗。可以通过时举起手旗，不可通过时放下手旗。而 Dispatch Semaphore 中，使用计数来实现该功能。</p>
<p>信号量的具体做法是：当信号计数大于 0 时，每条进来的线程使计数减 1，直到变为 0，变为 0 后其他的线程将进不来，处于等待状态；执行完任务的线程释放信号，使计数加 1，如此循环下去。</p>
<hr>
<h2 id="要点">要点</h2><ol>
<li><p>多个 Serial Dispatch Queue 可并行执行，但生成过线程，就会消耗大量内存，引起大量的上下文切换，大幅度降低系统的响应性能</p>
</li>
<li><p>dispatch_afer 函数并不是在指定时间后执行处理，而只是在指定时间追加处理到 Dispatch Queue</p>
</li>
<li><p>无论向什么样的 Dispatch Queue 中追加处理，使用 Dispatch Group 都可监视这些处理执行的结束。一旦监测到所有处理执行结束，就可将结束的处理追加到 Dispatch Queue 中。这就是使用 Dispatch Group 的原因</p>
</li>
<li><p>关于 dispatch_sync，不得不提<strong>死锁</strong>，详情可参见：<a href="http://www.saitjr.com/ios/ios-gcd-deadlock.html" target="_blank" rel="external">GCD死锁</a> </p>
</li>
<li><p>Serial Dispatch Queue 与 Concurrent Dispatch Queue 都是遵循 FIFO 原则</p>
</li>
<li><p>dispatch_once 方法用 <code>dispatch_once_t</code> 来测试 Block 是否被执行过了。如果执行过了，那么就不在执行，<code>dispatch_once_t</code> 必须是全局或 static 变量</p>
</li>
<li><p>dispatch_create 函数生成的 Dispatch Queue 不管是 Serial Dispatch Queue 还是 Concurrent Dispatch Queue，都使用与默认优先级 Global Dispatch Queue 相同执行优先级的线程</p>
</li>
<li><p>并发与并行的区别：<a href="https://www.zhihu.com/question/33515481" target="_blank" rel="external">https://www.zhihu.com/question/33515481</a></p>
</li>
<li><p>实现 GCD 取消操作：<a href="https://github.com/Tinghui/HUIGCDDispatchAsync" target="_blank" rel="external">A simple wrapper around GCD dispatch_async() function to make easily cancellation.</a>  </p>
</li>
</ol>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/" target="_blank" rel="external">Grand Central Dispatch (GCD) Reference</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文作为《Objective-C 高级编程》读书笔记的第三篇，也是最后一篇，给大家带来的是关于 Grand Central Dispatch (GCD) 的知识点总结。</p>]]>
    
    </summary>
    
      <category term="GCD" scheme="http://itangqi.me/tags/GCD/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Objective-C 高级编程》读书笔记之 Blocks]]></title>
    <link href="http://itangqi.me/2016/03/13/the-notes-of-learning-blocks/"/>
    <id>http://itangqi.me/2016/03/13/the-notes-of-learning-blocks/</id>
    <published>2016-03-12T16:00:00.000Z</published>
    <updated>2016-04-14T07:19:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文作为《Objective-C 高级编程》读书笔记的第二篇，给大家带来的是关于 Blocks 的知识点总结。</p>
<a id="more"></a> 
<hr>
<h2 id="概念">概念</h2><p>Blocks 是 C 语言的扩充功能，可以用一句话来表示 Blocks 的扩充功能：带有自动变量（局部变量）的匿名函数。（Blocks 是闭包在 OC 语言中的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，只是名称不同而已）</p>
<hr>
<h2 id="优势">优势</h2><ol>
<li><p>可代替 Delegate 完成回调，而不需要像 Delegate 那样繁琐</p>
</li>
<li><p>在某些方面，可代替 selector（如 NSNotificationCenter 在 addObserver 的时候，可以使用 block，而不用单独定义方法）</p>
</li>
<li><p>延长对象的生命周期（Block 会自动持有对象）</p>
</li>
<li><p>提高代码的复用性和可读性</p>
</li>
<li><p>常用于：View 动画、GCD、网络异步请求</p>
</li>
</ol>
<hr>
<h2 id="语法">语法</h2><p>关于 Blocks 的语法，看下面一张图就可以啦：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/How%20Do%20I%20Declare%20A%20Block%20in%20Objective%20C%20.png" alt=""></p>
<hr>
<h2 id="Blocks_的实现">Blocks 的实现</h2><h3 id="Blocks_的数据结构">Blocks 的数据结构</h3><p><img src="http://www.galloway.me.uk/media/images/2013-05-26-a-look-inside-blocks-episode-3-block-copy/block_layout.png" alt=""></p>
<p>对应的结构体定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_descriptor &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Block_layout &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor *descriptor;</span><br><span class="line">    <span class="comment">/* Imported variables. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过该图，我们可以知道，一个 Block 实例实际上由 6 部分构成：</p>
<ol>
<li><p><strong>isa 指针</strong>: 所有对象都有该指针，用于实现对象相关的功能</p>
</li>
<li><p><strong>flags</strong>: 用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用；</p>
</li>
<li><p><strong>reserved</strong>: 保留变量；</p>
</li>
<li><p><strong>invoke</strong>: 函数指针，指向具体的 block 实现的函数调用地址；</p>
</li>
<li><p><strong>descriptor</strong>: 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针；</p>
</li>
<li><p><strong>variables</strong>: capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中；</p>
</li>
</ol>
<hr>
<h2 id="Block_存储域">Block 存储域</h2><h3 id="Objective-C_中的_Stack_和_Heap">Objective-C 中的 Stack 和 Heap</h3><p>首先所有的 Objective-C 对象都是分配在 Heap 的。 在 OC 最典型的内存分配与初始化就是这样的：</p>
<pre><code>NSObject *obj = <span class="comment">[<span class="comment">[NSObject alloc]</span> init]</span>;
</code></pre><p>一个对象在 alloc 的时候，就在 Heap 分配了内存空间。</p>
<p>Stack 对象通常有速度的优势，而且不会发生内存泄露问题。那么为什么 OC 的对象都是分配在 Heap 的呢？ 原因在于：</p>
<ul>
<li><p>Stack 对象的生命周期所导致的问题。例如一旦函数返回，则所在的 Stack Frame（栈帧）就会被销毁。那么此时返回的对象也会一并销毁。这个时候我们去 retain 这个对象是无效的。因为整个 Stack Frame 都已经被销毁了。简单而言，就是 Stack 对象的生命周期不适合 OC 的引用计数内存管理方法。</p>
</li>
<li><p>Stack 对象不够灵活，不具备足够的扩展性。创建时长度已经是固定的,而stack对象的拥有者也就是所在的 Stack Frame</p>
</li>
</ul>
<h3 id="Block_类型">Block 类型</h3><p>应用程序的内存分配：</p>
<p><img src="http://blogofzuoyebuluo.qiniudn.com/image_note57603_2.png" alt=""></p>
<p>在 OC 中，一共有 3 种类型的 Block：</p>
<h4 id="_NSConcreteGlobalBlock">_NSConcreteGlobalBlock</h4><p>_NSConcreteGlobalBlock：全局的静态 Block，不会访问任何外部变量。</p>
<p><img src="http://blogofzuoyebuluo.qiniudn.com/image_note57603_3.png" alt=""></p>
<h4 id="_NSConcreteStackBlock">_NSConcreteStackBlock</h4><p>_NSConcreteStackBlock：保存在栈中的 Block，当函数返回时会被销毁。（ARC 中系统实现了自动 copy, 将创建在栈上的 Block 自动拷贝到堆上，所以不存在此类型的 Block）</p>
<h4 id="_NSConcreteMallocBlock">_NSConcreteMallocBlock</h4><p>_NSConcreteMallocBlock：保存在堆中的 Block，当引用计数为 0 时会被销毁。（即成为正常的 OC 对象）</p>
<p><img src="http://blogofzuoyebuluo.qiniudn.com/image_note57603_4.png" alt=""></p>
<hr>
<h2 id="Block_循环引用">Block 循环引用</h2><p>如果在 Block 中使用附有 __strong 修饰符的对象类型自动变量，那么当 Block 从栈复制到堆时，该对象为 Block 所持有，于是便导致了循环引用的产生。</p>
<p>如图所示：self 持有 Block，Block 持有 self，这正是循环引用。</p>
<p><img src="http://blogofzuoyebuluo.qiniudn.com/image_note58470_2.png" alt=""></p>
<h3 id="MRC">MRC</h3><p>在 MRC 下，使用 __block 说明符来避免 Block 中的循环引用。</p>
<p>这是由于当 Block 从栈复制到堆时，若 Block 使用的变量为附有 <strong>block 说明符的 id 类型或对象类型的自动变量，不会被 retain；若 Block 使用的变量为没有 </strong>block 说明符的 id 类型或对象类型的自动变量，则被 retain；若 Block 使用的变量为没有 __block 说明符的 id 类型或对象类型的自动变量，则被 retain。</p>
<h3 id="ARC">ARC</h3><p>在 ARC 下，为了避免这种情况发生，可以在变量声明时用 <strong>weak 修饰符修饰变量 self，让 block 不强引用 self，从而破除循环。iOS4 和 Snow Leopard 由于对 weak 的支持不够完全，可以用 </strong>unsafe_unretained 代替。</p>
<p>使用 Block 成员变量避免循环引用：</p>
<p><img src="http://blogofzuoyebuluo.qiniudn.com/image_note58470_3.png" alt=""></p>
<h3 id="比较">比较</h3><p>下面对使用 <strong>block 变量避免循环引用的方法和使用 </strong>weak 修饰符及 __unsafe_unretained 修饰符避免循环引用的方法做个比较。</p>
<h4 id="使用___block_变量的优点如下：">使用 __block 变量的优点如下：</h4><ul>
<li>通过 <code>__block</code> 变量可控制对象的持有期间</li>
<li><p>在不能使用 <code>__weak</code> 修饰符的环境中不使用 <code>__unsafe_unretained</code> 修饰符即可（不必担心<a href="https://en.wikipedia.org/wiki/Dangling_pointer" target="_blank" rel="external">悬垂指针</a>）</p>
<p>  在执行 Block 时可动态地决定是否将 nil 或其他对象赋值在 <code>__block</code> 变量中。</p>
</li>
</ul>
<h4 id="使用___block_变量的缺点如下：">使用 __block 变量的缺点如下：</h4><ul>
<li><p>为避免循环引用必须执行 Block</p>
<p>  存在执行了 Block 语法，却不执行 Block 的路径时，无法避免循环引用。若由于 Block 引发了循环引用时，根据 Block 的用途选择使用 <code>__block</code> 变量、<code>__weak</code> 修饰符或 <code>__unsafe_unretained</code> 修饰符来避免循环引用。</p>
</li>
</ul>
<hr>
<h2 id="要点">要点</h2><ol>
<li><p>Block 执行的代码其实在编译的时候就已经准备好了</p>
</li>
<li><p>本身 Block 就是一个普通的 OC 对象。正因为它是对象，Block 可以被作为参数传递，可以作为返回值从一个方法返回，可以用来给变量赋值</p>
</li>
<li><p>__block 修饰符在 MRC 下不会进行引用计数加 1，而 ARC 下则会加 1</p>
</li>
<li><p>对于 Block 外的变量引用，Block 默认是将其复制到其数据结构中来实现访问的</p>
</li>
<li><p>对于用 __block 修饰的外部变量引用，Block 是复制其引用地址来实现访问的</p>
</li>
</ol>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html" target="_blank" rel="external">Working with Blocks</a></li>
<li><a href="http://goshdarnblocksyntax.com/" target="_blank" rel="external">How Do I Declare A Block in Objective-C?</a></li>
<li><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C block的实现</a></li>
<li><a href="https://github.com/100mango/zen/blob/master/Objective-C%20%E6%8B%BE%E9%81%97%EF%BC%9A%E4%BB%8EHeap%20and%20Stack%E5%88%B0Block%20/Objective-C%20%E6%8B%BE%E9%81%97%EF%BC%9A%E4%BB%8EHeap%20and%20Stack%E5%88%B0Block%20.md" target="_blank" rel="external">Objective-C 拾遗：从Heap and Stack到Block</a></li>
<li><a href="https://www.zybuluo.com/MicroCai/note/51116" target="_blank" rel="external">block没那么难（一）：block的实现</a></li>
<li><a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/" target="_blank" rel="external">正确使用Block避免Cycle Retain和Crash</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文作为《Objective-C 高级编程》读书笔记的第二篇，给大家带来的是关于 Blocks 的知识点总结。</p>]]>
    
    </summary>
    
      <category term="Blocks" scheme="http://itangqi.me/tags/Blocks/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Objective-C 高级编程》读书笔记之 ARC]]></title>
    <link href="http://itangqi.me/2016/03/10/the-notes-of-learning-arc/"/>
    <id>http://itangqi.me/2016/03/10/the-notes-of-learning-arc/</id>
    <published>2016-03-09T16:00:00.000Z</published>
    <updated>2016-04-13T09:36:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文作为《Objective-C 高级编程》读书笔记的第一篇，给大家带来的是关于 ARC（Automatic Reference Counting）自动引用计数的知识点总结。</p>
<a id="more"></a> 
<hr>
<h2 id="概念">概念</h2><p>顾名思义，ARC（Automatic Reference Counting）— 自动引用计数，是指内存管理中对引用采取自动计数的技术。以下摘自苹果的官方文档：</p>
<blockquote>
<p>Automatic Reference Counting (ARC) is a compiler feature that provides automatic memory management of Objective-C objects. Rather than having to think about retain and release operations, ARC allows you to concentrate on the interesting code, the object graphs, and the relationships between objects in your application.</p>
</blockquote>
<p>一句话总结就是：<strong>在 LLVM 编译器中设置 ARC 为有效状态，就无需再次键入 retain 或者是 release 代码。</strong></p>
<hr>
<h2 id="MRC">MRC</h2><p>在介绍 ARC 之前，不得不提 MRC (MannulReference Counting) — 手动引用计数，即指内存管理中对引用采取手动计数的技术。</p>
<h3 id="引用计数">引用计数</h3><p>我们需要知道 Objective-C 采用的是引用计数式的内存管理方式，这一方式的特点是：</p>
<ol>
<li><p>自己生成的对象自己持有。比如：NSObject * __strong object = [NSObject alloc] init];</p>
</li>
<li><p>非自己生成的对象，自己也能持有。比如：NSMutableArray * __strong array = [NSMutableArray array];</p>
</li>
<li><p>不再需要自己持有的对象时释放</p>
</li>
<li><p>非自己持有的对象自己无法释放</p>
</li>
</ol>
<p>具体可参见下表：</p>
<table>
<thead>
<tr>
<th>对象操作</th>
<th style="text-align:center">OC 中对应的方法</th>
<th style="text-align:center">对应的 retainCount 变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>生成并持有对象</td>
<td style="text-align:center">alloc/new/copy/mutableCopy等</td>
<td style="text-align:center">+1</td>
</tr>
<tr>
<td>持有对象</td>
<td style="text-align:center">retain</td>
<td style="text-align:center">+1</td>
</tr>
<tr>
<td>释放对象</td>
<td style="text-align:center">release</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td>废弃对象</td>
<td style="text-align:center">dealloc</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong>这些有关 OC 内存管理的方法，实际上不包括在该语言中，而是包含再 Cocoa 框架中用于 OS X、iOS 应用开发。Cocoa 框架中 Foundation 框架类库的 NSObject 类担负内存管理的职责。Objective-C 内存管理中的 alloc/retain/release/dealloc 方法分别指代 NSObject 类的 alloc 类方法、retain 实例方法、release 实例方法和 dealloc 实例方法。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-arc-05.jpeg" alt="">(<a href="http://www.ituring.com.cn/minibook/745" target="_blank" rel="external">图片来自</a>)</p>
<h3 id="alloc/retain/release/dealloc实现">alloc/retain/release/dealloc实现</h3><p>苹果的实现大概就是采用散列表（引用计数表）来管理引用计数，如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-arc-06.jpeg" alt="">(<a href="http://www.ituring.com.cn/minibook/745" target="_blank" rel="external">图片来自</a>)</p>
<p>通过引用计数表管理引用计数的好处如下：</p>
<ol>
<li>对用内存块的分配无需考虑内存块头部</li>
<li>引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块</li>
</ol>
<p>这里特别要说的是，第二条这一特性在调试时有着举足轻重的作用。即使出现故障导致对象占用的内存块损坏，但只要引用计数表没有被破坏，就能够确认各内存块的位置，如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-arc-07.jpeg" alt="">(<a href="http://www.ituring.com.cn/minibook/745" target="_blank" rel="external">图片来自</a>)</p>
<p>另外，在利用工具检测内存泄漏时，引用计数表的各记录也有助于检测各对象的持有者是否存在。</p>
<hr>
<h2 id="ARC">ARC</h2><p>当当当~~~今天的主角登场啦！！！</p>
<p>实际上<strong>引用计数式内存管理</strong>的本质部分在 ARC 中并没有改变。就像<strong>自动引用计数</strong>这个名称表示的那样，ARC 只是自动地帮助我们处理<strong>引用计数</strong>的相关部分。</p>
<h3 id="所有权修饰符">所有权修饰符</h3><p>Objective-C 编程中为了处理对象，可将变量类型定义为 id 类型或各种对象类型。</p>
<p>所谓对象类型就是指向 NSObject 这样的 Objective-C 类的指针，例如 NSObject <em> 。id 类型用于隐藏对象类型的类名部分，相当于 C 语言中常用的 void </em> 。</p>
<p>ARC 有效时，id 类型和对象类型同 C 语言其他类型不同，其类型上必须附加所有权修饰符。所有权修饰符一共有 4 种：</p>
<ul>
<li><code>__strong</code></li>
<li><code>__weak</code></li>
<li><code>__unsafe_unretained</code></li>
<li><code>__autoreleasing</code></li>
</ul>
<p>说到变量所有权修饰符，有人可能会跟属性修饰符搞混，这里做一个对照关系小结：</p>
<ul>
<li><code>assign</code> 对应的所有权类型是 <code>__unsafe_unretained</code></li>
<li><code>copy</code> 对应的所有权类型是 <code>__strong</code></li>
<li><code>retain</code> 对应的所有权类型是 <code>__strong</code></li>
<li><code>strong</code> 对应的所有权类型是 <code>__strong</code></li>
<li><code>unsafe_unretained</code> 对应的所有权类型是 <code>__unsafe_unretained</code></li>
<li><code>weak</code> 对应的所有权类型是 <code>__weak</code></li>
</ul>
<p>以上除了 <code>weak</code> 外，其他的属性修饰符在 MRC 模式下也是有效的。</p>
<p>另外，<code>__strong</code>、<code>__weak</code>、<code>__autoreleasing</code> 修饰的自动变量会自动初始化为 nil。</p>
<h4 id="__strong_修饰符">__strong 修饰符</h4><p><code>__strong</code> 表示强引用，对应定义 property 时用到的 <code>strong</code>。当对象没有任何一个强引用指向它时，它才会被释放。如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，需要保证所有指向对象强引用置为 nil。<code>__strong</code> 修饰符是 id 类型和对象类型默认的所有权修饰符。</p>
<h4 id="__weak_修饰符">__weak 修饰符</h4><p><code>__weak</code> 表示弱引用，对应定义 property 时用到的 <code>weak</code>。弱引用不会影响对象的释放，而当对象被释放时，所有指向它的弱引用都会自定被置为 nil，这样可以防止野指针。<code>__weak</code> 最常见的一个作用就是用来避免强引用循环。但是需要注意的是，<code>__weak</code> 修饰符只能用于 iOS 5 以上的版本，在 iOS 4 及更低的版本中使用 <code>__unsafe_unretained</code> 修饰符来代替。</p>
<h5 id="循环引用">循环引用</h5><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-arc-02.001.jpeg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-arc-03.png" alt=""></p>
<h5 id="__weak_实现">__weak 实现</h5><p>关于 runtime 如何实现 weak 属性，可参见：<a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#8-runtime-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-weak-%E5%B1%9E%E6%80%A7" target="_blank" rel="external">《招聘一个靠谱的 iOS》</a> 中的解答。</p>
<h4 id="__unsafe_unretained_修饰符">__unsafe_unretained 修饰符</h4><p>ARC 是在 iOS 5 引入的，而 <code>__unsafe_unretained</code> 这个修饰符主要是为了在 ARC 刚发布时兼容 iOS 4 以及版本更低的系统，因为这些版本没有弱引用机制。这个修饰符在定义 property 时对应的是  <code>unsafe_unretained</code>。<code>__unsafe_unretained</code> 修饰的指针纯粹只是指向对象，没有任何额外的操作，不会去持有对象使得对象的 retainCount + 1。而在指向的对象被释放时依然原原本本地指向原来的对象地址，不会被自动置为 nil，所以成为了野指针，非常不安全。</p>
<h4 id="__autoreleasing_修饰符">__autoreleasing 修饰符</h4><p>在 ARC 模式下，我们不能显示的使用 <code>autorelease</code> 方法了，但是 <code>autorelease</code> 的机制还是有效的，通过将对象赋给 <code>__autoreleasing</code> 修饰的变量就能达到在 MRC 模式下调用对象的 <code>autorelease</code> 方法同样的效果。</p>
<p>也就是说可以理解为，在 ARC 有效时，用 @autoreleasepool 块替代 NSAutoreleasePool 类，用附有 <code>__autoreleasing</code> 修饰符的变量替代 <code>autorelease</code> 方法，如图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-arc-04.001.png" alt=""></p>
<p>在 ARC 模式下，显式的使用 <code>__autoreleasing</code> 的场景很少见，但是 autorelease 的机制却依然在很多地方默默起着作用。我们来看看这些场景：</p>
<ol>
<li>方法返回值</li>
<li>访问 __weak 修饰的变量</li>
<li>id 的指针或对象的指针(id *)</li>
</ol>
<p>关于使用场景的具体讲解，感兴趣的同学可以自学搜索。</p>
<h5 id="Autorelease_Pool">Autorelease Pool</h5><p>在 ARC 下，我们并不需要手动调用 autorelease 有关的方法，甚至可以完全不知道 autorelease 的存在，就可以正确管理好内存。因为 Cocoa Touch 的 Runloop 中，每个 runloop circle 中系统都自动加入了 Autorelease Pool 的创建和释放。</p>
<p>Autorelase Pool 提供了一种可以允许你向一个对象延迟发送 <code>release</code> 消息的机制。当你想放弃一个对象的所有权，同时又不希望这个对象立即被释放掉（例如在一个方法中返回一个对象时），Autorelease Pool 的作用就显现出来了。</p>
<p>所谓的延迟发送 <code>release</code> 消息指的是，当我们把一个对象标记为 <code>autorelease</code> 时:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span>* str = [[[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"hello"</span>] autorelease];</span><br></pre></td></tr></table></figure>
<p>这个对象的 retainCount 会 + 1，但是并不会发生 release。当这段语句所处的 autoreleasepool 进行 drain 操作时，所有标记了 <code>autorelease</code> 的对象的 retainCount 会被 - 1。即 <code>release</code> 消息的发送被延迟到 pool 释放的时候了。</p>
<p>在 ARC 环境下，苹果引入了 <code>@autoreleasepool</code> 语法，不再需要手动调用 <code>autorelease</code> 和 <code>drain</code> 等方法。</p>
<h3 id="规则">规则</h3><p>在 ARC 有效的情况下编译源代码，必须遵守一定的规则。下面就是具体的 ARC 的规则：</p>
<ol>
<li><p>不能显式使用 retain/release/retainCount/autorelease</p>
</li>
<li><p>不能使用 NSAllocateObject/NSDeallocateObject</p>
</li>
<li><p>需要遵守内存管理的方法命名规则。在 ARC 模式和 MRC 模式下，以 alloc/new/copy/mutableCopy 开头的方法在返回对象时都必须返回给调用方所应当持有的对象。在 ARC 模式下，追加一条：以 init 开头的方法必须是实例方法并且必须要返回对象。返回的对象应为 id 类型或声明该方法的类的对象类型，或是该类的超类型或子类型。该返回的对象并不注册到 Autorelease Pool 中，基本上只是对 alloc 方法返回值的对象进行初始化处理并返回该对象。需要注意的是：- (void)initialize; 方法虽然是以 init 开头但是并不包含在上述规则中</p>
</li>
<li><p>不要显式调用 dealloc</p>
</li>
<li><p>使用 @autoreleasepool 块替代 NSAutoreleasePool</p>
</li>
<li><p>不能使用区域（NSZone）</p>
</li>
<li><p>对象型变量不能作为 C 语言结构体（struct/union）的成员</p>
</li>
<li><p>显式转换 id 和 void *</p>
</li>
</ol>
<h3 id="Toll-Free_Bridge">Toll-Free Bridge</h3><blockquote>
<p>There are a number of data types in the Core Foundation framework and the Foundation framework that can be used interchangeably. This capability, called toll-free bridging, means that you can use the same data type as the parameter to a Core Foundation function call or as the receiver of an Objective-C message. For example, NSLocale (see NSLocale Class Reference) is interchangeable with its Core Foundation counterpart, CFLocale (see CFLocale Reference). Therefore, in a method where you see an NSLocale * parameter, you can pass a CFLocaleRef, and in a function where you see a CFLocaleRef parameter, you can pass an NSLocale instance. You cast one type to the other to suppress compiler warnings, as illustrated in the following example.</p>
</blockquote>
<p>Toll-Free Briding 保证了在程序中，可以方便和谐的使用 Core Foundation 类型的对象和 Objective-C 类型的对象。</p>
<p>在 MRC 时代，由于 Objective-C 类型的对象和 Core Foundation 类型的对象都是相同的 release 和 retain 操作规则，所以 Toll-Free Bridging 的使用比较简单，但是自从切换到 ARC 后，Objective-C 类型的对象内存管理规则改变了，而 Core Foundation 依然是之前的机制，换句话说，Core Foundation 不支持 ARC。</p>
<p>这个时候就必须要要考虑一个问题了，在做 Core Foundation 与 Objective-C 类型转换的时候，用哪一种规则来管理对象的内存。显然，对于同一个对象，我们不能够同时用两种规则来管理，所以这里就必须要确定一件事情：哪些对象用 Objective-C（也就是 ARC）的规则，哪些对象用 Core Foundation 的规则（也就是 MRC）的规则。或者说要确定对象类型转换了之后，内存管理的 ownership 的改变。于是苹果在引入 ARC 之后对 Toll-Free Bridging 的操作也加入了对应的方法与修饰符，用来指明用哪种规则管理内存，或者说是内存管理权的归属。这些方法和修饰符分别是：</p>
<ul>
<li>__bridge（修饰符）</li>
<li>__bridge_retained（修饰符） or CFBridgingRetain（函数）</li>
<li>__bridge_transfer（修饰符） or CFBridgingRelease（函数）</li>
</ul>
<p>本文关于 Toll-Free Bridge 不做过多介绍，感兴趣的同学可以参见：<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html" target="_blank" rel="external">Toll-Free Bridge</a></p>
<hr>
<h2 id="要点">要点</h2><ol>
<li><p>ARC 是编译器提供的机制，而不是 GC (Garbage Collection) 这种运行时提供的机制</p>
</li>
<li><p>autorelease 实例方法的本质就是调用 NSAutoreleasePool 对象的 addObject 类方法</p>
</li>
</ol>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="external">Objective-C Automatic Reference Counting (ARC)</a></li>
<li><a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Transitioning to ARC Release Notes</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011-SW1" target="_blank" rel="external">Advanced Memory Management Programming Guide</a></li>
<li><a href="http://www.samirchen.com/ios-arc/" target="_blank" rel="external">iOS ARC 内存管理要点</a></li>
<li><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/MM.html" target="_blank" rel="external">Objective-C 中的内存分配</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文作为《Objective-C 高级编程》读书笔记的第一篇，给大家带来的是关于 ARC（Automatic Reference Counting）自动引用计数的知识点总结。</p>]]>
    
    </summary>
    
      <category term="ARC" scheme="http://itangqi.me/tags/ARC/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊 UITableView（三）]]></title>
    <link href="http://itangqi.me/2016/02/27/the-notes-of-learning-uitableview-three/"/>
    <id>http://itangqi.me/2016/02/27/the-notes-of-learning-uitableview-three/</id>
    <published>2016-02-26T16:00:00.000Z</published>
    <updated>2016-04-16T08:10:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>在本系列文章中，我将和大家聊一聊关于 UITableView 的种种，那些你知道的或者不知道的事。</p>
</blockquote>
<p>本文是系列文章《聊一聊 UITableView》的完结篇。</p>
<a id="more"></a> 
<p>第一篇：<a href="http://itangqi.me/2016/02/25/the-notes-of-learning-uitableview-one/">聊一聊 UITableView（一）</a><br>第二篇：<a href="http://itangqi.me/2016/02/26/the-notes-of-learning-uitableview-two/">聊一聊 UITableView（二）</a></p>
<hr>
<h2 id="实现">实现</h2><p>如果你有仔细阅读过本系列文章的前两篇（没看过的一定要去看看呀！），那么我想你基本上已经对实现的原理及流程有了清晰的认识。所以关于具体的实现，本文不做详细介绍，你可以参见下面两篇文章：</p>
<ul>
<li><a href="http://www.wugaojun.com/blog/2015/05/24/autolayoutshi-zhan-cellgao-du-bu-gu-ding-de-uitableview/" target="_blank" rel="external">AutoLayout实战:cell高度不固定的UITableView</a></li>
<li><a href="http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/" target="_blank" rel="external">有趣的Autolayout示例2-Masonry实现</a></li>
</ul>
<hr>
<h2 id="那些坑">那些坑</h2><p>下面列举了几个在开发中比较常见的<strong>坑</strong>供大家学习：</p>
<h4 id="1-_UILabel_的_preferredMaxLayoutWidth">1. UILabel 的 <code>preferredMaxLayoutWidth</code></h4><p>定义如下:</p>
<blockquote>
<p>This property affects the size of the label when layout constraints are applied to it. During layout, if the text extends beyond the width specified by this property, the additional text is flowed to one or more new lines, thereby increasing the height of the label.</p>
</blockquote>
<p>如果我们要使用 Auto Layout 自动计算<strong>多行</strong> UILabel 的高度，这个属性就必须在运行时指定，要不然系统计算不出 UILabel 的宽度。这是因为 UILabel 需要知道 superview 的宽度才能<strong>折行</strong>，而 superview 的宽度还依仗着子 view 宽度的累加才能确定。</p>
<p>同时需要设置 UILabel 的 <code>numberOfLines</code> 属性为 0 以表示显示多行。</p>
<h4 id="2-_UITableView_的_estimatedRowHeight">2. UITableView 的 <code>estimatedRowHeight</code></h4><blockquote>
<p>我们知道，UITableView 是个 UIScrollView，就像平时使用 UIScrollView 一样，加载时指定 contentSize 后它才能根据自己的 bounds、contentInset、contentOffset 等属性共同决定是否可以滑动以及滚动条的长度。而 UITableView 在一开始并不知道自己会被填充多少内容，于是询问 data source 个数和创建 cell，同时询问 delegate 这些 cell 应该显示的高度，这就造成它在加载的时候浪费了多余的计算在屏幕外边的 cell 上。</p>
</blockquote>
<p>1.设置估算高度后，contentSize.height 根据“cell 估算值 x cell 个数”计算，这就导致滚动条的大小处于不稳定的状态，contentSize 会随着滚动从估算高度慢慢替换成真实高度，肉眼可见滚动条突然变化甚至“跳跃”。</p>
<p>2.若是有设计不好的下拉刷新或上拉加载控件，或是 KVO 了 contentSize 或 contentOffset 属性，有可能使表格滑动时跳动。</p>
<p>3.估算高度设计初衷是好的，让加载速度更快，那凭啥要去侵害滑动的流畅性呢，用户可能对进入页面时多零点几秒加载时间感觉不大，但是滑动时实时计算高度带来的卡顿是明显能体验到的，个人觉得还不如一开始都算好了呢（iOS8 更过分，即使都算好了也会边划边计算）</p>
<h4 id="3-_UITableView_的_heightForRowAtIndexPath:">3. UITableView 的 <code>heightForRowAtIndexPath:</code></h4><p>对于 Auto Layout 下的 cell，使用 <code>systemLayoutSizeFittingSize:</code> 计算 tableview.contentView 的 <code>UILayoutFittingCompressedSize</code> 返回的 CGSize 的高度是首选，但它同样是根据 <code>intrinsicContentSize</code> 来计算的，得出的高度其实是不包含 <code>UITextView</code> 这种 view 的，所以结果还需要<strong>加上</strong> UITextView 的高度即可。</p>
<h4 id="4-_iOS_8_算高机制">4. iOS 8 算高机制</h4><p>相同的代码在 iOS 7 和 iOS 8 上滑动顺畅程度完全不同，iOS8 莫名奇妙的卡。很大一部分原因是 iOS 8 上的算高机制大不相同，图片来自 <a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">sunnyxx</a>：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uitableview-three-01.jpg" alt=""></p>
<p>造成这样的原因：<br>1.不开启高度估算时，UITableView 上来就要对所有 cell 调用算高来确定 contentSize<br>2.<code>dequeueReusableCellWithIdentifier:forIndexPath:</code> 相比不带 “forIndexPath” 的版本会多调用一次高度计算<br>3.iOS 7 计算高度后有”缓存“机制，不会重复计算；而 iOS 8 不论何时都会重新计算 cell 高度（cell 被认为随时都可能改变高度（如从设置中调整动态字体大小），所以每次滑动出来后都要重新计算高度。）</p>
<hr>
<h2 id="那些优化">那些优化</h2><h4 id="1-_避免_cell_的重新布局">1. 避免 cell 的重新布局</h4><p>cell 的布局填充等操作比较耗时，一般可在创建时就布局好。如自定义 cell, 可重写其 <code>initWithStyle:</code> 方法，在其中将 cell 的布局设置完成。<br>创建 cell 完成之后，调用 <strong>相应方法</strong> 往其中填充内容即可，即将 cell 的布局及填充分开执行，且尽量将要填充的 data 提前准备好。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 UITableView 的 dequeueReusableCellWithIdentifier 方法时会通过这个方法初始化 Cell</span></span><br><span class="line">- (instancetype)initWithStyle:(<span class="built_in">UITableViewCellStyle</span>)style reuseIdentifier:(<span class="built_in">NSString</span> *)reuseIdentifier &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithStyle:style reuseIdentifier:reuseIdentifier];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    	<span class="comment">// 在这里！！！</span></span><br><span class="line">     	[<span class="keyword">self</span> initView];</span><br><span class="line">        [<span class="keyword">self</span> updateConstraints];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-_在_Model（Entity）中计算并保存_Cell_的高度">2. 在 Model（Entity）中计算并保存 Cell 的高度</h4><p>我们都知道，UITableView 是继承自 UIScrollView 的，需要先确定它的 contentSize 及每个 cell 的位置，然后才会把重用的 cell 放置到对应的位置。所以事实上，UITableView 的回调顺序是先多次调用 <code>tableView:heightForRowAtIndexPath:</code>以确定 contentSize 及 cell 的位置，然后才会调用 <code>tableView:cellForRowAtIndexPath:</code>，从而来显示在当前屏幕的 cell。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DataEntity</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始数据</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *content;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cell 高度</span></span><br><span class="line">@roperty(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> cellHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这样，就不用在 <code>tableView:heightForRowAtIndexPath:</code> 中每次都计算了。</p>
<p>补充：同理可将 view 缓存起来的：比如每一个 cell 都需要用到的 UIImage, UIFont, NSDateFormatter 或者任何在绘制时需要的对象，推荐使用类层级的初始化方法中执行分配，并将其存储为静态变量。</p>
<h4 id="3-_滑动_UITableView_时，按需加载对应的内容">3. 滑动 UITableView 时，按需加载对应的内容</h4><p>从 UIScrollView 的角度出发，对 cell 进行按需加载, 即滚动很快时候, 只加载目标范围内的 cell.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (needLoadArr<span class="variable">.count</span>&gt;<span class="number">0</span> &amp;&amp; [needLoadArr indexOfObject:indexPath]==<span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">    [cell clear]; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定 3 行加载。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset&#123;</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *ip = [<span class="keyword">self</span> indexPathForRowAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y)];</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *cip = [[<span class="keyword">self</span> indexPathsForVisibleRows] firstObject];</span><br><span class="line">    <span class="built_in">NSInteger</span> skipCount = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (labs(cip<span class="variable">.row</span>-ip<span class="variable">.row</span>)&gt;skipCount) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *temp = [<span class="keyword">self</span> indexPathsForRowsInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y, <span class="keyword">self</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.height</span>)];</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> arrayWithArray:temp];</span><br><span class="line">        <span class="keyword">if</span> (velocity<span class="variable">.y</span>&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp lastObject];</span><br><span class="line">            <span class="keyword">if</span> (indexPath<span class="variable">.row</span>+<span class="number">33</span>) &#123;</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath<span class="variable">.row</span>-<span class="number">3</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath<span class="variable">.row</span>-<span class="number">2</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath<span class="variable">.row</span>-<span class="number">1</span> inSection:<span class="number">0</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [needLoadArr addObjectsFromArray:arr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-_复用高开销的对象">4. 复用高开销的对象</h4><p>在 Objective-C 中有些对象的初始化过程很缓慢，比如：<code>NSDateFormatter</code> 和 <code>NSCalendar</code>，但是有些时候，你也不得不使用它们。为了这样的高开销的对象成为影响程序性能的重要因素，我们可以复用它们。</p>
<p>比如，我们在一个类里添加一个 <code>NSDateFormatter</code> 的对象，并使用懒加载机制来使用它，整个类只用到一个这样的对象，并只初始化一次：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in your .h or inside a class extension</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDateFormatter</span> *dateFormatter;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// inside the implementation (.m)</span></span><br><span class="line"><span class="comment">// When you need, just use self.dateFormatter</span></span><br><span class="line">- (<span class="built_in">NSDateFormatter</span> *)dateFormatter &#123;</span><br><span class="line">    <span class="keyword">if</span> (! _dateFormatter) &#123;</span><br><span class="line">        _dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        [_dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd a HH:mm:ss EEEE"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dateFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上面的代码在多线程环境下会有问题，所以我们可以改进如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no property is required anymore. The following code goes inside the implementation (.m)</span></span><br><span class="line">- (<span class="built_in">NSDateFormatter</span> *)dateFormatter &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *dateFormatter;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        [dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd a HH:mm:ss EEEE"</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dateFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就线程安全了。</p>
<h4 id="5-_尽量减少不必要的透明_View">5. 尽量减少不必要的透明 View</h4><p>透明图层对渲染性能会有一定的影响，系统必须将透明图层与下面的视图混合起来计算颜色，并绘制出来。减少透明图层并使用不透明的图层来替代它们，可以极大地提高渲染速度。</p>
<h4 id="6-_优化touch事件传递">6. 优化touch事件传递</h4><p>把不需要接受 touch 的 view 的 <code>userInteractionEnabled</code> 设为 0 </p>
<h4 id="7-_其他">7. 其他</h4><ul>
<li>选择合适的数据结构来承载数据，不同的数据结构对不同操作的开销是存在差异的；</li>
<li>如果 Cell 展示的内容来自网络，确保用异步加载的方式来获取数据，并且进行缓存，滚出可视范围的载入进程要 Cancel 掉；</li>
<li>尽量减少 subview 的数量，减少渲染工作；</li>
<li>异步获取数据：</li>
<li>启用 GZIP 数据压缩；</li>
</ul>
<hr>
<h2 id="写在最后">写在最后</h2><blockquote>
<p>纸上谈兵终觉浅 绝知此事要躬行</p>
</blockquote>
<p>好啦，不管怎样，亲自去实践才是获取与巩固知识的最佳办法！</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">优化UITableViewCell高度计算的那些事</a></li>
<li><a href="http://blog.alchemistxxd.com/2015/12/05/Auto-Layout-dynamic-UITableViewCell/" target="_blank" rel="external">使用 Auto Layout 处理动态高度的 UITableViewCell 方法的归纳与心得 ⭕️</a></li>
<li><a href="http://tutuge.me/2015/02/19/%E6%8F%90%E5%8D%87UITableView%E6%80%A7%E8%83%BD-%E5%A4%8D%E6%9D%82%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96/" target="_blank" rel="external">提升UITableView性能-复杂页面的优化</a></li>
<li><a href="http://www.samirchen.com/ios-performance-optimization/" target="_blank" rel="external">iOS 程序性能优化</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>在本系列文章中，我将和大家聊一聊关于 UITableView 的种种，那些你知道的或者不知道的事。</p>
</blockquote>
<p>本文是系列文章《聊一聊 UITableView》的完结篇。</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="UITableView" scheme="http://itangqi.me/tags/UITableView/"/>
    
      <category term="UITableViewCell" scheme="http://itangqi.me/tags/UITableViewCell/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊 UITableView（二）]]></title>
    <link href="http://itangqi.me/2016/02/26/the-notes-of-learning-uitableview-two/"/>
    <id>http://itangqi.me/2016/02/26/the-notes-of-learning-uitableview-two/</id>
    <published>2016-02-25T16:00:00.000Z</published>
    <updated>2016-04-16T08:10:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>在本系列文章中，我将和大家聊一聊关于 UITableView 的种种，那些你知道的或者不知道的事。</p>
</blockquote>
<p>本文是系列文章《聊一聊 UITableView》的第二篇。</p>
<a id="more"></a> 
<p>第一篇：<a href="http://itangqi.me/2016/02/25/the-notes-of-learning-uitableview-one/">聊一聊 UITableView（一）</a></p>
<hr>
<h2 id="相关知识储备">相关知识储备</h2><h3 id="estimatedHeightForRowAtIndexPath:"><code>estimatedHeightForRowAtIndexPath:</code></h3><p>首先，丢张官方文档截图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-uitableviewcell-two-02.png" alt=""></p>
<p>在 iOS 7 上， 苹果为 <code>UITableViewDelegate</code> 带来了新方法 <code>estimatedHeightForRowAtIndexPath:</code>。此方法用于返回一个 cell 的预估高度，如果在程序中实现了这个方法，tableview 首次加载的时候就不会调用 <code>heightForRowAtIndexPath:</code> 方法，而是用 <code>estimatedHeightForRowAtIndexPath:</code> 返回的预估高度计算 tableview 的总高度，然后 tableview 就可以显示出来了，等到 cell 可见的时候，再去调用 <code>heightForRowAtIndexPath:</code> 获取 cell 的实际高度。</p>
<p>注意：除非行高极端变化并且你已经明显的觉察到了滚动时滚动条的“跳跃”现象，你才需要实现此方法；否则，直接用 tableView 的 estimatedRowHeight 属性即可。</p>
<p>而在 iOS 8 上，苹果为 UITableView 带来了 <a href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithSelf-SizingTableViewCells.html" target="_blank" rel="external">Self-Sizing</a> </p>
<p>首先，进行行高预估：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tableView<span class="variable">.rowHeight</span> = <span class="built_in">UITableViewAutomaticDimension</span>;</span><br><span class="line">tableView<span class="variable">.estimatedRowHeight</span> = <span class="number">85.0</span>;</span><br></pre></td></tr></table></figure></p>
<p>其次，在 <code>heightForRowAtIndexPath:</code> 中返回 UITableViewAutomaticDimension 即可：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef IOS_8_NEW_FEATURE_SELF_SIZING</span></span><br><span class="line">    <span class="comment">// iOS 8 的 Self-sizing 特性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UITableViewAutomaticDimension</span>;</span><br><span class="line"><span class="preprocessor">#else</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你没看错，就这么简单。好啦，你可以愉快的去玩耍了。</p>
<h3 id="systemLayoutSizeFittingSize:"><code>systemLayoutSizeFittingSize:</code></h3><p>没错，还是官方文档截图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-uitableviewcell-two-01.png" alt=""></p>
<p>如果要适配 iOS 8 以下，则要使用到 <code>stemLayoutSizeFittingSize:</code> 方法。 由于其需要 cell 的一个实例才能计算，所以这儿用字典专门存放 cell 的实列，这样就不需要每次计算 cell 高度的时候去动态生成实例，这样即方便也高效也少用内存，可谓一举三得。</p>
<p>首先，试图从字典中取出指定 cell:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// offscreenCells 为成员变量</span></span><br><span class="line">NoteListCell *_templateCell = [<span class="keyword">self</span><span class="variable">.offscreenCells</span> objectForKey:reuseIdentifier];</span><br></pre></td></tr></table></figure></p>
<p>如果为空，创建并存入字典：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!_templateCell) &#123;</span><br><span class="line">    _templateCell = [[NoteListCell alloc] init];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.offscreenCells</span> setObject:_templateCell forKey:reuseIdentifier];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，计算 cell 的实际高度：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充数据</span></span><br><span class="line">[_templateCell updateWithNote:note];</span><br><span class="line"><span class="comment">// 根据当前数据，计算 Cell 的高度，注意 +1</span></span><br><span class="line">note<span class="variable">.cellHeight</span> = [_templateCell<span class="variable">.contentView</span></span><br><span class="line"><span class="comment">// 使用 `UILayoutFittingCompressedSize` 参数可以得到适合 cell 中所有内容所需的最小尺寸  </span></span><br><span class="line">systemLayoutSizeFittingSize:<span class="built_in">UILayoutFittingCompressedSize</span>]<span class="variable">.height</span> + <span class="number">1.0</span>f;</span><br></pre></td></tr></table></figure></p>
<p>注意：由于是在 _templateCell.contentView 上调用这个方法，那么返回的值将是 contentView 的高度，UITableViewCell 的高度要比它的 contentView 要高 1, 也就是它的分隔线的高度。</p>
<h3 id="setNeedsLayout_vs-_setNeedsUpdateConstraints_and_layoutIfNeeded_vs_updateConstraintsIfNeeded"><code>setNeedsLayout</code> vs. <code>setNeedsUpdateConstraints</code> and <code>layoutIfNeeded</code> vs <code>updateConstraintsIfNeeded</code></h3><p>参见 <a href="http://stackoverflow.com/questions/20609206/setneedslayout-vs-setneedsupdateconstraints-and-layoutifneeded-vs-updateconstra" target="_blank" rel="external">stackoverflow</a> 上相关问题的解答：</p>
<ol>
<li>如果仅想要立即改变约束，调用 <code>setNeedsLayout</code>;</li>
<li>如果改变 view 的一些属性（如 offsets）可能会导致布局的改变，那么调用 <code>setNeedsUpdateConstraints</code>, 更多的时候后面需要加 <code>setNeedsLayout</code>;</li>
<li>如果想要立即改变布局，如会形成新的 frame, 那么需要在调用 <code>layoutIfNeeded</code>;</li>
</ol>
<h3 id="缓存行高">缓存行高</h3><p>如果上面提到的你都做了，但是 <code>tableView:heightForRowAtIndexPath:</code> 的性能仍然慢的不可接受。非常不幸，你需要给行高做一些缓存（这是苹果的工程师们给出的改进建议）。大体的思路是，第一次计算时让自动布局引擎解析约束条件，然后将计算出的行高缓存起来，以后所有对该cell 的高度的请求都返回缓存值。当然，关键还要确保任何会导致 cell 高度变化的情况发生时你都清除了缓存的行高——这通常发生在 cell 的内容变化时或其他重大事件发生时（比如用户调节了动态类型文本大小(Dynamic Type text size)的滑动条）。</p>
<p>未完待续……</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="http://www.ifun.cc/blog/2014/02/21/dong-tai-ji-suan-uitableviewcellgao-du-xiang-jie/" target="_blank" rel="external">动态计算UITableViewCell高度详解</a></li>
<li><a href="http://codingobjc.com/blog/2014/10/15/shi-yong-autolayoutshi-xian-uitableviewde-celldong-tai-bu-ju-he-ke-bian-xing-gao/" target="_blank" rel="external">使用Autolayout实现UITableView的Cell动态布局和高度动态改变</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>在本系列文章中，我将和大家聊一聊关于 UITableView 的种种，那些你知道的或者不知道的事。</p>
</blockquote>
<p>本文是系列文章《聊一聊 UITableView》的第二篇。</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="UITableView" scheme="http://itangqi.me/tags/UITableView/"/>
    
      <category term="UITableViewCell" scheme="http://itangqi.me/tags/UITableViewCell/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊 UITableView（一）]]></title>
    <link href="http://itangqi.me/2016/02/25/the-notes-of-learning-uitableview-one/"/>
    <id>http://itangqi.me/2016/02/25/the-notes-of-learning-uitableview-one/</id>
    <published>2016-02-24T16:00:00.000Z</published>
    <updated>2016-03-07T05:42:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>在本系列文章中，我将和大家聊一聊关于 UITableView 的种种，那些你知道的或者不知道的事。</p>
</blockquote>
<p>前几天正好看了关于 AutoLayout 与 UITableViewCell 高度动态计算的文章，于是便在 <a href="https://github.com/tangqi92/SuperNote" target="_blank" rel="external">SuperNote</a> 上践行了所学的知识，并做了相关笔记的总结，在此与大家进行分享。</p>
<a id="more"></a> 
<hr>
<h2 id="Auto_Layout">Auto Layout</h2><p>首先看官方文档<a href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/AutolayoutPG/" target="_blank" rel="external">《Auto Layout Guide》</a>中关于 Auto Layout 的描述：</p>
<blockquote>
<p>Auto Layout dynamically calculates the size and position of all the views in your view hierarchy, based on constraints placed on those views. For example, you can constrain a button so that it is horizontally centered with an Image view and so that the button’s top edge always remains 8 points below the image’s bottom. If the image view’s size or position changes, the button’s position automatically adjusts to match.</p>
<p>This constraint-based approach to design allows you to build user interfaces that dynamically respond to both internal and external changes.</p>
</blockquote>
<p>作为从 Android 阵营转过来的我，一路都是手撕页面布局的，当我面对要在 Storyboard 中拖拽各种约束时，我的内心是几乎是崩溃的（也许我该尝试下），直到我发现了 <a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">Masonry</a>，妈妈再也不用担心我写 Auto Layout 了。</p>
<p>Masonry 老少皆宜，非常容易上手，具体的使用可参见<strong>里脊串</strong>的文章：</p>
<ul>
<li><a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/" target="_blank" rel="external">Masonry介绍与使用实践(快速上手Autolayout)</a></li>
</ul>
<hr>
<h2 id="UITableViewCell_重用机制">UITableViewCell 重用机制</h2><p>在讲 UITableViewCell 高度自适应前，首先简单介绍下 UITableViewCell 的重用机制：</p>
<ul>
<li><p>当用户滚动 UITableView 对象时，部分 UITableViewCell 对象会移出窗口。此时 UITableView 对象会将移出窗口的 UITableViewCell 对象放入 UITableViewCell <strong>对象池</strong>，等待重新利用。当 UITableView 对象要求数据源返回某个 UITableViewCell 对象时，数据源可以先查看对象池。如果有未使用的 UITableViewCell 对象，就可以用<strong>新的数据</strong>配置这个 UITableViewCell 对象，然后将其返回给 UITableView 对象，从而避免创建新对象。</p>
</li>
<li><p>这里还有一个问题：因为有时需要创建 UITableViewCell 的<strong>子类</strong>，用于实现特定的外观或特性，所以 UITableView 对象可能会拥有<strong>不同类型</strong>的 UITableViewCell 对象。如果 UITableViewCell 对象池中的对象创建自不同的子类，那么 UITableView 对象就有可能得到错误类型的 UITableViewCell 对象。鉴于上述原因，必须确保 UITableView 对象能够得到指定类型的 UITableViewCell 对象，这样才能确定返回的对象会拥有哪些属性和方法。</p>
</li>
<li><p>从 UITableViewCell 对象池获取对象时，无须关心取回的是否是某个特定的对象，因为无论取回的是哪个对象，都要重新设置数据。真正要关心的是取回的对象是否是某个<strong>特定</strong>的类型。每个 UITableViewCell 对象都有一个类型为 NSString 的 <strong>reuseIdentifier</strong> 属性。当数据源向 UITableView 对象获取可重用的 UITableViewCell 对象时，可传入一个字符串并要求 UITableView 对象返回相应的 UITableViewCell 对象，这些 UITableViewCell 对象的 reuseIdentifier 属性必须和传入的字符串相同。按照约定，应该将 UITableViewCell 或者 UITableViewCell 子类的类名用作 reuseIdentifier。</p>
</li>
</ul>
<p>上面讲得那么啰嗦，不如直接看下面的图： </p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-uitableviewcell-01.png" alt=""></p>
<p>情况 A: 所有 Cell 具有相同的类型</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  实现数据绑定</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// 根据标识符 identifier 从重用队列中取出一个 cell</span></span><br><span class="line">    NoteListCell *cell = [tableView dequeueReusableCellWithIdentifier:kCellReuseIdentifier];</span><br><span class="line">    <span class="comment">// 由于一开始重用队列是空的，所以取出的 cell 也是空的，if(!cell) 条件成立，就会去执行 &#123;&#125; 内的代码</span></span><br><span class="line">    <span class="keyword">if</span> (!cell) &#123;</span><br><span class="line">    	<span class="comment">// 创建 UITableViewCellStyleDefault类型的 cell，并将其标识为 identifier（@”cell”），这样一个 cell 就创建完成了</span></span><br><span class="line">        cell = [[NoteListCell alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:kCellReuseIdentifier];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定指定数据</span></span><br><span class="line">    VNNote *note = [<span class="keyword">self</span><span class="variable">.dataSource</span> objectAtIndex:indexPath<span class="variable">.row</span>];</span><br><span class="line">    note<span class="variable">.index</span> = indexPath<span class="variable">.row</span>;</span><br><span class="line">    [cell updateWithNote:note];</span><br><span class="line">    <span class="comment">// Make sure the constraints have been added to this cell, since it may have just been created from scratch</span></span><br><span class="line">    [cell setNeedsUpdateConstraints];</span><br><span class="line">    [cell updateConstraintsIfNeeded];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>情况 B: 具有多种类型的 Cell</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *cellIdentifier;</span><br><span class="line">    <span class="built_in">UITableViewCellStyle</span> cellStyle;</span><br><span class="line">    <span class="keyword">switch</span> ((indexPath<span class="variable">.row</span> + <span class="number">1</span>)%<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">            <span class="comment">//有标题和副标题，可选图片</span></span><br><span class="line">            cellIdentifier = <span class="string">@"Subtitle Style"</span>;</span><br><span class="line">            cellStyle = <span class="built_in">UITableViewCellStyleSubtitle</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            <span class="comment">//左边文字左对齐，右边文字右对齐，可选的图片</span></span><br><span class="line">            cellIdentifier = <span class="string">@"Value1 Style"</span>;</span><br><span class="line">            cellStyle = <span class="built_in">UITableViewCellStyleValue1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">            <span class="comment">//左边文字右对齐，蓝色字体。右边文字左对齐，黑色。没有图片</span></span><br><span class="line">            cellIdentifier = <span class="string">@"Value2 Style"</span>;</span><br><span class="line">            cellStyle = <span class="built_in">UITableViewCellStyleValue2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:&#123;</span><br><span class="line">            <span class="comment">//有标题，没有副标题，可选的图片</span></span><br><span class="line">            cellIdentifier = <span class="string">@"Default Style"</span>;</span><br><span class="line">            cellStyle = <span class="built_in">UITableViewCellStyleDefault</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSInteger</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">UITableViewCell</span> *myCell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];</span><br><span class="line">    <span class="keyword">if</span> (!myCell) &#123;</span><br><span class="line">        myCell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:cellStyle reuseIdentifier:cellIdentifier];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"创建%d次"</span>,++times);</span><br><span class="line">    &#125;</span><br><span class="line">    myCell<span class="variable">.textLabel</span><span class="variable">.text</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"第%d行%@"</span>,indexPath<span class="variable">.row</span>+<span class="number">1</span>, cellIdentifier];</span><br><span class="line">    myCell<span class="variable">.detailTextLabel</span><span class="variable">.text</span> = <span class="string">@"Subtitle Text"</span>;</span><br><span class="line">    <span class="keyword">if</span> (indexPath<span class="variable">.row</span> &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        myCell<span class="variable">.imageView</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"smile.png"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myCell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未完待续……</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="http://sharonhu1990.github.io/2015/10/28/%E6%B5%85%E6%9E%90UITableViewCell%E9%87%8D%E7%94%A8%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">浅析UITableViewCell重用机制</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>在本系列文章中，我将和大家聊一聊关于 UITableView 的种种，那些你知道的或者不知道的事。</p>
</blockquote>
<p>前几天正好看了关于 AutoLayout 与 UITableViewCell 高度动态计算的文章，于是便在 <a href="https://github.com/tangqi92/SuperNote">SuperNote</a> 上践行了所学的知识，并做了相关笔记的总结，在此与大家进行分享。</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="UITableView" scheme="http://itangqi.me/tags/UITableView/"/>
    
      <category term="UITableViewCell" scheme="http://itangqi.me/tags/UITableViewCell/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Text Kit 学习笔记]]></title>
    <link href="http://itangqi.me/2016/02/18/the-notes-of-learning-text-kit/"/>
    <id>http://itangqi.me/2016/02/18/the-notes-of-learning-text-kit/</id>
    <published>2016-02-17T16:00:00.000Z</published>
    <updated>2016-04-19T08:45:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>目前，我正在开发自己的第一款 iOS App: <a href="https://github.com/tangqi92/SuperNote" target="_blank" rel="external">SuperNote</a>, 作为一款笔记类应用，其最基础也是最核心的功能便是富文本的编辑。起初为了能快速地实现此功能，我直接使用了 <a href="https://github.com/ibireme/YYText" target="_blank" rel="external">YYText</a>, 照着其 Demo 改了改便基本实现了需求，虽然看似便捷但随后我便发现自己其实是「知其然，而不知其所以然」，对于其中的实现原理只知胜少。</p>
<p>于是决定对富文本编辑的实现原理进行一探究竟，而 <a href="https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html" target="_blank" rel="external">Text Kit</a> 便是今天的主角。</p>
<a id="more"></a> 
<hr>
<h2 id="简介">简介</h2><p>苹果在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html" target="_blank" rel="external">Text Programming Guide for iOS</a> 中对其做了如下解释:</p>
<blockquote>
<p>“Text Kit is a set of classes and protocols in the UIKit framework that provide high-quality typographical services which enable applications to store, lay out, and display text with all the characteristics of fine typesetting, such as kerning, ligatures, line-breaking, and justification.”</p>
</blockquote>
<p>一句话总结：<strong>Text Kit 就是为文字排版与渲染孕应而生的。</strong></p>
<h3 id="历史">历史</h3><p><strong>iOS 2</strong>：这是第一个公开的 SDK，包括一个简单的文本显示组件（UILabel），一个简单的文本输入组件（UITextField），以及一个简单的、可滚动、可编辑的并且支持更大量文本的组件：UITextView。这些组件都只支持纯文本，没有文本选择支持（仅支持插入点），除了设置字体和文本颜色外几乎没有其他可定制功能。</p>
<p><strong>iOS 3</strong>：新特性有复制和粘贴，以及复制粘贴所需要的文本选择功能。数据探测器（Data Detector）为文本视图提供了一个高亮电话号码和链接的方法。然而，除了打开或关闭这些特性外，开发者基本上没有什么别的事情可以做。</p>
<p><strong>iOS 3.2</strong>：iPad 的出现带来了 CoreText，一个低级文本布局和渲染引擎（从Mac OS X 10.5 移植过来的），以及 UITextInput，就是前面也提到的键盘存取协议。</p>
<p><strong>iOS 4</strong>：iOS 3.2 发布仅仅几个月后就发布了，文本方面没有一丁点新功能。</p>
<p><strong>iOS 5</strong>：文本方面没啥变化。</p>
<p><strong>iOS 6</strong>：有些动作了：属性文本编辑被加入了 UITextView。很不幸的是，它很难定制。默认的 UI 有粗体、斜体和下划线。用户可以设置字体大小和颜色。粗看起来相当不错，但还是没法控制布局或者提供一个便利的途径来定制文本属性。然而对于（文本编辑）开发者，有一个大的新功能：可以继承 UITextView 了，这样的话，除了以前版本提供的键盘输入外，开发者可以“免费”获得文本选择功能。而在这以前，开发者必须实现一个完全自定义的文本选择功能，这可能是很多非纯文本工具的开发半途而废的原因。</p>
<p><strong>iOS 7</strong>：终于等来了 TextKit。</p>
<h3 id="架构">架构</h3><p>在 <strong>iOS 6 之前</strong>，WebView 通常是呈现混合风格，如粗体，斜体，甚至颜色文本的最简单方法。</p>
<p>在 <strong>iOS 6 时代</strong>，文本控件如：UILabel、UITextField 和 UITextView 是基于 String Drawing 和 WebKit 构建的。其中 String Drawing 与 Core Graphics 直接通信。因此在iOS 7 之前文本控件也可以实现多种样式的文字排版，但是事实上是通过 WebKit 实现的。WebKit 是一种浏览器内核技术，使用它进行文字渲染会消耗掉比较多的内存，对应用的性能有一定的影响。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-01.png" alt=""></p>
<p>在 <strong>iOS 7 时代</strong>，Text Kit 是建立在 Core Text 之上的，它通过 Core Text 与 Core Graphics 进行交互。而文本控件如：UILabel、UITextField 和 UITextView，则构建于 Text Kit 之上，可见这些文本控件可以利用 Text Kit 提供的 API 来对文字进行排版和渲染处理。从下图可见，UIWebView 是基于 WebKit 的，它不能使用 Text Kit 提供的功能。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-02.png" alt=""></p>
<hr>
<h2 id="核心">核心</h2><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-04.png" alt=""></p>
<p>下面将对上图涉及到的核心类进行一一解释：</p>
<ol>
<li><p><code>UITextView</code>：<br>在 TextKit 中，有两个目的：第一，它是文本系统用来绘制的视图。文本视图它自己并不会做任何绘制；它仅仅提供一个供其它类绘制的区域。第二，处理所有的用户交互，具体来说，Text View 实现 UITextInput 的协议来处理键盘事件，它为用户提供了一种途径来设置一个插入点或选择文本。它并不对文本做任何实际上的改变，仅仅将这些改变请求转发给刚刚讨论的 Text Storage。</p>
</li>
<li><p><code>NSTextStorage</code>:<br>顾名思义，NSTextStorage 就是用来存储文本的字符和相关属性的，例如字体或段落信息等，因为它是 <code>NSMutableAttributedString</code> 的子类，这也就是为什么它来负责存储文本的属性。此外，当 NSTextStorage 中的字符或属性发生改变时，会通知 <code>NSLayoutManager</code>, 进而做到文本内容的显示更新。</p>
</li>
<li><p><code>NSLayoutManager</code>:<br>该类负责对文字进行编辑排版处理，将存储在 <code>NSTextStorage</code> 中的数据转换为可以在视图控件中显示的文本内容，并把字符编码映射到对应的字形上，然后将字形排版到 <code>NSTextContainer</code> 定义的区域中。</p>
</li>
<li><p><code>NSTextContainer</code>:<br>定义了文本可以排版的区域，默认情况下是矩形区域，如果是其他形状的区域，需要通过子类化 NSTextContainer 来创建。</p>
</li>
</ol>
<p>它们的关系可见下图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-06.png" alt=""></p>
<p><code>NSLayoutManager</code> 对象从 <code>NSTextStorage</code> 对象中取得文本内容，进行排版，然后把排版之后的文本放到 <code>NSTextContainer</code> 对象指定的区域上。最后再由一个文本控件从 <code>NSTextContainer</code> 中取出内容显示到屏幕中。</p>
<h3 id="使用场景">使用场景</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-09.png" alt=""></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-08.png" alt=""></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-07.png" alt=""></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-10.png" alt=""></p>
<h3 id="补充">补充</h3><ol>
<li><code>Core Text</code>: 没有直接包含在 TextKit 中，CoreText 是进行实际排版的库。对于布局管理器的每一步，CoreText 被这样或那样的方式调用。它提供了从字符到字形的翻译，用它们来填充行，以及建议断字点</li>
<li><code>NSAttributedString</code>: 就是用来设置文字的效果(颜色、字体、下划线等等)</li>
<li><p><code>NSMutableAttributedString</code>:是 NSAttributedString 的子类，可变类型的NSAttributedString</p>
<p> <img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-05.jpg" alt=""></p>
</li>
</ol>
<hr>
<h2 id="功能">功能</h2><ol>
<li>对文字进行分页或多列排版</li>
<li>支持文字的换行、折叠和着色等处理</li>
<li>可以调整字与字之间的距离、行间距、文字大小、指定特定的字体</li>
<li>支持富文本编辑，可以自定义文字截断</li>
<li>支持凸版印刷效果（letterpress）</li>
<li>支持数据类型的检测（例如链接、附件等）</li>
</ol>
<p>效果如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-11.png" alt=""></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-12.png" alt=""></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-13.png" alt=""></p>
<p>本文并不会对具体功能的实现进行详细的阐述，毕竟本文重点是了解内在的实现原理而非具体实现。好啦，剩下的事情就交给你了！</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html" target="_blank" rel="external">Using Text Kit to Draw and Manage Text</a></li>
<li><a href="https://www.objc.io/issues/5-ios7/getting-to-know-textkit/" target="_blank" rel="external">Getting to Know TextKit</a></li>
<li><a href="https://www.raywenderlich.com/50151/text-kit-tutorial" target="_blank" rel="external">Text Kit Tutorial</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>目前，我正在开发自己的第一款 iOS App: <a href="https://github.com/tangqi92/SuperNote">SuperNote</a>, 作为一款笔记类应用，其最基础也是最核心的功能便是富文本的编辑。起初为了能快速地实现此功能，我直接使用了 <a href="https://github.com/ibireme/YYText">YYText</a>, 照着其 Demo 改了改便基本实现了需求，虽然看似便捷但随后我便发现自己其实是「知其然，而不知其所以然」，对于其中的实现原理只知胜少。</p>
<p>于是决定对富文本编辑的实现原理进行一探究竟，而 <a href="https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html">Text Kit</a> 便是今天的主角。</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自学 iOS 开发之旅]]></title>
    <link href="http://itangqi.me/2016/02/08/the-journey-of-learning-ios/"/>
    <id>http://itangqi.me/2016/02/08/the-journey-of-learning-ios/</id>
    <published>2016-02-07T16:00:00.000Z</published>
    <updated>2016-04-19T08:41:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>不知不觉，学习 iOS 开发已经有 3 个多月的时间了，我想，也是时候写篇文章作为总结与回顾了吧。</p>
</blockquote>
<a id="more"></a> 
<p>我相信，很多人都会有这样的经历：每当他在学习一门新语言时，都会阅读许多 <strong>XXX 自学必备资源</strong> 这类的文章，然后一股脑地买下推荐的书，收藏推荐的网站，下载推荐的视频，订阅推荐的邮箱，注册推荐的论坛等等，当时那个热血沸腾劲，心中一定默默地告诉自己：「来吧，我 XXX 要大干一场了！」</p>
<p>然而现实却是：在经过几天的热血过后，你会发现其实你并没有那么多精力与时间去学习去消化那么多资料，一方面的确是因为你时间有限，另一方面更因为并不是所有的都适合现阶段的你。一段时间过，你会发现有些收藏的网站你始终未打开过，有些订阅的邮件你从未阅读过，有些下载的视频你从未看过。</p>
<p>所以，凡事都不能心急与贪多，稳扎稳打方能在学习的道路上越走越远。文中所列出的资料（均以时间为顺序排列），都是到目前为止我所学习过的，并且我会定期更新文章，记录我一步步从小白到<strong>大牛</strong>的心路历程（真是不要脸啊！）。</p>
<hr>
<h2 id="书籍">书籍</h2><p><strong>1. <a href="http://book.douban.com/subject/19962787/" target="_blank" rel="external">Objective-C 编程</a></strong></p>
<p>  本书首先从基本的编程概念讲起（变量、条件语句、循环结构等），接着用浅显易懂的语言讲解 Objective-C 和 Foundation 的知识，包括 Objective-C 的基本语法、 Foundation 常用类 、内存管理、常用设计模式等。—— 本书内容浅显易懂，比较适合作为 OC 的入门书籍。</p>
<p><strong>2. <a href="http://book.douban.com/subject/26287812/" target="_blank" rel="external">iOS 编程（第4版）</a></strong></p>
<p>  本书涵盖了开发 iOS 应用的方方面面：从 Objective-C 基础知识到新增加的语言特性；从 AppKit 库到常见的 Cocoa 设计模式；从 Xcode 技巧到 Instruments 等。—— 本书手把手带你一步步完成一个完整的 iOS 应用，随着章节的深入，循序渐进地不断完善与优化，让你深切体会到开发一款应用所需了解的方方面面。</p>
<p><strong>3. <a href="http://book.douban.com/subject/26287173/" target="_blank" rel="external">iOS 开发进阶</a></strong></p>
<p>  本书分工具、实践、理论三大部分：第一部分介绍 iOS 开发的常用工具；第二部分介绍 iOS 开发中的一些常见的实践经验；第三部分介绍 iOS 开发中涉及的原理。—— 本书中绝大部分内容都能在作者的博客中找到，所谓「进阶」，我想作者更多的是在抛砖引玉吧。</p>
<p><strong>4. <a href="http://book.douban.com/subject/24284008/" target="_blank" rel="external">Objective-C 基础教程</a></strong></p>
<p>  本书全面系统地讲述了 Objective-C 的基础知识和面向对象编程的重要概念，结合实例介绍了 Cocoa 工具包的优秀特性及框架，以及继承、复合、对象初始化、类别、协议、内存管理和源文件组织等重要编程技术。—— 本想作为 OC 的进阶书籍阅读，但并没有预期中好。</p>
<p><strong>5. <a href="http://book.douban.com/subject/19967897/" target="_blank" rel="external">Objective-C 程序设计</a></strong></p>
<p>  本书是针对初学者编写的一个完整又循序渐进的 Objective-C 语言权威入门。阅读本书，不需要先学过 C 语言或其他面向对象语言。本书包含许多详细且实用的范例，用来告诉你如何在实践中运用Objective-C。本书完整展示如何利用 Foundation framework 所提供的丰富自带类库 (Library of classes)，并对 iOS 程序设计原理有所讲解。—— 与《Objective-C 编程》同样作为入门书籍，内容相对前者详实许多。</p>
<p><strong>6. <a href="http://book.douban.com/subject/24720270/" target="_blank" rel="external">Objective-C 高级编程</a></strong></p>
<p>  本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码, 告诉你一些苹果公司官方文档中不会出现的知识。—— 真正的 OC 进阶书籍，满满的干货，值得反复阅读。</p>
<p><strong>7. <a href="http://book.douban.com/subject/25829244/" target="_blank" rel="external">Effective Objective-C 2.0</a></strong></p>
<p>  本书从语法、接口与 API 设计、内存管理、框架等 7 大方面总结和探讨了 Objective-C 编程中 52 个鲜为人知和容易被忽视的特性与陷阱。书中包含大量实用范例代码，为编写易于理解、便于维护、易于扩展和高效的 Objective-C  应用提供了解决方案。—— Effective 系列为进阶必备之书，但我认为应该在有一定的项目经验后回过头来阅读，才更能体会其中的精髓。</p>
<p><strong>8. <a href="http://producter.io/" target="_blank" rel="external">Producer</a> by <a href="http://weibo.com/kevinzhow" target="_blank" rel="external">周楷雯Kevin</a></strong></p>
<p>  本书主要涵盖了：设计原理、原型，动效，交互设计、iOS 开发与营销，这四个部分，以 <strong>小记</strong> 作为例子，完整的还原了一款产品从想法到编码，再到上架，以及营销的全过程。 —— 它会作为叩响你成为独立开发者大门的敲门砖。</p>
<p><strong>9. <a href="https://gumroad.com/l/JnWS" target="_blank" rel="external">A GUIDE TO IOS ANIMATION</a> by <a href="http://weibo.com/imapplegeeker" target="_blank" rel="external">KITTEN-YANG</a></strong></p>
<p>  动画小王子的力作 —— 如何你想学习动画，那么就选它作为入门吧。</p>
<hr>
<h2 id="视频">视频</h2><p><strong>1. <a href="https://itunes.apple.com/us/course/developing-ios-7-apps-for/id733644550" target="_blank" rel="external">Developing iOS 7 Apps for iPhone and iPad</a></strong></p>
<p>目前唯一看过的视频教程，老爷子讲得非常棒，如果你想学习 Swift ，可以搜索其相应的课程。我是一边看视频一边将课上所讲的例子都手敲实现了一遍，最后对 iOS 开发有了较全面的了解。</p>
<p><strong>2. <a href="https://developer.apple.com/videos/" target="_blank" rel="external">WWDC Session</a></strong></p>
<p>苹果自家的视频，内容相当多，计划之后空下来按系列来看。</p>
<hr>
<h2 id="开源项目">开源项目</h2><p><strong>1. <a href="https://github.com/dsxNiubility/SXNews" target="_blank" rel="external">SXNews</a></strong></p>
<p>  精仿网易新闻客户端 —— 学习 Android 时第一个仿写的应用便是网易新闻。</p>
<p><strong>2. <a href="https://github.com/hshpy/HPYZhiHuDaily" target="_blank" rel="external">HPYZhiHuDailly</a></strong></p>
<p>  采用 MVVM 的 OC 版知乎客户端 —— 第一个 Android 开源项目便是仿写知乎。</p>
<p><strong>3. <a href="https://github.com/liaojinxing/Voice2Note" target="_blank" rel="external">Voice2Note</a></strong></p>
<p>  懒人笔记客户端 —— 第一个完整的 iOS 应用便是以此为基础进行修修改改的。</p>
<p><strong>4. <a href="https://github.com/meilbn/MyOne-iOS" target="_blank" rel="external">MyOne</a></strong></p>
<p>  精仿「一个」iOS 客户端 —— 代码规范，难度适中，非常适合拿来当做练手的项目。目前希望能将其剩余未完成的功能完成。</p>
<p><strong>5. <a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding</a></strong></p>
<p>  Coding 官方 iOS 客户端 —— 官方源码，编写规范，文档较完整，且不断更新中，是个进阶学习的项目。</p>
<hr>
<h2 id="博客">博客</h2><p><strong>1. <a href="https://www.objc.io/" target="_blank" rel="external">objc</a></strong></p>
<pre><code>objc<span class="class">.io</span> 国外一个定期发布关于 Objective-c 的最佳实践以及进阶技术的网站，基本上是每月一期，每期关注一个技术主题，围绕这个主题，有几篇文章涉及到本主题的不同方面。
</code></pre><p>当然，我订阅了许多国内外大牛的技术博客，但是我觉得，如果不是系列性的文章，我更喜欢<strong>通过 Google 搜索关键字来快速寻找出最符合我当下要求的文章来阅读学习</strong>。</p>
<hr>
<h2 id="其他">其他</h2><p><strong><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md" target="_blank" rel="external">《招聘一个靠谱的 iOS》面试题参考答案</a></strong></p>
<p>  面试题来自 <a href="http://weibo.com/u/1364395395" target="_blank" rel="external">微博@我就叫Sunny怎么了</a> 的博文<a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/" target="_blank" rel="external">《招聘一个靠谱的 iOS》</a>，其中共 55 题，除第 1 题为纠错题外，其他 54 道均为简答题，答案为 <a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">微博@iOS程序犭袁</a> 整理。—— 由于有年后进行实习生面试的计划，所以，我每天都会来看上两题。当然，即使你不为面试，这里的题目也可以作为检验你学习成果的一个有效方法。</p>
<blockquote>
<p>未完待续……</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>不知不觉，学习 iOS 开发已经有 3 个多月的时间了，我想，也是时候写篇文章作为总结与回顾了吧。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Summary" scheme="http://itangqi.me/tags/Summary/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Bye 2015, Hi 2016]]></title>
    <link href="http://itangqi.me/2015/12/25/bye2015-hi2016/"/>
    <id>http://itangqi.me/2015/12/25/bye2015-hi2016/</id>
    <published>2015-12-24T16:00:00.000Z</published>
    <updated>2016-02-25T05:44:11.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>世上哪有终点？什么时候你走不动了，倒下了，那里才是终点。—— 今何在《西游日记》</p>
</blockquote>
<a id="more"></a>
<h2 id="考研">考研</h2><p>2015 年 3 月 25 日，当我接到录取通知电话的那一刻，压在我心底的所有，顷刻间都释然了。</p>
<p>喜悦的心情只持续了片刻吧，我脑海中的思绪便飘回到了 2014 年。</p>
<p>那年是我第一次考研，考试前，几乎所有认识我的人，都认为我考上是铁板钉钉的事，而对我而言，我不但要求自己要考上而且还要考第一。可想而知，正是这样的心态导致了我在考场上的心态失衡，而最终的结果便是以我彻彻底底地失败告终。</p>
<p>没错，不愿就此放弃，确切的说，不愿就此否定自己的我选择了二战。由于时间尚早，加之马上面临毕业的我不愿再向家人伸手要钱了，所以我选择立马工作来作为那段时间的过度。</p>
<p>于是……</p>
<p>思绪不知不觉又飘了回来，此时的我还在北信源南京研发中心，回想过去的一年，整个移动开发团队由最初的 3 人扩展到现在的 10 人。感谢已经离职的大飞哥，正是你当时的赏识让我有幸加入，尽管当时你已经提出离职，还是尽职尽责地带着我们几个新人熟悉项目并帮助我们快速提升技术；感谢团队现在的老大王总和姚总，你们为人非常和蔼平易敬人，会尽一切努力为团队的利益着想；感谢一起共事过的小伙伴们，没有你们，我真的无法在在职的情况下完成考研的复习，是你们给了我支持与信任。</p>
<p>对我而言，考研是一种历练，而过程远远大于结果。</p>
<h2 id="跳槽">跳槽</h2><p>2015 年 5 月 6 日，在面试结束后，我当场便收到了 FriendMedia 的 Offer，像这样一个小而美且工程师文化浓厚的团队，正是我梦寐以求想要加入的。与此同时，我也到了和北信源说再见的时候了。</p>
<p>舒适的工作环境，扁平化的管理模式，聪明且有激情的同事，富有挑战性的工作，在 FM 的每一天都充满着压力但却快速的成长着。</p>
<p>入职后我便由师哥带着参与到公司核心产品的开发，由于能力有限，我的工作从实现界面 UI 开始，看似简单的工作内容，实践起来却总会遇到各种各样的问题。放到之前，我会索性告诉领导这个做不了，但现在我却是加班加点想尽办法去实现，我想正是因为归属感吧。</p>
<p>由于界面的改版得到了师哥和老总的认可，我得到了完成下一版本某关键功能的开发任务，由于是创业公司，我们奉行快速迭代，可要在短时间内完成，对于当时的我来说，是非常具有挑战性的。最终，尽管我为此熬了好几个夜，也没能在 Deadline 前百分百完成任务。事后，师哥帮我填了坑，王总则教会了我将来在面对此类问题时，一定要及时向大家提出，埋头苦干不是解决问题的办法。</p>
<p>虽然公司不大，但每一个人都是独挡一面的能手，而当时的我却似乎在拖大家的后腿，无形的压力与内疚充斥着我每天的工作，但公司或者说王总的包容却坚定我要努力证明自己的价值。恰巧此时公司有一个国外的外包项目需要改版升级，由于师哥要接着负责公司自己的产品，这个外包项目便顺理成章的由我来完成。</p>
<p>庆幸的是，改版过程相对顺利，我在预定的时间内完成了任务，期间我的能力也得到了迅速的提升，我能对一个项目有较为完整的把控。可此时，时间也悄悄来到了 8 月下旬。</p>
<p>短暂却充实的三个月很快就结束了，我也到了不得不和 FM 说再见的时候了。在这里，我结识了一群聪明且又友爱的伙伴们；在这里，我体会到了创业公司的激情与不易；在这里，我一步步走向了 Android 开发的正轨。感谢 FM 带给我的一切，愿你的未来一帆风顺。</p>
<h2 id="重返校园">重返校园</h2><p>2015 年 8 月 31 日，我正式成为东大软院的一名研究僧。从大专到本三再到重点本科，一路走来，我从未想证明给任何人看，我只是单纯的不信邪，我始终坚信着我可以。</p>
<p>正是因为之前的工作经历，让我比其他应届的同学有着更为清晰的自我认识与更为明确的职业规划，对于选择明年就出去实习的我而言，我很清楚其实留给我的时间不多了。</p>
<p>回首过去的四个月，<strong>开源</strong> 与 <strong>iOS</strong> 不得不提。</p>
<p>开学以来，陆续开源了 BuildingBlocks、 Android-Tips 与 WaveLoadingView 三个项目，因为开源，我认识了许多志同道合的朋友们（大牛们）；因为开源，我意识到自己的付出是有价值的；因为开源，我不断向她汲取着知识的同时也分享着成果。我很庆幸能叩响开源的这扇大门，得以让我能见识到开源世界的种种美好，这些带给我的快乐与满足，要远远比收集到的星星数与粉丝数重要的多得多。</p>
<p>而转战 iOS，则是再一次从了自己的内心，即使周围的很多人都不理解，即使现在很多人说 iOS 市场已经饱和，在这里，我不想过多的探讨 iOS 与 Android 的孰优孰劣，亦或是未来的前景如何，但我知道，我只是单纯的选择了一件自己更喜欢的事情去做，对我而言就够了。我的一个 iOS 项目现在也接近尾声了，期待开源的那一天吧。</p>
<p>除此之外，我还在努力地夯实基础与扩充技术栈，从数据结构到算法再到前端最后到设计，每接触到一个新领域，总能有发现新大陆般的喜悦与激动。</p>
<h2 id="<2016>"><2016></2016></h2><p>下一站会是哪里？我会遇到怎样的人？还会经历哪些磨砺？– 我不知道，但我很期待！</p>
<h2 id="书单列表">书单列表</h2><ol>
<li><a href="http://book.douban.com/subject/1770782/" target="_blank" rel="external">追风筝的人</a></li>
<li><a href="http://book.douban.com/subject/10763902/" target="_blank" rel="external">偷影子的人</a></li>
<li><a href="http://book.douban.com/subject/25850737/" target="_blank" rel="external">想得美</a></li>
<li><a href="http://book.douban.com/subject/26183838/" target="_blank" rel="external">我想看到的世界</a></li>
<li><a href="http://book.douban.com/subject/26266755/" target="_blank" rel="external">塔利班</a></li>
<li><a href="http://book.douban.com/subject/26613294/" target="_blank" rel="external">Objective-C编程(第2版)</a></li>
<li><a href="http://book.douban.com/subject/26287812/" target="_blank" rel="external">iOS编程（第4版）</a></li>
<li><a href="http://book.douban.com/subject/26287173/" target="_blank" rel="external">iOS开发进阶</a></li>
<li><a href="http://book.douban.com/subject/25752357/" target="_blank" rel="external">Head First HTML与CSS(第2版)</a></li>
</ol>
<h2 id="Podcast_列表">Podcast 列表</h2><ol>
<li><a href="https://ipn.li/itgonglun/" target="_blank" rel="external">IT 公论</a></li>
<li><a href="https://ipn.li/kernelpanic/" target="_blank" rel="external">内核恐慌</a></li>
<li><a href="http://teahour.fm/" target="_blank" rel="external">Teahour</a></li>
<li><a href="https://ipn.li/xuanmei/" target="_blank" rel="external">选·美</a></li>
</ol>
<h2 id="推荐利器">推荐利器</h2><p><a href="https://getpocket.com" target="_blank" rel="external">Pocket</a></p>
<h2 id="无主题">无主题</h2><blockquote>
<p>感谢过去一年我所经历的事，感谢过去一年我所遇到的人，感谢过去一年我所收获和失去的情感。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>世上哪有终点？什么时候你走不动了，倒下了，那里才是终点。—— 今何在《西游日记》</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Review" scheme="http://itangqi.me/tags/Review/"/>
    
      <category term="Summary" scheme="http://itangqi.me/tags/Summary/"/>
    
      <category term="Life" scheme="http://itangqi.me/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WaveLoadingView - 水波加载]]></title>
    <link href="http://itangqi.me/2015/12/15/waveloadingview/"/>
    <id>http://itangqi.me/2015/12/15/waveloadingview/</id>
    <published>2015-12-14T16:00:00.000Z</published>
    <updated>2016-02-25T05:42:36.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><strong>WaveLoadingView</strong> - An Android library that provides a realistic wave-loading effect.</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="Sample">Sample</h2><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/waveloadingview.png" alt="sample" title="sample" width="400" height="680"></p>
<hr>
<h2 id="Usage">Usage</h2><p><strong>For a working implementation of this project see the <code>sample/</code> folder.</strong></p>
<h3 id="Step_1">Step 1</h3><p>Include the library as a local library project or add the dependency in your build.gradle.</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'me.itangqi.waveloadingview:library:0.2.0'</span></span><br><span class="line">    <span class="comment">// I have uploaded v0.2.0 on 2016-02-17, if it doesn't take effect or your </span></span><br><span class="line">    <span class="comment">// gradle cannot find it in maven central, you may try v0.1.5. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
<p>Or</p>
<p>Import the library, then add it to your /settings.gradle and /app/build.gradle. If you don’t know how to do this, you can read my blog for help.</p>
<h3 id="Step_2">Step 2</h3><p>Include the WaveLoadingView widget in your layout. And you can customize it like this.</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;me.itangqi.waveloadingview.WaveLoadingView</span><br><span class="line">    android:id=<span class="string">"@+id/waveLoadingView"</span></span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_borderColor=<span class="string">"@color/colorAccent"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_borderWidth=<span class="string">"3dp"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_progressValue=<span class="string">"40"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_shapeType=<span class="string">"circle"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_titleBottom=<span class="string">"Bottom Title"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_titleBottomColor=<span class="string">"@color/colorPrimaryText"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_titleBottomSize=<span class="string">"20sp"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_titleCenter=<span class="string">"Center Title"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_titleCenterColor=<span class="string">"@color/colorPrimaryText"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_titleCenterSize=<span class="string">"24sp"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_titleTop=<span class="string">"Top Title"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_titleTopColor=<span class="string">"@color/colorPrimaryText"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_titleTopSize=<span class="string">"20sp"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_waveAmplitude=<span class="string">"70"</span></span><br><span class="line">    <span class="keyword">app</span>:wlv_waveColor=<span class="string">"@color/colorAccent"</span>/&gt;</span><br></pre></td></tr></table></figure> 
<h3 id="Step_3">Step 3</h3><p>You can write some animation codes to the callbacks such as setOnCheckedChangeListener, onProgressChanged, etc in your Activity.</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WaveLoadingView mWaveLoadingView = (WaveLoadingView) findViewById(R.id.waveLoadingView)<span class="comment">;</span></span><br><span class="line">truemWaveLoadingView.setShapeType(WaveLoadingView.ShapeType.CIRCLE)<span class="comment">;</span></span><br><span class="line">truemWaveLoadingView.setTopTitle("Top Title")<span class="comment">;</span></span><br><span class="line">truemWaveLoadingView.setCenterTitleColor(Color.GRAY)<span class="comment">;</span></span><br><span class="line">truemWaveLoadingView.setBottomTitleSize(18)<span class="comment">;</span></span><br><span class="line">truemWaveLoadingView.setProgressValue(80)<span class="comment">;</span></span><br><span class="line">truemWaveLoadingView.setBorderWidth(10)<span class="comment">;</span></span><br><span class="line">truemWaveLoadingView.setAmplitudeRatio(60)<span class="comment">;</span></span><br><span class="line">truemWaveLoadingView.setWaveColor(Color.GRAY)<span class="comment">;</span></span><br><span class="line">truemWaveLoadingView.setBorderColor(Color.GRAY)<span class="comment">;</span></span><br></pre></td></tr></table></figure> 
<h2 id="Customization">Customization</h2><p>Do what you what :)</p>
<table>
<thead>
<tr>
<th style="text-align:center">name</th>
<th style="text-align:center">format</th>
<th style="text-align:center">description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">wlv_borderWidth</td>
<td style="text-align:center">dimension</td>
<td style="text-align:center">set border width, default is 0</td>
</tr>
<tr>
<td style="text-align:center">wlv_borderColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">set border color</td>
</tr>
<tr>
<td style="text-align:center">wlv_progressValue</td>
<td style="text-align:center">integer</td>
<td style="text-align:center">set progress value, default is 50</td>
</tr>
<tr>
<td style="text-align:center">wlv_shapeType</td>
<td style="text-align:center">enum</td>
<td style="text-align:center">set shape type, default is circle</td>
</tr>
<tr>
<td style="text-align:center">wlv_waveColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">set wave color</td>
</tr>
<tr>
<td style="text-align:center">wlv_waveAmplitude</td>
<td style="text-align:center">float</td>
<td style="text-align:center">set wave amplitude</td>
</tr>
<tr>
<td style="text-align:center">wlv_titleTopSize</td>
<td style="text-align:center">dimension</td>
<td style="text-align:center">set top title size, default is 18 </td>
</tr>
<tr>
<td style="text-align:center">wlv_titleCenterSize</td>
<td style="text-align:center">dimension</td>
<td style="text-align:center">set center title size, default is 22</td>
</tr>
<tr>
<td style="text-align:center">wlv_titleBottomSize</td>
<td style="text-align:center">dimension</td>
<td style="text-align:center">set bottom size, default is 18</td>
</tr>
<tr>
<td style="text-align:center">wlv_titleTopColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">set top title color</td>
</tr>
<tr>
<td style="text-align:center">wlv_titleCenterColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">set center title color </td>
</tr>
<tr>
<td style="text-align:center">wlv_titleBottomColor</td>
<td style="text-align:center">color</td>
<td style="text-align:center">set bottom title color </td>
</tr>
<tr>
<td style="text-align:center">wlv_titleTop</td>
<td style="text-align:center">string</td>
<td style="text-align:center">set top title content, default is null</td>
</tr>
<tr>
<td style="text-align:center">wlv_titleCenter</td>
<td style="text-align:center">string</td>
<td style="text-align:center">set center title content, default is null</td>
</tr>
<tr>
<td style="text-align:center">wlv_titleBottom</td>
<td style="text-align:center">string</td>
<td style="text-align:center">set bottom title content, default is null</td>
</tr>
</tbody>
</table>
<p><strong>All attributes have their respective getters and setters to change them at runtime.</strong></p>
<h2 id="Change_Log">Change Log</h2><h3 id="0-2-0_(2016-02-17)">0.2.0 (2016-02-17)</h3><h4 id="Implemented_enhancements:">Implemented enhancements:</h4><ul>
<li>Prefix the attributes with “wlv”</li>
</ul>
<h4 id="Fixed_bugs:">Fixed bugs:</h4><ul>
<li>setProgressValue() increase doesn’t conform to logic <a href="https://github.com/tangqi92/WaveLoadingView/issues/8" target="_blank" rel="external">#8</a></li>
</ul>
<h4 id="Update:">Update:</h4><ul>
<li>Update <code>build.gradle</code></li>
<li>Update Sample</li>
</ul>
<h3 id="0-1-5_(2016-01-14)">0.1.5 (2016-01-14)</h3><h4 id="Fixed_bugs:-1">Fixed bugs:</h4><ul>
<li>IllegalArgumentException: width and height must be &gt; 0 while loading Bitmap from View <a href="https://github.com/tangqi92/WaveLoadingView/issues/6" target="_blank" rel="external">#6</a></li>
</ul>
<h3 id="0-1-4_(2015-12-17)">0.1.4 (2015-12-17)</h3><h4 id="Fixed_bugs:-2">Fixed bugs:</h4><ul>
<li>setProgressValue() doesn’t change the value of mProgressValue <a href="https://github.com/tangqi92/WaveLoadingView/issues/4" target="_blank" rel="external">#4</a></li>
</ul>
<h3 id="0-1-3">0.1.3</h3><h4 id="Fixed_bugs:-3">Fixed bugs:</h4><ul>
<li>Attribute “borderWidth” has already been defined <a href="https://github.com/tangqi92/WaveLoadingView/issues/2" target="_blank" rel="external">#2</a></li>
</ul>
<h2 id="Demo">Demo</h2><p><a href="https://github.com/tangqi92/WaveLoadingView/releases/download/v0.1.2/sample-release-unsigned.apk" target="_blank" rel="external">Download</a></p>
<h2 id="Community">Community</h2><p>Looking for contributors, feel free to fork !</p>
<p>Tell me if you’re using my library in your application, I’ll share it in this README.</p>
<h2 id="Thanks">Thanks</h2><p>Inspired by </p>
<ul>
<li><a href="https://github.com/gelitenight/WaveView" target="_blank" rel="external">WaveView</a> created by <a href="https://github.com/gelitenight" target="_blank" rel="external">gelitenight</a></li>
<li><a href="https://github.com/lopspower/CircularFillableLoaders" target="_blank" rel="external">CircularFillableLoaders</a> created by <a href="https://github.com/lopspower" target="_blank" rel="external">lopspower</a></li>
</ul>
<h2 id="License">License</h2><p>Apache 2.0 </p>
<hr>
<h2 id="期待与你成为朋友">期待与你成为朋友</h2><ul>
<li>Weibo: <a href="http://weibo.com/qiktang" target="_blank" rel="external">汤奇V</a>  </li>
<li>GitHub: <a href="https://github.com/tangqi92" target="_blank" rel="external">tangqi92</a></li>
<li>Blog: <a href="http://itangqi.me/">http://itangqi.me</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><strong>WaveLoadingView</strong> - An Android library that provides a realistic wave-loading effect.</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Library" scheme="http://itangqi.me/tags/Library/"/>
    
      <category term="Loading" scheme="http://itangqi.me/tags/Loading/"/>
    
      <category term="View" scheme="http://itangqi.me/tags/View/"/>
    
      <category term="Android" scheme="http://itangqi.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[回归·日记]]></title>
    <link href="http://itangqi.me/2015/11/02/comeback-diary/"/>
    <id>http://itangqi.me/2015/11/02/comeback-diary/</id>
    <published>2015-11-01T16:00:00.000Z</published>
    <updated>2016-02-25T05:44:01.000Z</updated>
    <content type="html"><![CDATA[<h3 id="2015年8月21日">2015年8月21日</h3><p>这一天，我结束了在 <a href="http://friendmedia.com/" target="_blank" rel="external">FriendMedia</a> 三个月短暂却又充实的工作。在这里，我结识了一群聪明且又友爱的伙伴；在这里，我体会到了创业公司的激情与不易；在这里，我一步步走向了 Android 开发的正轨。感谢 FM 给我的一切，愿你的未来一帆风顺。</p>
<p>离职回到家后，由于身体的原因，我逼迫自己休息了一个星期，上午睡个懒觉，下午看看综艺节目，饭后出门散个步，晚上陪老妈扯会家常。让自己慢下来，不看技术文档与满屏的代码，享受与家人在一起的悠闲时光，我很珍惜，真的。</p>
<a id="more"></a> 
<hr>
<h3 id="2015年8月31日">2015年8月31日</h3><p>这一天，我成为了 <a href="http://www.seu.edu.cn/" target="_blank" rel="external">东南大学</a> 软件学院的一名研究僧。从 <a href="http://www.ccit.js.cn/" target="_blank" rel="external">常信</a> 到 <a href="http://cxxy.seu.edu.cn/" target="_blank" rel="external">成贤</a> 再到 <a href="http://www.seu.edu.cn/" target="_blank" rel="external">东大</a>，从大专到本三再到重点本科，一路走来，我从未想证明给任何人看，我只是单纯的「不信邪」，我始终坚信「我可以」。</p>
<p>我心里清楚，从报到的那一刻起，之前所取得的就已经成为过去。而想想下一个目标，既感到鸭梨山大又是那么的激动人心呢。在经历 FM 的历练过后，我对自己未来的职业发展有了更清晰的认识，研究生的日子更多的是靠自己规划，而我也正按着计划一步步的进行着。</p>
<hr>
<h3 id="2015年9月4日">2015年9月4日</h3><p>这一天，<a href="https://github.com/tangqi92/BuildingBlocks" target="_blank" rel="external">BuildingBlocks - 积木</a> 开源了，第一个正儿八经写的小应用，之后便是以每两周一个小版本的速度进行迭代，目标是持续更新到V1.0。</p>
<hr>
<h3 id="2015年9月14日">2015年9月14日</h3><p>这一天，<a href="https://github.com/tangqi92/Android-Tips" target="_blank" rel="external">Android-Tips 填坑手册</a> 开源了，原本只想作为备份书签使用，却意外地收获了大家的支持，Star 数远远超出了自己的预期，4天内就突破了1K。</p>
<p>随着项目得到越来越多人的关注，无形中也鞭策着自己不断前进。在接下来的一个月的时间里，我大部分时间都在进行版本的更新。真心感谢开源，让我不断进步的同时，也认识了许多志同道合的好友们。</p>
<hr>
<h3 id="2015年10月8日">2015年10月8日</h3><p>这一天，闲不下来的我，决定扩充自己的技能树。</p>
<p>首先是<strong>设计</strong>，初衷就是想给自己将来的应用画个漂亮的图标，于是参考 <a href="http://www.zhihu.com/question/23421455" target="_blank" rel="external">有没有 Sketch 相关的教程或者素材下载？</a> 问题下的答案，进行 Sketch 的学习与使用。</p>
<p>其次是<strong>前端</strong>，参考 <a href="http://www.zhihu.com/question/19809484" target="_blank" rel="external">有哪些关于前端开发技术（HTML、CSS 和 JavaScript 等）的值得推荐的书籍？</a> 问题下的答案，买了本 <a href="http://book.douban.com/subject/25752357/" target="_blank" rel="external">Head First HTML与CSS（第2版）</a> 就开始了，然后跟着慕课网 <a href="http://www.imooc.com/course/programdetail/pid/32" target="_blank" rel="external">Web前端工程师</a> 的课程学习。</p>
<p>接下来是<strong>算法</strong>，参考 <a href="http://www.zhihu.com/question/19981544" target="_blank" rel="external">怎样学算法？</a> 问题下的答案，买了本 <a href="http://book.douban.com/subject/10432347/" target="_blank" rel="external">算法</a> 并跟着 coursera 上配套教学视频 <a href="https://www.coursera.org/course/algs4partI" target="_blank" rel="external">算法，第一部分</a> 进行学习。 计划每天刷 <a href="https://leetcode.com/" target="_blank" rel="external">LeetCode</a>，并在 GitHub 上记录<a href="https://github.com/tangqi92/LeetCode" target="_blank" rel="external">解题的思路与答案</a>。</p>
<p>最后，作为一名伪文艺青年，怎能不涉猎文学书籍，期间看完了<a href="http://book.douban.com/subject/26266755/" target="_blank" rel="external">塔利班</a>，现在正看着<a href="http://book.douban.com/subject/24380577/" target="_blank" rel="external">平凡的世界</a>。</p>
<hr>
<h3 id="2015年11月2日">2015年11月2日</h3><p>今天，是我<strong>回归</strong>的日子。</p>
<p>其实很多人不知道，在过去的两年多时间里，我经历了太多太多，我收获了许多，但也失去了许多，过去的经历教会了我成长。</p>
<p>今天是我停药的第7天，在饱受胃病折磨的一年时间里，我的斗志与激情正一点点被消磨，心有余而力不足的感觉糟透了，很多时候，我想做的更多更好，但自己的身体却不容许我全身心的投入进去。</p>
<p>但一切都会过去不是吗？我一直在等今天，等我的胃病痊愈，等我找回那个充满干劲的自己，我想，就是现在了。</p>
<p>是的，我回来了！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="2015年8月21日">2015年8月21日</h3><p>这一天，我结束了在 <a href="http://friendmedia.com/">FriendMedia</a> 三个月短暂却又充实的工作。在这里，我结识了一群聪明且又友爱的伙伴；在这里，我体会到了创业公司的激情与不易；在这里，我一步步走向了 Android 开发的正轨。感谢 FM 给我的一切，愿你的未来一帆风顺。</p>
<p>离职回到家后，由于身体的原因，我逼迫自己休息了一个星期，上午睡个懒觉，下午看看综艺节目，饭后出门散个步，晚上陪老妈扯会家常。让自己慢下来，不看技术文档与满屏的代码，享受与家人在一起的悠闲时光，我很珍惜，真的。</p>]]>
    
    </summary>
    
      <category term="Comeback" scheme="http://itangqi.me/tags/Comeback/"/>
    
      <category term="Diary" scheme="http://itangqi.me/tags/Diary/"/>
    
      <category term="Summary" scheme="http://itangqi.me/tags/Summary/"/>
    
      <category term="Life" scheme="http://itangqi.me/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Tips - 填坑手册]]></title>
    <link href="http://itangqi.me/2015/09/14/android-tips/"/>
    <id>http://itangqi.me/2015/09/14/android-tips/</id>
    <published>2015-09-13T16:00:00.000Z</published>
    <updated>2016-02-25T05:44:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>学习 Android 至今，大大小小的坑没少踩，庆幸的是，在强大的搜索引擎与无私奉献的人们的帮助下，我遇到的坑都顺利地被填平了。</p>
<p>为了便于日后遇到同样的问题时，能免于再次搜索带来的麻烦，我养成了收藏书签的习惯，随着书签（Tips）的日积月累，我想，是时候该有这个项目了。</p>
<a id="more"></a> 
<p><strong>如果你是个 Android 新人，那么我希望这份列表，可以成为你踩到坑时的不完全手册。</strong></p>
<p>当然，这份列表一定会有遗漏，如果不幸，这里没有你所踩到的坑，或者对于某个问题你有更好的 Tips，欢迎分享，让我们一起来维护这个项目！你可以通过 <a href="https://github.com/tangqi92/Android-Tips/issues" target="_blank" rel="external">Commit</a> 或者 <a href="https://github.com/tangqi92/Android-Tips/pulls" target="_blank" rel="external">Pull requests</a> 的形式，当然也欢迎 <code>Star</code> 与 <code>Fork</code> :)</p>
<blockquote>
<p>由于本项目面向的群体为初学者，所以列表的知识点以初级为主，资源大多数为中文，如遇到少数无法访问的情况，请自备梯子。</p>
</blockquote>
<hr>
<h2 id="地址">地址</h2><p>项目地址：<a href="https://github.com/tangqi92/Android-Tips" target="_blank" rel="external">https://github.com/tangqi92/Android-Tips</a></p>
<hr>
<h2 id="期待与你成为朋友">期待与你成为朋友</h2><ul>
<li>Weibo: <a href="http://weibo.com/qiktang" target="_blank" rel="external">汤奇V</a>  </li>
<li>GitHub: <a href="https://github.com/tangqi92" target="_blank" rel="external">tangqi92</a></li>
<li>Blog: <a href="http://itangqi.me/">http://itangqi.me</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="介绍">介绍</h2><p>学习 Android 至今，大大小小的坑没少踩，庆幸的是，在强大的搜索引擎与无私奉献的人们的帮助下，我遇到的坑都顺利地被填平了。</p>
<p>为了便于日后遇到同样的问题时，能免于再次搜索带来的麻烦，我养成了收藏书签的习惯，随着书签（Tips）的日积月累，我想，是时候该有这个项目了。</p>]]>
    
    </summary>
    
      <category term="List" scheme="http://itangqi.me/tags/List/"/>
    
      <category term="Tips" scheme="http://itangqi.me/tags/Tips/"/>
    
      <category term="Android" scheme="http://itangqi.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[积木 - 享受搭建应用的乐趣]]></title>
    <link href="http://itangqi.me/2015/09/03/building-blocks/"/>
    <id>http://itangqi.me/2015/09/03/building-blocks/</id>
    <published>2015-09-02T16:00:00.000Z</published>
    <updated>2016-02-25T05:44:19.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><strong>积木</strong> - 一个以知乎日报作为数据展现内容；以抽屉菜单作为功能扩展入口；依循 Material Design 作为主导设计 UI 的应用；好吧，我承认这听上去就很酷！</p>
</blockquote>
<a id="more"></a> 
<hr>
<h2 id="How_to_use">How to use</h2><blockquote>
<p>dev 分支由 <a href="https://github.com/troyliu0105" target="_blank" rel="external">troyliu0105</a> 同学全力维护，他会不断对<strong>积木</strong>进行重构与增加好玩的功能，这非常酷，欢迎 <strong>Star</strong> 与 <strong>Fork</strong> 此分支！</p>
</blockquote>
<p>那么，你该如何利用「她」呢？</p>
<p>好啦，其实我已经帮你完成了应用整体框架的搭建，你需要做的，仅仅是依据自己的实际需求，简单的替换下数据来源，比如在 <a href="http://apistore.baidu.com/" target="_blank" rel="external">APIStore</a> 上就有详细的类别供你选择，然后再改改 UI，一款全新应用就完成啦！</p>
<p>想想，是不是还有点小激动？那么赶紧 <strong>Star</strong> 与 <strong>Fork</strong> 吧！你的支持将成为我最大的动力与褒奖！</p>
<hr>
<h2 id="Update_Log_-_更新日志">Update Log - 更新日志</h2><h3 id="0-7-0">0.7.0</h3><ul>
<li>新增 - 夜间模式</li>
<li>新增 - 程序崩溃日志收集</li>
<li>新增 - 自动更新</li>
<li>新增 - <code>html+</code>模式（其实就是修改了html标签==）</li>
<li>修复 - 自动清理功能的错误</li>
<li>修复 - 主界面刷新闪烁BUG</li>
<li>修改 - 部分UI</li>
</ul>
<h5 id="已知BUG">已知BUG</h5><ul>
<li>部分文章显示有问题(使用<code>html+</code>模式无影响)</li>
</ul>
<h3 id="v0-6-0">v0.6.0</h3><ul>
<li>新增 - FAB刷新</li>
<li>新增 - html模式下的页面缓存</li>
<li>新增 - json模式(速度更快，但部分文章显示有问题)</li>
<li>新增 - 自动清理过期缓存</li>
<li>新增 - SQLite数据储存</li>
<li>重构 - 使用MVP进行重构</li>
<li>新增 - 由<a href="http://weibo.com/cat93/" target="_blank" rel="external">Mao</a>提供的Logo</li>
<li>修改 - 部分的UI</li>
</ul>
<h3 id="v0-5-1">v0.5.1</h3><ul>
<li>修复 - 手势右划返回上级页面在4.4系统上的 Bug</li>
<li>优化 - 首页 Item 的展示布局</li>
</ul>
<h3 id="v0-5-0">v0.5.0</h3><ul>
<li>抛弃 - CardView，回归朴实并为 RecycerView 中 item 增加分割线</li>
<li>抛弃 - 第三方 DrawerLayout，华而不实</li>
<li>抛弃 - WebView 中显示文章标题，取而代之为分享按钮</li>
<li>新增 - 搜索功能，跳转页面显示结果</li>
<li>新增 - 手势右滑，返回上级页面功能</li>
<li>优化 - 将功能扩展作为抽屉菜单的子选项</li>
<li>重构 - 尽可能将代码写得优雅和规整</li>
</ul>
<hr>
<h2 id="Screenshots_-_预览">Screenshots - 预览</h2><p><strong>这里并不是最新效果预览，请前往 <a href="https://github.com/tangqi92/BuildingBlocks/blob/master/README.z.md" target="_blank" rel="external">GitHub</a> 查看</strong></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/bb_s1.png" alt="screenshot" title="screenshot" width="270" height="486">  <img src="http://7xikfc.com1.z0.glb.clouddn.com/bb_s2.png" alt="screenshot" title="screenshot" width="270" height="486"></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/bb_s3.png" alt="screenshot" title="screenshot" width="270" height="486">  <img src="http://7xikfc.com1.z0.glb.clouddn.com/bb_s4.png" alt="screenshot" title="screenshot" width="270" height="486"></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/bb_s5.png" alt="screenshot" title="screenshot" width="270" height="486">  <img src="http://7xikfc.com1.z0.glb.clouddn.com/bb_s6.png" alt="screenshot" title="screenshot" width="270" height="486"></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/bb_s7.png" alt="screenshot" title="screenshot" width="270" height="486">  <img src="http://7xikfc.com1.z0.glb.clouddn.com/bb_s8.png" alt="screenshot" title="screenshot" width="270" height="486"></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/bb_s9.png" alt="screenshot" title="screenshot" width="270" height="486"></p>
<hr>
<h2 id="Dependencies_-_开源项目">Dependencies - 开源项目</h2><ul>
<li><a href="https://github.com/bumptech/glide" target="_blank" rel="external">glide</a></li>
<li><a href="https://github.com/orhanobut/logger" target="_blank" rel="external">logger</a></li>
<li><a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">butterknife</a></li>
<li><a href="https://github.com/jdamcd/android-crop" target="_blank" rel="external">android-crop</a></li>
<li><a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">android-async-http</a></li>
<li><a href="https://github.com/ikew0ng/SwipeBackLayout" target="_blank" rel="external">SwipeBackLayout</a></li>
</ul>
<hr>
<h2 id="Thanks_-_感谢你们">Thanks - 感谢你们</h2><ul>
<li><p>感谢 <a href="https://github.com/drakeet" target="_blank" rel="external">drakeet</a> 及他的 <a href="https://github.com/drakeet/Meizhi" target="_blank" rel="external">妹纸&amp;gank.io</a>， 其代码写得真的非常漂亮：)，从中学到了很多并运用到了项目中（依葫芦画瓢而已啦）</p>
</li>
<li><p>感谢 <a href="https://github.com/izzyleung" target="_blank" rel="external">Izzy Leung</a> 及他的 <a href="https://github.com/izzyleung/ZhihuDailyPurify" target="_blank" rel="external">知乎日报·净化</a>，项目最初的原型就来自于此，感谢其提供了详细的知乎日报 API 说明</p>
</li>
</ul>
<hr>
<h2 id="Contributors_-_贡献者">Contributors - 贡献者</h2><ul>
<li>dev version: <a href="https://github.com/troyliu0105" target="_blank" rel="external">troyliu0105</a></li>
<li>Logo: <a href="http://weibo.com/cat93/" target="_blank" rel="external">Mao</a> &amp; <a href="https://github.com/troyliu0105" target="_blank" rel="external">troyliu0105</a></li>
</ul>
<hr>
<h2 id="Demo_-_示例">Demo - 示例</h2><p><a href="http://7xk54v.com1.z0.glb.clouddn.com/app/bb/0.7.0.apk" target="_blank" rel="external">快速下载</a></p>
<hr>
<h2 id="Source_code_-_源码">Source code - 源码</h2><p>源代码：<a href="https://github.com/tangqi92/BuildingBlocks" target="_blank" rel="external">https://github.com/tangqi92/BuildingBlocks</a></p>
<hr>
<h2 id="Contact_-_联系我">Contact - 联系我</h2><ul>
<li>Weibo：<a href="http://weibo.com/qiktang" target="_blank" rel="external">汤奇V</a></li>
<li>Blog: <a href="http://itangqi.me">http://itangqi.me</a></li>
<li>Gmail：<a href="mailto:imtangqi@gmail.com" title="欢迎与我联系" target="_blank" rel="external">imtangqi#gmail.com</a></li>
</ul>
<hr>
<p>最后更新时间：2015-10-07 19:47</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><strong>积木</strong> - 一个以知乎日报作为数据展现内容；以抽屉菜单作为功能扩展入口；依循 Material Design 作为主导设计 UI 的应用；好吧，我承认这听上去就很酷！</p>
</blockquote>]]>
    
    </summary>
    
      <category term="AOSP" scheme="http://itangqi.me/tags/AOSP/"/>
    
      <category term="Framework" scheme="http://itangqi.me/tags/Framework/"/>
    
      <category term="Android" scheme="http://itangqi.me/categories/Android/"/>
    
  </entry>
  
</feed>
