<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Qi Tang's Blog]]></title>
  <subtitle><![CDATA[你不能把这个世界，让给你所鄙视的人]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://itangqi.me/"/>
  <updated>2016-04-21T05:06:55.000Z</updated>
  <id>http://itangqi.me/</id>
  
  <author>
    <name><![CDATA[Qi Tang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[UICollectionView 学习笔记]]></title>
    <link href="http://itangqi.me/2016/04/21/the-notes-of-learning-uicollectionview/"/>
    <id>http://itangqi.me/2016/04/21/the-notes-of-learning-uicollectionview/</id>
    <published>2016-04-20T16:00:00.000Z</published>
    <updated>2016-04-21T05:06:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近计划着开个新项目，前期工作准备先撸个图片选择器出来。当然核心肯定是 PhotoKit (ASsetsLibrary) 啦，不过那些会在稍后文章中介绍，今天的主角则是 <strong>UICollectionView</strong>。</p>
<a id="more"></a> 
<hr>
<h2 id="简介">简介</h2><p>首先看苹果官方文档 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionView_class/" target="_blank" rel="external">UICollectionView Class Reference</a> 的介绍:</p>
<blockquote>
<p>The UICollectionView class manages an ordered collection of data items and presents them using customizable layouts. Collection views provide the same general function as table views except that a collection view is able to support more than just single-column layouts. Collection views support customizable layouts that can be used to implement multi-column grids, tiled layouts, circular layouts, and many more. You can even change the layout of a collection view dynamically if you want.</p>
</blockquote>
<p>一句话总结就是：<strong>UICollectionView 与 UITableView 相似，却提供了可自定义多列网格（Grild）的功能。</strong></p>
<hr>
<h2 id="核心">核心</h2><ul>
<li><p><strong>Cells</strong>：单元格，用于展示内容的主体</p>
</li>
<li><p><strong>Supplementary Views</strong>：追加视图，相当于 UITableView 中每个 Section 的 Header 或 Footer</p>
</li>
<li><p><strong>Decoration Views</strong>：装饰视图，用于装饰整个 UICollectionView</p>
</li>
</ul>
<p>UICollectionView 最常见的使用场景，想必就是相册（照片墙）的实现与展示了，下面通过一张图来直观地认识 CollectionView 各部分的构成：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-001.png" alt=""></p>
<hr>
<h2 id="实现">实现</h2><p>如果你在之前有了解及使用过 UITableView 的话，那么恭喜你，你将会快速上手 UICollectionView。</p>
<h3 id="UICollectionViewDataSource">UICollectionViewDataSource</h3><p>UICollectionViewDataSource - 负责提供展示的数据，实现下面两个必须的委托方法，其实 UITableView 并无二意，所以在此不做过多介绍了。</p>
<ul>
<li><p><strong>numberOfItemsInSection</strong>：某个 section 里有多少个 item</p>
</li>
<li><p><strong>cellForItemAtIndexPath</strong>：对于某个位置应该显示什么样的 cell，里面会涉及到 cell 的复用，可参见 TableView</p>
</li>
</ul>
<p>其实到这里，CollectionView 就可以正常显示了，对吧，就是这么简单：）</p>
<h3 id="UICollectionViewDelegate">UICollectionViewDelegate</h3><p>UICollectionViewDelegate - 负责用户的交互、Cell 的外形，委托方法和 TableView 相似，可以选择性实现以下委托方法。</p>
<ul>
<li><p><strong>collectionView:shouldHighlightItemAtIndexPath</strong>：是否支持高亮？</p>
</li>
<li><p><strong>collectionView:didHighlightItemAtIndexPath</strong>：如果支持高亮，那么高亮；</p>
</li>
<li><p><strong>collectionView:shouldSelectItemAtIndexPath</strong>：询问是否可以被选中？</p>
</li>
<li><p><strong>collectionView:didUnhighlightItemAtIndexPath</strong>：如果支持高亮，那么现在取消高亮；</p>
</li>
<li><p><strong>collectionView:didSelectItemAtIndexPath</strong>：如果支持可以被选中，那么选中 cell；</p>
</li>
</ul>
<p>下面再通过几张图来更加清晰地理解：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-002.jpg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-003.jpg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-004.jpg" alt=""></p>
<h3 id="UICollectionViewLayout">UICollectionViewLayout</h3><p>在布局上，与 UITableView 直接使用系统提供的样式不同，UICollectionView 使用的是 UICollectionViewLayout 来自定义布局样式。</p>
<p>在苹果官方文档：<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/" target="_blank" rel="external">UICollectionViewLayout Class Reference</a> 中对其做了如下解释:</p>
<blockquote>
<p>The UICollectionViewLayout class is an abstract base class that you subclass and use to generate layout information for a collection view. The job of a layout object is to determine the placement of cells, supplementary views, and decoration views inside the collection view’s bounds and to report that information to the collection view when asked. The collection view then applies the provided layout information to the corresponding views so that they can be presented onscreen.</p>
</blockquote>
<p>这里做下简短的总结：</p>
<ol>
<li><p>UICollectionViewLayout 是一个抽象基类，你需要继承自他，来为 CollectionView 生成 Layout 信息。Layout 对象的作用是决定 Cells，Supplementary Views 和 Decoration Views 在 CollectionView 中的布局位置。当然啦，如果你不想折腾，苹果也贴心的为你准备了 UICollectionViewFlowLayout - 流水式布局效果。</p>
</li>
<li><p>UICollectionView 的显示效果几乎全部由 UICollectionViewLayout 负责，而真正存储着每一个 Cell 的位置、大小等属性的是 UICollectionViewLayoutAttributes 。每一个 Cell 对应着一个属于自己的 UICollectionViewLayoutAttributes，而 UICollectionViewLayout 正是利用 UICollectionViewLayoutAttributes 里存在的信息对每一个 Cell 进行布局。</p>
</li>
</ol>
<p>下面通过一张图来了解 UICollectionView 的构成：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-005.jpg" alt=""></p>
<h2 id="总结">总结</h2><p>可以说 UICollectionView 是 iOS 开发中必不可少的 UIKit 控件之一。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionView_class/" target="_blank" rel="external">UICollectionView Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/" target="_blank" rel="external">UICollectionViewLayout Class Reference</a></li>
<li><a href="http://www.appcoda.com/ios-programming-uicollectionview-tutorial/" target="_blank" rel="external">Create Grid Layout Using UICollectionView in iOS 6</a></li>
<li><a href="http://my.oschina.net/sunqichao/blog/182623" target="_blank" rel="external">UICollectionView 使用 介绍</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>最近计划着开个新项目，前期工作准备先撸个图片选择器出来。当然核心肯定是 PhotoKit (ASsetsLibrary) 啦，不过那些会在稍后文章中介绍，今天的主角则是 <strong>UICollectionView</strong>。</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 中的 Autorelease Pool]]></title>
    <link href="http://itangqi.me/2016/04/15/autorelease-pool-in-ios/"/>
    <id>http://itangqi.me/2016/04/15/autorelease-pool-in-ios/</id>
    <published>2016-04-14T16:00:00.000Z</published>
    <updated>2016-04-24T06:22:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Objective-C 对象的生命周期取决于其引用计数。在 Objective-C 的引用计数架构中，有一项特性叫做 Autorelease Pool（自动释放池）。释放对象有两种方式：</p>
<ol>
<li>调用 <code>release</code> 方法，使其保留计数立即减 1 </li>
<li>调用 <code>autorelease</code> 方法，将其加入 Autorelease Pool 中</li>
</ol>
<p>Autorelease Pool 用于存放那些需要在稍后某个时刻释放的对象。当 Pool drain（清空）时，系统会向其中的对象发送 <code>release</code> 消息。</p>
<a id="more"></a>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/autorelease-pool-in-ios-01.jpg" alt=""></p>
<hr>
<h2 id="详解">详解</h2><p>创建 Autorelease Pool 所使用语法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">true<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在没有创建 Autorelease Pool 的情况下给对象发送 <code>autorelease</code> 消息，那么控制台会输出这样一条信息：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__<span class="built_in">NSAutoreleaseNoPool</span>(): Object <span class="number">0x350270</span> of class <span class="built_in">NSCFString</span> autoreleased with no pool <span class="keyword">in</span> place - just leaking - <span class="keyword">break</span> on objc_ autoreleaseNoPool() to debug</span><br></pre></td></tr></table></figure>
<p>而然，一般情况下无须担心 Autorelease Pool 的创建问题。Mac OS X  与 iOS 应用程序分别运行于 Cocoa 及 Cocoa Touch 环境中。系统会自动创建一些线程，比如主线程或者是 GCD 机制中的线程，这些线程默认都有 Autorelease Pool，每次执行 Event Loop（事件循环）时，就会将其清空。因此，不需要自己来创建。</p>
<p>通常只有一个地方需要创建 Autorelease Pool，那就是在 <code>main</code> 函数里，我们用 Autorelease Pool  来包裹应用程序的入口点。比如说，iOS 程序的 <code>main</code> 函数经常这样写：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">true<span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">true    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实从技术角度看，不是非得有个 <code>@autoreleasepool {}</code> 才行。因为块的末尾恰好就是应用程序的终止处，而此时操作系统会把程序所占的全部内存都释放掉。虽说如此，但是如果不写这个块的话，那么由 <code>UIApplicationMain</code> 函数所自动释放的那些对象，就没有 Autorelease Pool 可以容纳了，于是系统会发出警告信息来表明这一情况。所以说，这个池可以理解成最外围捕捉全部自动释放对象所用的池。</p>
<hr>
<h2 id="示例">示例</h2><p>下面这段代码中的花括号定义了 Autorelease Pool 的范围。Autorelease Pool 于 <code>{</code>（左花括号）处创建，并于对应的 <code>}</code>（右花括号）处自动清空。位于 Autorelease Pool 范围内的对象，将在此范围末尾处收到 <code>release</code> 消息。Autorelease Pool 可以嵌套。系统在自动释放对象时，会把它放到最内层的池里。比如说：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"1 = %i"</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSNumber</span> *number = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中有两个对象，它们都由类的工厂方法所创建，这样创建出来的对象会自动释放。<code>NSString</code> 对象放在外围的 Autorelease Pool 中，而 <code>NSNumber</code> 对象则放在里层的 Autorelease Pool 中。将 Autorelease Pool 嵌套使用的好处是，可以借此控制应用程序的<strong>内存峰值（high-memory waterline）</strong>，使其不致过高。</p>
<p>考虑下面这段代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    [<span class="keyword">self</span> doSomethingWithInt:i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>doSomethingWithInt:</code> 方法要创建临时对象，那么这些对象很可能会放在 Autorelease Pool 里。比方说，它们可能是一些临时字符串。但是，即便这些对象在调用完方法之后就不再使用了，它们也依然处于]存活状态，因为目前还在 Autorelease Pool 里，等待系统稍后将其释放并回收。然而，<strong>Autorelease Pool 要等到线程执行下一个事件循环时才会清空。</strong>这就意味着在执行 for 循环时，会持续有新的对象创建出来，并加入 Autorelease Pool 中。所有这种对象都要等 for 循环执行完才会释放。这样一来，在执行 for 循环时，应用程序所占内存量就会持续上涨，而等到所有临时对象都释放之后，内存量又会突然下降。</p>
<hr>
<h2 id="实现原理">实现原理</h2><h3 id="AutoreleasePoolPage">AutoreleasePoolPage</h3><p>ARC 下，我们使用 <code>@autoreleasepool {}</code> 来使用一个 Autorelease Pool，随后编译器将其改写成下面的样子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *context = objc_autoreleasePoolPush();</span><br><span class="line"><span class="comment">// &#123;&#125;中的代码</span></span><br><span class="line">objc_autoreleasePoolPop(context);</span><br></pre></td></tr></table></figure>
<p>而这两个函数都是对 <code>AutoreleasePoolPage</code> 的简单封装，所以自动释放机制的核心就在于这个类。</p>
<p><code>AutoreleasePoolPage</code> 是一个 C++ 实现的类：</p>
<ol>
<li>Autorelease Pool 并没有单独的结构，而是由若干个 <code>AutoreleasePoolPage</code> 以<strong>双向链表</strong>的形式组合而成（分别对应结构中的 parent 指针和 child 指针）</li>
<li>Autorelease Pool 是按线程一一对应的（结构中的 thread 指针指向当前线程）</li>
<li><code>AutoreleasePoolPage</code> 每个对象会开辟 4096 字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存 autorelease 对象的地址</li>
<li>上面的 id *next 指针作为游标指向栈顶最新 add 进来的 autorelease 对象的下一个位置</li>
<li>一个 <code>AutoreleasePoolPage</code> 的空间被占满时，会新建一个 <code>AutoreleasePoolPage</code> 对象，连接链表，后来的 autorelease 对象在新的 Page 加入</li>
</ol>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/autorelease-pool-in-ios-02.jpg" alt=""></p>
<ul>
<li><code>magic</code> 用来校验 <code>AutoreleasePoolPage</code> 的结构是否完整</li>
<li><code>next</code> 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 begin() </li>
<li><code>thread</code> 指向当前线程</li>
<li><code>parent</code> 指向父结点，第一个结点的 parent 值为 nil </li>
<li><code>child</code> 指向子结点，最后一个结点的 child 值为 nil </li>
<li><code>depth</code> 代表深度，从 0 开始，往后递增 1</li>
<li><code>hiwat</code> 代表 high water mark </li>
</ul>
<p>另外，当 next == begin() 时，表示 <code>AutoreleasePoolPage</code> 为空；当 next == end() 时，表示 <code>AutoreleasePoolPage</code> 已满。</p>
<p>所以，若当前线程中只有一个 <code>AutoreleasePoolPage</code> 对象，并记录了很多 autorelease 对象地址时内存如下图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/autorelease-pool-in-ios-03.jpg" alt=""></p>
<p>图中的情况，这一页再加入一个 autorelease 对象就要满了（也就是 next 指针马上指向栈顶），这时就要执行上面说的操作，建立下一页 Page 对象，与这一页链表连接完成后，新 Page 的 next 指针被初始化在栈底（ begin 的位置），然后继续向栈顶添加新对象。</p>
<p>所以，向一个对象发送 <code>autorelease</code> 消息，就是将这个对象加入到当前 <code>AutoreleasePoolPage</code> 的栈顶 next 指针指向的位置</p>
<h3 id="释放时机">释放时机</h3><p>每当进行一次 <code>objc_autoreleasePoolPush</code> 调用时，Runtime 向当前的 <code>AutoreleasePoolPage</code>中 add 进一个<strong>哨兵对象（POOL_SENTINEL）</strong>，值为 0（也就是个 nil），那么这一个 page 就变成了下面的样子：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/autorelease-pool-in-ios-04.jpg" alt=""></p>
<p><code>objc_autoreleasePoolPush</code> 的返回值正是这个哨兵对象的地址，被 <code>objc_autoreleasePoolPop</code>（哨兵对象）作为入参，于是：</p>
<ol>
<li>根据传入的哨兵对象地址找到哨兵对象所处的 Page</li>
<li>在当前 Page 中，将晚于哨兵对象插入的所有 autorelease 对象都发送一次 <code>release</code> 消息，并向回移动next指针到正确位置</li>
<li>补充 2：从最新加入的对象一直向前清理，可以向前跨越若干个 Page，直到哨兵所在的 Page</li>
</ol>
<p>刚才的 <code>objc_autoreleasePoolPop</code> 执行后，最终变成了下面的样子：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/autorelease-pool-in-ios-05.jpg" alt=""></p>
<hr>
<h2 id="@autoreleasepool_{}">@autoreleasepool {}</h2><p>我们使用 <code>clang -rewrite-objc</code> 命令将下面的 Objective-C 代码重写成 C++ 代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将会得到以下输出结果（只保留了相关代码）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="keyword">void</span> * objc_autoreleasePoolPush(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="keyword">void</span> objc_autoreleasePoolPop(<span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>苹果通过声明一个 <code>__AtAutoreleasePool</code> 类型的局部变量 <code>__autoreleasepool</code> 来实现 <code>@autoreleasepool {}</code>。当声明 <code>__autoreleasepool</code> 变量时，构造函数 <code>__AtAutoreleasePool()</code> 被调用，即执行 <code>atautoreleasepoolobj = objc_autoreleasePoolPush();</code>；当出了当前作用域时，析构函数 <code>~__AtAutoreleasePool()</code> 被调用，即执行 <code>objc_autoreleasePoolPop(atautoreleasepoolobj);</code>。也就是说 <code>@autoreleasepool {}</code> 的实现代码可以进一步简化如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">    <span class="comment">// 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 Autorelease Pool 中</span></span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，单个 Autorelease Pool 的运行过程可以简单地理解为 <code>objc_autoreleasePoolPush()</code>、<code>[obj autorelease]</code> 和 <code>objc_autoreleasePoolPop(void *)</code> 三个过程。</p>
<h3 id="push_操作">push 操作</h3><p>上面提到的 <code>objc_autoreleasePoolPush()</code> 函数本质上就是调用的 <code>AutoreleasePoolPage</code> 的 <code>push</code> 函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">objc_autoreleasePoolPush(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们接下来看看 <code>AutoreleasePoolPage</code> 的 <code>push</code> 函数的作用和执行过程。一个 <code>push</code> 操作其实就是创建一个新的 Autorelease Pool，对应 <code>AutoreleasePoolPage</code> 的具体实现就是往 <code>AutoreleasePoolPage</code> 中的 <code>next</code> 位置插入一个 <strong>POOL_SENTINEL</strong>（哨兵对象），并且返回插入的 <code>POOL_SENTINEL</code> 的内存地址。这个地址也就是我们前面提到的 pool token ，在执行 <code>pop</code> 操作的时候作为函数的入参：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> *dest = autoreleaseFast(POOL_SENTINEL);</span><br><span class="line">    assert(*dest == POOL_SENTINEL);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>push</code> 函数通过调用 <code>autoreleaseFast</code> 函数来执行具体的插入操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> *autoreleaseFast(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>autoreleaseFast</code> 函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p>
<ol>
<li>当前 Page 存在且没有满时，直接将对象添加到当前 Page 中，即 next 指向的位置</li>
<li>当前 Page 存在且已满时，创建一个新的 Page ，并将对象添加到新创建的 Page 中</li>
<li>当前 Page 不存在时，即还没有 Page 时，创建第一个 Page ，并将对象添加到新创建的 Page 中</li>
</ol>
<p>每调用一次 <code>push</code> 操作就会创建一个新的 Autorelease Pool，即往 <code>AutoreleasePoolPage</code> 中插入一个 <code>POOL_SENTINEL</code>，并且返回插入的 <code>POOL_SENTINEL</code> 的内存地址。</p>
<h3 id="autorelease_操作">autorelease 操作</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)autorelease &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootAutorelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过查看 <code>((id)self)-&gt;rootAutorelease()</code> 的方法调用，我们发现最终调用的就是  <code>AutoreleasePoolPage</code> 的 <code>autorelease</code> 函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline,used))</span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AutoreleasePoolPage</code> 的 <code>autorelease</code> 函数的实现对我们来说就比较容量理解了，它跟 <code>push</code> 操作的实现非常相似。只不过 <code>push</code> 操作插入的是一个 <code>POOL_SENTINEL</code>，而 <code>autorelease</code> 操作插入的是一个具体的 autoreleased 对象：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line">    assert(!obj-&gt;isTaggedPointer());</span><br><span class="line">    <span class="keyword">id</span> *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    assert(!dest  ||  *dest == obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pop_操作">pop 操作</h3><p>同理，前面提到的 <code>objc_autoreleasePoolPop(void *)</code> 函数本质上也是调用的  <code>AutoreleasePoolPage</code> 的 <code>pop</code> 函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rdar://9167170</span></span><br><span class="line">    <span class="keyword">if</span> (!ctxt) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pop</code> 函数的入参就是 <code>push</code> 函数的返回值，也就是 <code>POOL_SENTINEL</code> 的内存地址，即 pool token。当执行 <code>pop</code> 操作时，内存地址在 pool token 之后的所有 autoreleased 对象都会被 release。直到 pool token 所在 Page 的 next 指向 pool token 为止。</p>
<p>下面是某个线程的 Autorelease Pool 堆栈的内存结构图，在这个 Autorelease Pool 堆栈中总共有两个 <code>POOL_SENTINEL</code>，即有两个 Autorelease Pool。该堆栈由三个 <code>AutoreleasePoolPage</code> 结点组成，第一个 <code>AutoreleasePoolPage</code> 结点为 <code>coldPage()</code>，最后一个 <code>AutoreleasePoolPage</code> 结点为 <code>hotPage()</code>。其中，前两个结点已经满了，最后一个结点中保存了最新添加的 autoreleased 对象 <code>objr3</code> 的内存地址：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/autorelease-pool-in-ios-06.png" alt=""></p>
<p>此时，如果执行 <code>pop(token1)</code> 操作，那么该 Autorelease Pool 堆栈的内存结构将会变成如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/autorelease-pool-in-ios-07.png" alt=""></p>
<hr>
<h2 id="总结">总结</h2><p>这种情况不甚理想，尤其当循环长度无法预知的情况下更是如此。比方说，要从数据库中读出许多对象。代码可能会这么写：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *databaseRecords = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *people = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *record <span class="keyword">in</span> databaseRecords) &#123;</span><br><span class="line">    EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</span><br><span class="line">    [people addObject:person];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EOCPerson</code> 的初始化函数也许会像上列那样，再创建出一些临时对象。若记录有很多条，则内存中也会有很多不必要的临时对象，它们本来应该提早回收的。增加一个 Autorelease Pool 即可解决此问题。如果把循环内的代码包裹在 <code>@autoreleasepool {}</code> 中，那么在循环中自动释放的对象就会放在这个 Pool，而不是线程的主池里面。例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *databaseRecords = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *people = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *record <span class="keyword">in</span> databaseRecords) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</span><br><span class="line">        [people addObject:person]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上这个 Autorelease Pool 之后，应用程序在执行循环时的内存峰值就会降低，不再像原来那么高了。内存峰值（high-memory waterline）是指应用程序在某个特定时间段内的最大内存用量（highest memory footprint）。新增的 <code>@autoreleasepool {}</code> 可以减少这个峰值，因为系统会在块的末尾把某些对象回收掉。而刚才提到的那种临时对象，就在回收之列。</p>
<p>是否应该用池来优化效率，完全取决于具体的应用程序。首先得监控内存用量，判断其中有没有需要解决的问题，如果没有完成这一步，那就别急着优化。尽管 <code>@autoreleasepool {}</code> 的开销不太大，但毕竟还是有的，所以尽量不要建立额外的 Autorelease Pool。</p>
<h3 id="MRC_vs-_ARC">MRC vs. ARC</h3><p>如果在 ARC 出现之前就写过 Objective-C 程序，那么可能还记得有种老式写法，就是使用 <code>NSAutoreleasePool</code> 对象。这个特殊的对象与普通对象不同，它专门用来表示 Autorelease Pool，就像新语法中的 <code>@autoreleasepool {}</code> 一样。但是这种写法并不会在每次执行 for 循环时都清空池，此对象更为重量级，通常用来创建那种偶尔需要清空的池，比方说：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *databaseRecords = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *people = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *record <span class="keyword">in</span> databaseRecords) &#123;</span><br><span class="line">    EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</span><br><span class="line">    [people addObject:person];</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Drain the pool only every 10 cycles</span></span><br><span class="line">    <span class="keyword">if</span> (++i == <span class="number">10</span>) &#123;</span><br><span class="line">        [pool drain];</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Also drain at the end in case the loop is not a multiple of 10</span></span><br><span class="line">[pool drain];</span><br></pre></td></tr></table></figure>
<p>现在不需要再这样写代码了。采用随着 ARC 所引入的新语法，可以创建出更为轻量级的 Autorelease Pool。原来所写的代码可能会每执行 n 次循环清空一次 Autorelease Pool，现在可以改用 <code>@autoreleasepool {}</code> 把 for 循环中的语句包起来，这样的话，每次执行循环时都会建立并清空 Autorelease Pool。</p>
<p><code>@autoreleasepool {}</code> 语法还有个好处：每个 Autorelease Pool 均有其范围，可以避免无意间误用了那些在清空池后已为系统所回收的对象。比方说，考虑下面这段采用旧式写法的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="keyword">id</span> object = [<span class="keyword">self</span> createObject];</span><br><span class="line">[pool drain];</span><br><span class="line">[<span class="keyword">self</span> useObject:object];</span><br></pre></td></tr></table></figure>
<p>这样写虽然稍显夸张，但却能说明问题。调用 <code>useObject:</code> 方法时所传入的那个对象，可能已经为系统所回收了。同样的代码改用新式写法就变成了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="keyword">id</span> object = [<span class="keyword">self</span> createObject];</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span> useObject:object];</span><br></pre></td></tr></table></figure>
<p>这次根本就无法编译，因为 object 变量出了 Autorelease Pool 的外围后就不可用了，所以在调用 <code>useObject:</code> 方法时不能用它做参数。</p>
<h3 id="NSThread、NSRunLoop_和_NSAutoreleasePool">NSThread、NSRunLoop 和 NSAutoreleasePool</h3><p>根据苹果官方文档中对 <code>NSRunLoop</code> 的描述，我们可以知道每一个线程，包括主线程，都会拥有一个专属的 <code>NSRunLoop</code> 对象，并且会在有需要的时候自动创建。</p>
<p>在主线程的 <code>NSRunLoop</code> 对象（在系统级别的其他线程中应该也是如此，比如通过 <code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code> 获取到的线程）的每个（事件循环）Event Loop 开始前，系统会自动创建一个 Autorelease Pool ，并在 Event Loop 结束时 drain 。</p>
<p>另外，<code>NSAutoreleasePool</code> 中还提到，每一个线程都会维护自己的 Autorelease Pool 堆栈。换句话说 Autorelease Pool 是与线程紧密相关的，每一个 Autorelease Pool 只对应一个线程。</p>
<p>弄清楚 <code>NSThread</code>、<code>NSRunLoop</code> 和 <code>NSAutoreleasePool</code> 三者之间的关系可以帮助我们从整体上了解 Objective-C 的内存管理机制</p>
<h3 id="使用场景">使用场景</h3><ol>
<li>你编写是命令行工具的代码，而不是基于 UI 框架的代码</li>
<li>你需要写一个循环，里面会创建很多临时的对象<ul>
<li>这时候你可以在循环内部的代码块里使用一个 <code>@autoreleasepool {}</code>，这样这些对象就能在一次迭代完成后被释放掉。这种方式可以降低内存最大占用</li>
</ul>
</li>
<li>当你大量使用辅助线程<ul>
<li>你需要在线程的任务代码中创建自己的 <code>@autoreleasepool {}</code></li>
</ul>
</li>
</ol>
<hr>
<h2 id="要点">要点</h2><ol>
<li>Autorelease Pool 排布在栈中，对象收到 <code>autorelease</code> 消息后，系统将其放入最顶端的池里。</li>
<li>合理运用 Autorelease Pool，可降低应用程序的内存峰值。</li>
<li><code>@autoreleasepool {}</code> 这种新式写法能创建出更为轻便的 Autorelease Pool。</li>
</ol>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://book.douban.com/subject/25829244/" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI" target="_blank" rel="external">Using Autorelease Pool Blocks</a></li>
<li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a></li>
<li><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">Objective-C Autorelease Pool 的实现原理</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>Objective-C 对象的生命周期取决于其引用计数。在 Objective-C 的引用计数架构中，有一项特性叫做 Autorelease Pool（自动释放池）。释放对象有两种方式：</p>
<ol>
<li>调用 <code>release</code> 方法，使其保留计数立即减 1 </li>
<li>调用 <code>autorelease</code> 方法，将其加入 Autorelease Pool 中</li>
</ol>
<p>Autorelease Pool 用于存放那些需要在稍后某个时刻释放的对象。当 Pool drain（清空）时，系统会向其中的对象发送 <code>release</code> 消息。</p>]]>
    
    </summary>
    
      <category term="Autorelease Pool" scheme="http://itangqi.me/tags/Autorelease-Pool/"/>
    
      <category term="Memory Management" scheme="http://itangqi.me/tags/Memory-Management/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初识 Run Loop]]></title>
    <link href="http://itangqi.me/2016/04/14/the-first-meet-with-runloop/"/>
    <id>http://itangqi.me/2016/04/14/the-first-meet-with-runloop/</id>
    <published>2016-04-13T16:00:00.000Z</published>
    <updated>2016-04-23T05:46:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在学习完内存管理与多线程的知识后，我又将目光瞄向了 <strong>Run Loop</strong>，不过受限于现阶段的能力，我在查阅了大量资料后，对于 Run Loop 的理解仍然非常浅显，所以本文绝大多数的内容，是参照网上大牛们的文章进行总结的。当然啦，我也希望在不久的将来，对于 Run Loop 能有更多自己的观点与总结。</p>
<a id="more"></a>
<hr>
<h2 id="什么是_Run_Loop">什么是 Run Loop</h2><p>首先看以下代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知道刚接触 iOS 开发的同学有没有过这样的疑惑：我们都知道 <code>main</code> 函数是程序的入口，可为何当 <code>main</code> 函数执行完毕后，程序没有退出呢？而能在没有事情做的时候维持应用的运行的呢？</p>
<p>如果你是个好奇的宝宝，那么一定会去搜寻答案，没错，其实这背后便隐藏了今天的主角 Run Loop。</p>
<p>以下来自苹果<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="external">官方文档</a>的介绍：</p>
<blockquote>
<p>Run loops are part of the fundamental infrastructure associated with threads. A run loop is an event processing loop that you use to schedule work and coordinate the receipt of incoming events. The purpose of a run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none.</p>
<p>Run loop management is not entirely automatic. You must still design your thread’s code to start the run loop at appropriate times and respond to incoming events. Both Cocoa and Core Foundation provide run loop objects to help you configure and manage your thread’s run loop. Your application does not need to create these objects explicitly; each thread, including the application’s main thread, has an associated run loop object. Only secondary threads need to run their run loop explicitly, however. The app frameworks automatically set up and run the run loop on the main thread as part of the application startup process.</p>
</blockquote>
<p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，那么就得让它循环。</p>
<p>所以，Run Loop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行任务。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>
<p>所以，上面代码中 <code>UIApplicationMain()</code> 方法在这里不仅完成了初始化我们的程序并设置程序 Delegate 的任务，而且随之开启了主线程的 Run Loop，开始接受处理事件。这样我们的应用就可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>
<p>直接看图更容易理解：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-10.jpg" alt=""><a href="http://stackoverflow.com/questions/5766839/end-of-run-loop-autorelease-pool-recovery" target="_blank" rel="external">图片来自</a></p>
<p>在 OS X/iOS 系统中，提供了两个这样的对象：</p>
<p>• <strong>CFRunLoopRef</strong>：是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br>• <strong>NSRunLoop</strong>：是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<p>首先来看一张关系图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-09.jpeg" alt="">[图片来自-sunnyxx]</p>
<hr>
<h2 id="RunLoop_与线程的关系">RunLoop 与线程的关系</h2><p>苹果不允许直接创建 Run Loop，它只提供了两个自动获取的函数：<code>CFRunLoopGetMain()</code> 和 <code>CFRunLoopGetCurrent()</code>，这两个函数内部的逻辑大概是下面这样：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 全局的 Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> loopsDic;</span><br><span class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFSpinLock_t</span> loopsLock;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 获取一个 pthread 对应的 Run Loop。</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> _<span class="built_in">CFRunLoopGet</span>(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 Run Loop。</span></span><br><span class="line">        loopsDic = <span class="built_in">CFDictionaryCreateMutable</span>();</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> mainLoop = _<span class="built_in">CFRunLoopCreate</span>();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = <span class="built_in">CFDictionaryGetValue</span>(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">/// 取不到时，创建一个</span></span><br><span class="line">        loop = _<span class="built_in">CFRunLoopCreate</span>();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, thread, loop);</span><br><span class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 Run Loop。</span></span><br><span class="line">        _<span class="built_in">CFSetTSD</span>(..., thread, loop, __<span class="built_in">CFFinalizeRunLoop</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">CFRunLoopGet</span>(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">CFRunLoopGet</span>(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，线程和 Run Loop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 Run Loop，如果你不主动获取，那它一直都不会有。Run Loop 的创建是发生在第一次获取时，Run Loop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 Run Loop（主线程除外）。</p>
<hr>
<h2 id="Run_Loop_对外的接口">Run Loop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有 5 个类:</p>
<p>• CFRunLoopRef<br>• CFRunLoopModeRef<br>• CFRunLoopSourceRef<br>• CFRunLoopTimerRef<br>• CFRunLoopObserverRef</p>
<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-01.png" alt=""><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">图片来自</a></p>
<p>对于上图的理解：一个 Run Loop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 Run Loop 的主函数时，只能指定其中一个 Mode，这个 Mode 被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p><strong>CFRunLoopSourceRef：</strong> 是事件产生的地方。Source 有两个版本：Source0 和 Source1：</p>
<p>• Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <code>CFRunLoopSourceSignal(source)</code>，将这个 Source 标记为待处理，然后手动调用 <code>CFRunLoopWakeUp(runloop)</code> 来唤醒 Run Loop，让其处理这个事件。<br>• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 Run Loop 的线程，其原理在下面会讲到。</p>
<p><strong>CFRunLoopTimerRef：</strong> 是基于时间的触发器，它和 NSTimer 是 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html" target="_blank" rel="external">Toll-Free Bridging</a> 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 Run Loop 时，Run Loop 会注册对应的时间点，当时间点到时，Run Loop 会被唤醒以执行那个回调。</p>
<p><strong>CFRunLoopObserverRef：</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 Run Loop 的状态发生变化时，观察者就能通过回调接受到这个变化。</p>
<hr>
<h2 id="Run_Loop_的_Sources">Run Loop 的 Sources</h2><p>Run Loop 对象处理的事件源分为两种：Input sources 和 Timer sources：</p>
<p>• Input sources：用分发异步事件，通常是用于其他线程或程序的消息，比如：<code>performSelector:onThread:...</code></p>
<p>• Timer sources：用分发同步事件，通常这些事件发生在特定时间或者重复的时间间隔上，比如：<code>[NSTimer scheduledTimerWithTimeInterval:target:selector:...]</code></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-07.jpg" alt=""></p>
<p>上面图中展示了 Run Loop 的概念结构及各种事件源。其中 Input sources 分发异步事件给相应的处理程序并且调用 <code>runUntilDate:</code> 方法（这个方法会在该线程关联的 NSRunLoop 对象上被调用）来退出其 Run Loop。Timer sources 分发事件到相应的处理程序，但不会引起 Run Loop 退出。</p>
<h3 id="Input_sources">Input sources</h3><p>Input sources 有两个不同的种类: Port-Based Sources 和 Custom Input Sources。Run Loop 本身并不关心 Input sources 是哪一种类型。系统会实现两种不同的 Input sources 供我们使用。这两种不同类型的 Input sources 的区别在于：Port-Based Sources 由内核自动发送，Custom Input Sources 需要从其他线程手动发送。</p>
<p><strong>Custom Input Sources</strong></p>
<p>我们可以使用 Core Foundation 里面的 CFRunLoopSourceRef 类型相关的函数来创建 Custom Input Sources。</p>
<p><strong>Port-Based Sources</strong></p>
<p>通过内置的端口相关的对象和函数，配置基于端口的 Input sources。（比如在主线程创建子线程时传入一个 NSPort 对象，主线程和子线程就可以进行通讯。NSPort 对象会负责自己创建和配置 Input sources。)</p>
<h3 id="Time_sources">Time sources</h3><p>Timer sources 在预设的时间点同步的传递消息，Timer 是线程通知自己做某件事的一种方式。</p>
<p>Foundation 中 NSTimer Class 提供了相关方法来设置 Timer sources。需要注意的是除了 <code>scheduledTimerWithTimeInterval</code> 开头的方法创建的 Timer 都需要手动添加到当前 Run Loop 中。（<code>scheduledTimerWithTimeInterval</code> 创建的 Timer 会自动以 Default Mode 加载到当前 Run Loop中。）</p>
<p>Timer 在选择使用一次后，在执行完成时，会从 Run Loop 中移除。选择循环时，会一直保存在当前 Run Loop 中，直到调用 invalidated 方法。</p>
<hr>
<h2 id="Run_Loop_的_Mode">Run Loop 的 Mode</h2><p>Run Loop Mode 是指要被监听的事件源（包括 Input sources 和 Timer sources）的集合 + 要被通知的 run-loop observers 的集合。每一次运行自己的 Run Loop 时，都需要显示或者隐示的指定其运行于哪一种 Mode。在设置 Run Loop Mode 后，你的 Run Loop 会自动过滤和其他 Mode 相关的事件源，而只监视和当前设置 Mode 相关的源（通知相关的观察者）。大多数时候，Run Loop 都是运行在系统定义的默认模式上。</p>
<p>首先我们可以看一下 App 启动后 Run Loop 的状态：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;&#10;    current mode = kCFRunLoopDefaultMode&#10;    common modes = &#123;&#10;        UITrackingRunLoopMode&#10;        kCFRunLoopDefaultMode&#10;    &#125;&#10; &#10;    common mode items = &#123;&#10; &#10;        // source0 (manual)&#10;        CFRunLoopSource &#123;order =-1, &#123;&#10;            callout = _UIApplicationHandleEventQueue&#125;&#125;&#10;        CFRunLoopSource &#123;order =-1, &#123;&#10;            callout = PurpleEventSignalCallback &#125;&#125;&#10;        CFRunLoopSource &#123;order = 0, &#123;&#10;            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;&#10; &#10;        // source1 (mach port)&#10;        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;&#10;        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;&#10;        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;&#10;        CFRunLoopSource &#123;order =-1, &#123;&#10;            callout = PurpleEventCallback&#125;&#125;&#10;        CFRunLoopSource &#123;order = 0, &#123;port = 2407,&#10;            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;&#10;        CFRunLoopSource &#123;order = 0, &#123;port = 1c03,&#10;            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;&#10;        CFRunLoopSource &#123;order = 0, &#123;port = 1b03,&#10;            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;&#10;        CFRunLoopSource &#123;order = 1, &#123;port = 1903,&#10;            callout = __IOMIGMachPortPortCallback&#125;&#125;&#10; &#10;        // Ovserver&#10;        CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry&#10;            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;&#10;        CFRunLoopObserver &#123;order = 0, activities = 0x20,          // BeforeWaiting&#10;            callout = _UIGestureRecognizerUpdateObserver&#125;&#10;        CFRunLoopObserver &#123;order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit&#10;            callout = _afterCACommitHandler&#125;&#10;        CFRunLoopObserver &#123;order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit&#10;            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;&#10;        CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit&#10;            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;&#10; &#10;        // Timer&#10;        CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,&#10;            next fire date = 453098071 (-4421.76019 @ 96223387169499),&#10;            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;&#10;    &#125;,&#10; &#10;    modes &#65309; &#123;&#10;        CFRunLoopMode  &#123;&#10;            sources0 =  &#123; /* same as &#39;common mode items&#39; */ &#125;,&#10;            sources1 =  &#123; /* same as &#39;common mode items&#39; */ &#125;,&#10;            observers = &#123; /* same as &#39;common mode items&#39; */ &#125;,&#10;            timers =    &#123; /* same as &#39;common mode items&#39; */ &#125;,&#10;        &#125;,&#10; &#10;        CFRunLoopMode  &#123;&#10;            sources0 =  &#123; /* same as &#39;common mode items&#39; */ &#125;,&#10;            sources1 =  &#123; /* same as &#39;common mode items&#39; */ &#125;,&#10;            observers = &#123; /* same as &#39;common mode items&#39; */ &#125;,&#10;            timers =    &#123; /* same as &#39;common mode items&#39; */ &#125;,&#10;        &#125;,&#10; &#10;        CFRunLoopMode  &#123;&#10;            sources0 = &#123;&#10;                CFRunLoopSource &#123;order = 0, &#123;&#10;                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;&#10;            &#125;,&#10;            sources1 = (null),&#10;            observers = &#123;&#10;                CFRunLoopObserver &#62;&#123;activities = 0xa0, order = 2000000,&#10;                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;&#10;            )&#125;,&#10;            timers = (null),&#10;        &#125;,&#10; &#10;        CFRunLoopMode  &#123;&#10;            sources0 = &#123;&#10;                CFRunLoopSource &#123;order = -1, &#123;&#10;                    callout = PurpleEventSignalCallback&#125;&#125;&#10;            &#125;,&#10;            sources1 = &#123;&#10;                CFRunLoopSource &#123;order = -1, &#123;&#10;                    callout = PurpleEventCallback&#125;&#125;&#10;            &#125;,&#10;            observers = (null),&#10;            timers = (null),&#10;        &#125;,&#10;        &#10;        CFRunLoopMode  &#123;&#10;            sources0 = (null),&#10;            sources1 = (null),&#10;            observers = (null),&#10;            timers = (null),&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，系统默认注册了 5 个 Mode：</p>
<ol>
<li>kCFRunLoopDefaultMode：App的默认 Mode，通常主线程是在这个 Mode 下运行的</li>
<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>
<li>UIInitializationRunLoopMode：在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用（私有）</li>
<li>GSEventReceiveRunLoopMode：接受系统事件的内部 Mode，通常用不到</li>
<li>kCFRunLoopCommonModes：这是一个占位的 Mode，没有实际作用</li>
</ol>
<p>下图列出了 Cocoa 和 Core Foundation 中定义的一些 Modes：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-08.png" alt=""></p>
<p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopMode</span> &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoop</span> &#123;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为 “Common” 属性（通过将其 Mode Name 添加到 RunLoop 的 “commonModes” 中）。每当 Run Loop 的内容发生变化时，Run Loop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有 Mode 里。</p>
<p>应用场景举例：主线程的 Run Loop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为 “Common” 属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个 TableView 时，Run Loop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 Run Loop 的 “commonModeItems” 中。”commonModeItems” 被 Run Loop 自动更新到所有具有 “Common” 属性的 Mode 里去。</p>
<p>你只能通过 Mode Name 来操作内部的 Mode，当你传入一个新的 Mode Name 但 Run Loop 内部没有对应 Mode 时，Run Loop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 Run Loop 来说，其内部的 Mode 只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 Mode Name。</p>
<hr>
<h2 id="Run_Loop_的_Observers">Run Loop 的 Observers</h2><p>对比上面说的事件源——它们是在特定的同步事件或异步事件发生时被触发，Run Loop Observers 就不一样了，它是在 Run Loop 执行自己的代码到某一个指定位置时被触发。我们可以用 Run Loop Observers 来跟踪到这些事件：</p>
<ul>
<li>进入 Run Loop 的时候</li>
<li>Run Loop 将要处理一个 Timer source 的时候</li>
<li>Run Loop 将要处理一个 Input source 的时候</li>
<li>Run Loop 将要休眠的时候</li>
<li>Run Loop 被唤醒，并准备处理唤醒它的事件的时候</li>
<li>Run Loop 将要退出的时候</li>
</ul>
<p>与 Timer 类似，Run Loop Observers 也可以只观察一次或者反复观察。只观察一次的话，就在 fire 后把自己从 Run Loop 中给移除掉就行了</p>
<p>当你为一个需要长时间运行的线程配置 Run Loop 时，最好是能添加至少一个 Input source 到 Run Loop 中，这比用 Timer source 更好，Timer 要么一次，触发完了，就会结束，而之后 Run Loop 也就结束了，要么循环，这样就会导致周期性地唤醒线程，这实际上是一种轮询的形式。与之相反，Input source会一直等待对应的事件发生，而在事件发生前它能让线程先休眠。</p>
<hr>
<h2 id="Run_Loop_事件处理流程">Run Loop 事件处理流程</h2><p>Run Loop 本质是一个处理事件源的循环。我们对 Run Loop 的运行时具有控制权，如果当前没有时间发生，Run Loop 会让当前线程进入睡眠模式，来减轻 CPU 压力。如果有事件发生，Run Loop 就处理事件并通知相关的 Observer。具体的顺序如下:</p>
<ol>
<li>Run Loop 进入的时候，会通知 Observer</li>
<li>Timer 即将被触发时，会通知 Observer</li>
<li>有其它非 Port-Based Input Source 即将被触发时，会通知 Observer</li>
<li>触发非 Port-Based Input Source 的事件源</li>
<li>如果一个基于端口的 Input source 已经就绪，那就立即处理这个事件，跳转到步骤 9</li>
<li>通知 Observer 当前线程进入睡眠状态</li>
<li>让线程休眠，除非下面的事件发生：<ul>
<li>一个对应着基于端口的 Input source 的事件到来</li>
<li>一个 timer 触发了</li>
<li>Run Loop 的超时了</li>
<li>Run Loop 被显示唤醒</li>
</ul>
</li>
<li>通知 Observer 线程被唤醒</li>
<li>处理等待的事件<ul>
<li>如果一个用户定义的 Timer 触发了，处理这个 Timer 事件并且重启 Run Loop，跳转到步骤 2</li>
<li>如果一个 Input source 触发了，分发这个事件</li>
<li>如果 Run Loop 被显式地唤醒了并且还没超时，重启 Run Loop，跳转到步骤 2</li>
</ul>
</li>
<li>通知 observers 这个 Run Loop 要退出了</li>
</ol>
<p>由于与 Timer source 和 Input source 相关的 observer 通知是在事件发生前发出去的，所以这些通知和真实的事件发生时间之间是存在一定的延时的。如果你需要精确的时间控制，而这个延时对你来说很致命的话，你可以使用休眠通知和唤醒通知来校队事件实际发生时间。</p>
<p>由于 timer 和其他一些周期性的事件是在你运行其对应的 Run Loop 的时候被分发的，所以当绕过这个 Loop 的时候，这些事件的分发也会被干扰到。一个典型的例子就是当你实现一个鼠标事件追踪的例程时，你进入到一个循环里不断地向应用请求事件，由于你直接抓取这些事件而不是正常地由应用向你的例程分发，这时那些活动的timer也会无法触发，除非你的鼠标事件追踪例程退出并将控制器交给应用。</p>
<p>可以通过 Run Loop 对象来显式地唤醒 Run Loop。其他事件也可以唤醒 Run Loop，比如：添加一个其他的非基于端口的 Input source 可以唤醒 Run Loop 立即处理这个 Input source，而不是等到其他事件发生才处理。</p>
<hr>
<h2 id="Run_Loop_对象的线程安全问题">Run Loop 对象的线程安全问题</h2><p>使用 Core Foundation 中的方法通常是线程安全的，可以被任意线程调用。如果修改了 Run Loop 的配置然后需要执行某些操作，我们最好是在 Run Loop 所在的线程中执行这些操作。</p>
<p>使用 Foundation 中的 NSRunLoop 类来修改自己的 Run Loop，我们必须在 Run Loop 的所在线程中完成这些操作。在其他线程中给 Run Loop 添加事件源或者 Timer 会导致程序崩溃。</p>
<hr>
<h2 id="Run_Loop_的内部逻辑">Run Loop 的内部逻辑</h2><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-02.png" alt=""><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">图片来自</a></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用DefaultMode启动</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), k<span class="built_in">CFRunLoopDefaultMode</span>, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// RunLoop的实现</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunSpecific</span>(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __<span class="built_in">CFRunLoopFindMode</span>(runloop, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (__<span class="built_in">CFRunLoopModeIsEmpty</span>(currentMode)) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopEntry</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 内部函数，进入loop</span></span><br><span class="line">    __<span class="built_in">CFRunLoopRun</span>(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">truetruetrue<span class="comment">// 省略</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    __<span class="built_in">CFRunLoopDoObservers</span>(rl, currentMode, k<span class="built_in">CFRunLoopExit</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，实际上 Run Loop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<hr>
<h2 id="Run_Loop_的底层实现">Run Loop 的底层实现</h2><p>从上面代码可以看到，Run Loop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OS X/iOS 的系统架构。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-03.png" alt=""><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">图片来自</a></p>
<p>苹果官方将整个系统大致划分为上述 4 个层次：</p>
<p>• 应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。<br>• 应用框架层即开发人员接触到的 Cocoa 等框架。<br>• 核心框架层包括各种核心框架、OpenGL 等内容。<br>• Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 <a href="http://opensource.apple.com/" target="_blank" rel="external">opensource.apple.com</a> 里找到。</p>
<p>我们在深入看一下 Darwin 这个核心的架构：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-04.png" alt=""><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">图片来自</a></p>
<p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。<br>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。<br>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。<br>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>
<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些 API 非常基础，如果没有这些 API 的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>
<p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，发送和接受消息是通过同一个 API 进行的。</p>
<p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-05.png" alt=""><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">图片来自</a></p>
<p>这些概念可以参考维基百科: <a href="https://en.wikipedia.org/wiki/System_call" target="_blank" rel="external">System_call</a>、<a href="https://en.wikipedia.org/wiki/Trap_(computing" target="_blank" rel="external">Trap_(computing)</a>)。</p>
<p><strong>Run Loop 的核心就是一个 <code>mach_msg()</code>，Run Loop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 <code>mach_msg_trap()</code> 这个地方。</strong></p>
<p>关于具体的如何利用 mach port 发送信息，可以看看 NSHipster <a href="http://nshipster.com/inter-process-communication/" target="_blank" rel="external">这一篇文章</a>，或者这里的<a href="https://segmentfault.com/a/1190000002400329" target="_blank" rel="external">中文翻译</a> 。</p>
<p>关于Mach的历史可以看看这篇很有趣的文章：<a href="http://history.programmer.com.cn/8121/" target="_blank" rel="external">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p>
<hr>
<h2 id="苹果用_Run_Loop_实现的功能">苹果用 Run Loop 实现的功能</h2><h3 id="AutoreleasePool">AutoreleasePool</h3><p>在主线程执行的代码，通常是写在诸如事件回调、Timer 回调内的。这些回调会被 Run Loop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h3 id="事件响应">事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h3 id="手势识别">手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop 即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="界面更新">界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<p>这个函数内部的调用栈大概是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2<span class="built_in">CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span>()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> layoutSublayers];</span><br><span class="line">                            [<span class="built_in">UIView</span> layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> display];</span><br><span class="line">                            [<span class="built_in">UIView</span> drawRect];</span><br></pre></td></tr></table></figure>
<h3 id="定时器">定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 Run Loop 后，Run Loop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。Run Loop 为了节省资源，并不会在非常准确的时间点回调这个 Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<h3 id="PerformSelecter">PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 Run Loop 中。所以如果当前线程没有 Run Loop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 Run Loop 该方法也会失效。</p>
<h3 id="关于_GCD">关于 GCD</h3><p>GCD 提供的某些接口也用到了 Run Loop， 例如 dispatch_async()。</p>
<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code> 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h3 id="关于网络请求">关于网络请求</h3><p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-06.png" alt=""><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">图片来自</a></p>
<p>NSURLConnectionLoader 中的 Run Loop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 Run Loop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 Run Loop 对 Delegate 执行实际的回调。</p>
<hr>
<h2 id="Run_Loop_的实际应用举例">Run Loop 的实际应用举例</h2><h3 id="AFNetworking">AFNetworking</h3><p>由于计划之后会阅读 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a> 的源码，并整理成系列的文章，所以，这里先留个坑，回头再来补上。</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="external">Threading Programming Guide</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/" target="_blank" rel="external">NSRunLoop Class Reference</a></li>
<li><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></li>
<li><a href="http://www.samirchen.com/ios-runloop/" target="_blank" rel="external">iOS中的RunLoop</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>在学习完内存管理与多线程的知识后，我又将目光瞄向了 <strong>Run Loop</strong>，不过受限于现阶段的能力，我在查阅了大量资料后，对于 Run Loop 的理解仍然非常浅显，所以本文绝大多数的内容，是参照网上大牛们的文章进行总结的。当然啦，我也希望在不久的将来，对于 Run Loop 能有更多自己的观点与总结。</p>]]>
    
    </summary>
    
      <category term="NSRunLoop" scheme="http://itangqi.me/tags/NSRunLoop/"/>
    
      <category term="Run Loop" scheme="http://itangqi.me/tags/Run-Loop/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《图解 HTTP》读书笔记（三）]]></title>
    <link href="http://itangqi.me/2016/04/07/the-notes-of-learning-illustrating-http-three/"/>
    <id>http://itangqi.me/2016/04/07/the-notes-of-learning-illustrating-http-three/</id>
    <published>2016-04-06T16:00:00.000Z</published>
    <updated>2016-04-21T05:06:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="第_7_章_确保_Web_安全的_HTTPS">第 7 章 确保 Web 安全的 HTTPS</h2><a id="more"></a> 
<h3 id="7-1_HTTP_的缺点">7.1 HTTP 的缺点</h3><h4 id="7-1-1_通信使用明文（不加密），内容可能会被窃听">7.1.1 通信使用明文（不加密），内容可能会被窃听</h4><h5 id="TCP/IP_是可能被窃听的网络">TCP/IP 是可能被窃听的网络</h5><p>这是因为，按 TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-7.1.1.jpg" alt=""></p>
<h5 id="加密处理防止被窃听">加密处理防止被窃听</h5><p><strong>1. 通信的加密</strong></p>
<p>一种方式就是将通信加密。HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。</p>
<p>用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。</p>
<p><strong>2. 内容加密</strong></p>
<p>由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里所含的内容进行加密处理。</p>
<p>在这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送请求。</p>
<p>有一点必须引起注意，由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。稍后我们会加以说明。</p>
<h4 id="7-1-2_不验证通信方的身份，因此有可能遭遇伪装">7.1.2 不验证通信方的身份，因此有可能遭遇伪装</h4><p><strong>1. 任何人都可发起请求</strong></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-7.1.2.jpg" alt=""></p>
<p>HTTP 协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患：</p>
<ol>
<li><p>无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器</p>
</li>
<li><p>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端</p>
</li>
<li><p>无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限</p>
</li>
<li><p>无法判定请求是来自何方、出自谁手</p>
</li>
<li><p>即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）</p>
</li>
</ol>
<p><strong>2. 查明对手的证书</strong></p>
<p>如果使用 SSL 则可以。SSL 不仅提供加密处理，而且还使用了一种被称为<strong>证书</strong>的手段，可用于确定方。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-7.1.3.jpg" alt=""></p>
<h4 id="7-1-3_无法证明报文的完整性，所以有可能已遭篡改">7.1.3 无法证明报文的完整性，所以有可能已遭篡改</h4><p>所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。</p>
<p><strong>1. 接收到的内容可能有误</strong></p>
<p>像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-7.1.4.jpg" alt=""></p>
<p><strong>2. 如何防止篡改</strong></p>
<p>虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。</p>
<p>可惜的是，用这些方法也依然无法百分百保证确认结果正确。因为 PGP 和 MD5 本身被改写的话，用户是没有办法意识到的。</p>
<p>为了有效防止这些弊端，有必要使用 HTTPS。</p>
<h3 id="7-2_HTTP_+_加密_+_认证_+_完整性保护_=_HTTPS">7.2 HTTP + 加密 + 认证 + 完整性保护 = HTTPS</h3><h4 id="7-2-1_HTTPS_是身披_SSL_外壳的_HTTP">7.2.1 HTTPS 是身披 SSL 外壳的 HTTP</h4><p>通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-7.2.1.jpg" alt=""></p>
<p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的<strong>加密</strong>、<strong>证书</strong>和<strong>完整性保护</strong>这些功能。</p>
<p>SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL（Secure Socket Layer） 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-7.2.1.1.jpg" alt=""></p>
<h4 id="7-2-2_相互交换密钥的公开密钥加密技术">7.2.2 相互交换密钥的公开密钥加密技术</h4><p>SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。</p>
<p>近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。</p>
<p><strong>1. 共享密钥加密的困境</strong></p>
<p>加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-7.2.2.1.jpg" alt=""></p>
<p>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</p>
<p><strong>2. 使用两把密钥的公开密钥加密</strong></p>
<p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</p>
<p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-7.2.2.2.jpg" alt=""></p>
<p><strong>3. HTTPS 采用混合加密机制</strong></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-7.2.2.3.jpg" alt=""></p>
<h4 id="7-2-3_证明公开密钥正确性的证书">7.2.3 证明公开密钥正确性的证书</h4><p>遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。</p>
<p>为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-7.2.3.jpg" alt=""></p>
<p><strong>1. 可证明组织真实性的 EV SSL 证书</strong></p>
<p><strong>2. 用以确定客户端的客户端证书</strong></p>
<p><strong>3. 认证机构信誉第一</strong></p>
<p><strong>4. 自由认证机构颁发的证书称为自签名证书</strong></p>
<h4 id="7-2-4_HTTPS_的安全通信机制">7.2.4 HTTPS 的安全通信机制</h4><p>为了更好地理解 HTTPS，我们来观察一下 HTTPS 的通信步骤：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-7.2.4.1.jpg" alt=""></p>
<p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-7.2.4.2.jpg" alt=""></p>
<p><strong>1. SSL 和 TLS</strong></p>
<p>SSL 技术最初是由浏览器开发商网景通信公司率先倡导的，开发过 SSL3.0 之前的版本。目前主导权已转移到 IETF（Internet Engineering Task Force，Internet 工程任务组）的手中。</p>
<p>IETF 以 SSL3.0 为基准，后又制定了 TLS1.0、TLS1.1 和 TLS1.2。TSL 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。</p>
<p><strong>2. SSL 速度慢吗</strong></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-7.2.4.3.jpg" alt=""></p>
<p>SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗 CPU 及内存等资源，导致处理速度变慢。</p>
<hr>
<h2 id="第_8_章_确认访问用户身份的认证">第 8 章 确认访问用户身份的认证</h2><h3 id="8-1_何为认证">8.1 何为认证</h3><p><strong>HTTP/1.1 使用的认证方式如下所示：</strong></p>
<ol>
<li>BASIC 认证（基本认证）</li>
<li>DIGEST  认证（摘要认证）</li>
<li>SSL 客户端认证</li>
<li>FormBase 认证（基于表单认证）</li>
</ol>
<p>此外，还有 Windows 统一认证（Keberos 认证、NTLM 认证）</p>
<h3 id="8-2_BASIC_认证">8.2 BASIC 认证</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-8.1.jpg" alt=""></p>
<p>BASIC 采用 Base64 编码方式，但这并不是加密处理。</p>
<p>详情参见：</p>
<ul>
<li><a href="http://www.cnblogs.com/xqxacm/p/4886299.html" target="_blank" rel="external">浅谈Base64编码算法</a></li>
<li><a href="https://nieyong.github.io/wiki_web/BASE64%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8.html" target="_blank" rel="external">BASE64编码原理及应用</a></li>
<li><a href="https://segmentfault.com/q/1010000000801988" target="_blank" rel="external">为什么有的代码要用 base64 进行编码？</a></li>
<li><a href="http://blog.xiayf.cn/2016/01/24/base64-encoding/" target="_blank" rel="external">Base64编码原理与应用</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2008/06/base64.html" target="_blank" rel="external">Base64笔记</a></li>
</ul>
<h3 id="8-3_DIGEST_认证">8.3 DIGEST 认证</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-8.2.jpg" alt=""></p>
<p>DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 的客户端认证相比仍旧很弱。DIGEST 认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。</p>
<h3 id="8-4_SSL_客户端认证">8.4 SSL 客户端认证</h3><p>SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书（在 HTTPS 一章已讲解）认证，服务器可确认访问是否来自已登录的客户端。</p>
<p>在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证（稍后讲解）组合形成一种双因素认证（Two-factor authentication）来使用。所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。</p>
<h3 id="8-5_基于表单认证">8.5 基于表单认证</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-8.3.jpg" alt=""></p>
<p>基于表单认证本身是通过服务器端的 Web 应用，将客户端发送过来的用户 ID 和密码与之前登录过的信息做匹配来进行认证的。</p>
<p>但鉴于 HTTP 是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。”</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="第_7_章_确保_Web_安全的_HTTPS">第 7 章 确保 Web 安全的 HTTPS</h2>]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://itangqi.me/tags/HTTP/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="HTTP" scheme="http://itangqi.me/categories/HTTP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《图解 HTTP》读书笔记（二）]]></title>
    <link href="http://itangqi.me/2016/04/05/the-notes-of-learning-illustrating-http-two/"/>
    <id>http://itangqi.me/2016/04/05/the-notes-of-learning-illustrating-http-two/</id>
    <published>2016-04-04T16:00:00.000Z</published>
    <updated>2016-04-20T02:27:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="第_4_章_返回结果的_HTTP_状态码">第 4 章 返回结果的 HTTP 状态码</h2><a id="more"></a> 
<h3 id="4-1_状态码告知从服务器端返回的请求结果">4.1  状态码告知从服务器端返回的请求结果</h3><p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-4.1.1.jpg" alt=""></p>
<p>数字中的第一位定义了响应类别，后两位无分类。响应类别有以下 5 种：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">类别</th>
<th style="text-align:center">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1XX</td>
<td style="text-align:center">Informational（信息性状态码）</td>
<td style="text-align:center">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:center">2XX</td>
<td style="text-align:center">Success（成功状态码）</td>
<td style="text-align:center">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:center">3XX</td>
<td style="text-align:center">Redirection（重定向状态码）</td>
<td style="text-align:center">需求进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:center">4XX</td>
<td style="text-align:center">Client Error（客户端错误状态码）</td>
<td style="text-align:center">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:center">5XX</td>
<td style="text-align:center">Server Error（服务器错误状态码）</td>
<td style="text-align:center">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<p>只要遵守状态码类别的定义，即使改变 <a href="https://datatracker.ietf.org/doc/rfc2616/" target="_blank" rel="external">RFC2616</a> 中定义的状态码，或服务器端自行创建状态码都没问题。</p>
<h4 id="2XX_成功">2XX 成功</h4><p>200 OK：表示从客户端发来的请求在服务器端被正常处理了</p>
<p>204 No Content：请求处理成功，但是没有资源返回</p>
<p>206 Partial Content：请求处理成功，返回部分内容，响应报文中包含 Content-Range 指定范围的实体内容</p>
<h4 id="3XX_重定向">3XX 重定向</h4><p>301 Moved Permanently：永久性重定向</p>
<p>302 Found：临时性重定向</p>
<p>303 See Other：表示请求的资源存在着另一个 URL，应使用 GET 方法定向获取请求的资源</p>
<p>304 Not Modified：表示请求的资源没有改变，可以使用客户端上未过期的资源</p>
<p>307 Temporary Redirect：临时性重定向，不会从 POST 变成 GET</p>
<h4 id="4XX_客户端错误">4XX 客户端错误</h4><p>400 Bad Request：表示请求报文中存在语法错误</p>
<p>401 Unauthorized：表示发送的请求需要有通过 HTTP 认证</p>
<p>403 Forbidden：表示请求资源的访问被服务器拒绝了</p>
<p>404 Not Found：表示服务器上没有请求的资源</p>
<h4 id="5XX_服务器错误">5XX 服务器错误</h4><p>500 Internal Server Error：表示服务器在执行请求时发生了错误</p>
<p>503 Service Unavailable：表示服务器暂时处于超负载或者正在进行停机维护，现在无法处理请求</p>
<hr>
<h2 id="第_5_章_与_HTTP_协作的_Web_服务器">第 5 章 与 HTTP 协作的 Web 服务器</h2><h3 id="5-1_用单台虚拟主机实现多个域名">5.1  用单台虚拟主机实现多个域名</h3><p>HTTP / 1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。这是利用虚拟主机（Virtual Host，又称虚拟服务器）的功能。</p>
<p>在互联网上，域名通过 DNS 服务映射到 IP 地址之后访问目标网站。可见，当请求发送到服务器时，已经是以 IP 地址形式访问了。所以，当一台托管了两个域名的服务器接收到请求时就需要弄清楚究竟要访问哪个域名。<br>在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。</p>
<h3 id="5-2_通信数据转发程序：代理、网关、隧道">5.2 通信数据转发程序：代理、网关、隧道</h3><h4 id="5-2-1_代理">5.2.1 代理</h4><p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-5.2.1.jpg" alt=""></p>
<p>每次通过代理服务器转发请求或响应式，会追加写入via首部信息。</p>
<p>使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。</p>
<p>代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文：</p>
<ul>
<li>缓存代理：代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上</li>
<li>透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理。反之，对 报文内容进行加工的代理被成为非透明代理</li>
</ul>
<h4 id="5-2-2_网关">5.2.2 网关</h4><p>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。 </p>
<p>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-5.2.2.jpg" alt=""></p>
<h4 id="5-2-3_隧道">5.2.3 隧道</h4><p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。</p>
<p>隧道本身不会去解析 HTTP 请求。请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-5.2.3.jpg" alt=""></p>
<h3 id="5-3_保存资源的缓存">5.3 保存资源的缓存</h3><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，节省通信流量和时间。</p>
<p>缓存服务器是代理服务器的一种。当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。</p>
<p>缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。</p>
<h4 id="5-3-1_缓存的有效期限">5.3.1 缓存的有效期限</h4><p>对于缓存服务器和客户端浏览器，当判定缓存过期或客户端要求，会向源服务器确认资源的有效性。若失效，浏览器会再次请求新资源。</p>
<h4 id="5-3-2_客户端的缓存">5.3.2 客户端的缓存</h4><p>缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以 Internet Explorer 程序为例，把客户端缓存称为临时网络文件（Temporary Internet File）。</p>
<hr>
<h2 id="第_6_章_HTTP_首部">第 6 章 HTTP 首部</h2><h3 id="6-1_HTTP_首部字段">6.1 HTTP 首部字段</h3><h4 id="6-1-1_HTTP_首部字段传递重要信息">6.1.1 HTTP 首部字段传递重要信息</h4><p>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p>
<h4 id="6-1-2_4_种_HTTP_首部字段类型">6.1.2 4 种 HTTP 首部字段类型</h4><ol>
<li>通用首部字段（General Header Fields）</li>
<li>请求首部字段（Request Header Fields）</li>
<li>响应首部字段（Response Header Fields）</li>
<li>实体首部字段（Entity Header Fields）</li>
</ol>
<h4 id="6-1-3_HTTP_/_1-1_首部字段一览">6.1.3 HTTP / 1.1 首部字段一览</h4><p><strong>通用首部字段</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Cache-Control</td>
<td style="text-align:center">控制缓存的行为</td>
</tr>
<tr>
<td style="text-align:center">Connection</td>
<td style="text-align:center">逐跳首部、连接的管理</td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">创建报文日期时间</td>
</tr>
<tr>
<td style="text-align:center">Pragma</td>
<td style="text-align:center">报文指令</td>
</tr>
<tr>
<td style="text-align:center">Trailer</td>
<td style="text-align:center">报文末端的首部一览</td>
</tr>
<tr>
<td style="text-align:center">Transfer-Encoding</td>
<td style="text-align:center">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td style="text-align:center">Upgrade</td>
<td style="text-align:center">升级为其他协议</td>
</tr>
<tr>
<td style="text-align:center">Via</td>
<td style="text-align:center">代理服务器的相关信息</td>
</tr>
<tr>
<td style="text-align:center">Warning</td>
<td style="text-align:center">错误通知</td>
</tr>
</tbody>
</table>
<ol>
<li>Cache-Control 的 no-cache 指令代表不缓存过期的资源，而不是不缓存。no-store 才是真正不进行缓存。</li>
<li>Connection 首部字段的值为 close 时，代表服务器想明确断开连接（HTTP / 1.1默认都是持久连接）</li>
</ol>
<p><strong>请求首部字段</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept</td>
<td style="text-align:center">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td style="text-align:center">Accept-Charset</td>
<td style="text-align:center">优先的字符集</td>
</tr>
<tr>
<td style="text-align:center">Accept-Encoding</td>
<td style="text-align:center">优先的内容编码</td>
</tr>
<tr>
<td style="text-align:center">Accept-Language</td>
<td style="text-align:center">优先的语言</td>
</tr>
<tr>
<td style="text-align:center">Authorization</td>
<td style="text-align:center">Web 认证信息</td>
</tr>
<tr>
<td style="text-align:center">Expect</td>
<td style="text-align:center">期待服务器的特定行为</td>
</tr>
<tr>
<td style="text-align:center">From</td>
<td style="text-align:center">用户的电子邮件地址</td>
</tr>
<tr>
<td style="text-align:center">Host</td>
<td style="text-align:center">请求资源所在服务器</td>
</tr>
<tr>
<td style="text-align:center">If-Match</td>
<td style="text-align:center">比较实体标记（ETag）</td>
</tr>
<tr>
<td style="text-align:center">If-Modified-Since</td>
<td style="text-align:center">比较资源的更新时间</td>
</tr>
<tr>
<td style="text-align:center">If-None-Match</td>
<td style="text-align:center">比较实体标记（与If-Match相反）</td>
</tr>
<tr>
<td style="text-align:center">If-Range</td>
<td style="text-align:center">资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td style="text-align:center">If-Unmodified-Since</td>
<td style="text-align:center">比较资源的更新时间（与 If-Modified-Since 相反）</td>
</tr>
<tr>
<td style="text-align:center">Max-Forwards</td>
<td style="text-align:center">最大传输逐跳数</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Authorization</td>
<td style="text-align:center">代理服务器要求客户端的认真信息</td>
</tr>
<tr>
<td style="text-align:center">Range</td>
<td style="text-align:center">实体的字节范围请求</td>
</tr>
<tr>
<td style="text-align:center">Referer</td>
<td style="text-align:center">对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td style="text-align:center">TE</td>
<td style="text-align:center">传输编码的优先级</td>
</tr>
<tr>
<td style="text-align:center">User-Agent</td>
<td style="text-align:center">HTTP 客户端程序的信息</td>
</tr>
</tbody>
</table>
<ol>
<li>该表的 Accept* 字段都可以指定权重 q 值（0-1）。当服务器提供多种内容时，将会首先返回权重最高的</li>
<li>If-xxx 请求首部字段都称为条件请求，服务器接收到附带条件的请求后，只有判断指定条件为真时，才回执行请求</li>
<li>Referer 的正确拼写应该是 Referrer。当直接在浏览器的地址栏输入 URI 时，或处于安全考虑时，可不发该首部字段</li>
</ol>
<p><strong>响应首部字段</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept-Ranges</td>
<td style="text-align:center">是否接受字节范围请求</td>
</tr>
<tr>
<td style="text-align:center">Age</td>
<td style="text-align:center">推算资源创建经过时间</td>
</tr>
<tr>
<td style="text-align:center">ETag</td>
<td style="text-align:center">资源的匹配信息</td>
</tr>
<tr>
<td style="text-align:center">Location</td>
<td style="text-align:center">令客户端重定向至指定的 URI</td>
</tr>
<tr>
<td style="text-align:center">Proxy-Authentication</td>
<td style="text-align:center">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td style="text-align:center">Retry-After</td>
<td style="text-align:center">对再次发起请求的时机要求</td>
</tr>
<tr>
<td style="text-align:center">Server</td>
<td style="text-align:center">HTTP 服务器的安装信息</td>
</tr>
<tr>
<td style="text-align:center">Vary</td>
<td style="text-align:center">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td style="text-align:center">WWW-Authenticate</td>
<td style="text-align:center">服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
<p>几乎所有浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p>
<p><strong>实体首部字段</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Allow</td>
<td style="text-align:center">资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td style="text-align:center">Content-Encoding</td>
<td style="text-align:center">实体主体适用的编码方式</td>
</tr>
<tr>
<td style="text-align:center">Content-Language</td>
<td style="text-align:center">实体主体的自然语言</td>
</tr>
<tr>
<td style="text-align:center">Content-Length</td>
<td style="text-align:center">实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td style="text-align:center">Content-Location</td>
<td style="text-align:center">替代对应资源的 URI</td>
</tr>
<tr>
<td style="text-align:center">Content-MD5</td>
<td style="text-align:center">实体主体的报文摘要</td>
</tr>
<tr>
<td style="text-align:center">Content-Range</td>
<td style="text-align:center">实体主体的位置范围</td>
</tr>
<tr>
<td style="text-align:center">Content-Type</td>
<td style="text-align:center">实体主体的媒体类型</td>
</tr>
<tr>
<td style="text-align:center">Expires</td>
<td style="text-align:center">实体主体过期的日期时间</td>
</tr>
<tr>
<td style="text-align:center">Last-Modified</td>
<td style="text-align:center">资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
<p><strong>Cookie 相关首部字段</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">首部类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Set-Cookie</td>
<td style="text-align:center">服务器端返回给客户端存储的 Cookie 信息</td>
<td style="text-align:center">响应首部字段</td>
</tr>
<tr>
<td style="text-align:center">Cookie</td>
<td style="text-align:center">客户端向服务器端发送 Cookie 信息</td>
<td style="text-align:center">请求首部字段</td>
</tr>
</tbody>
</table>
<p><strong>Set-Cookie 字段的属性</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NAME=VALUE</td>
<td style="text-align:center">赋予 Cookie 的名称和其值（必须项）</td>
</tr>
<tr>
<td style="text-align:center">expires=DATE</td>
<td style="text-align:center">Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td>
</tr>
<tr>
<td style="text-align:center">path=Path</td>
<td style="text-align:center">将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录）</td>
</tr>
<tr>
<td style="text-align:center">domain=域名</td>
<td style="text-align:center">作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名）</td>
</tr>
<tr>
<td style="text-align:center">Secure</td>
<td style="text-align:center">仅在 HTTPS 安全通信时才会发送 Cookie</td>
</tr>
<tr>
<td style="text-align:center">HttpOnly</td>
<td style="text-align:center">加以限制，使 Cookie 不能被 JavaScript 脚本访问</td>
</tr>
</tbody>
</table>
<ol>
<li>expires：一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显示删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作</li>
<li>path：用来指定 cookie 被发送到服务器的哪一个目录路径下（即被服务器哪个路径接收 cookie），其中”/“指的是站点根目录，可在同一台服务器（即使有多个应用）内共享该 cookie</li>
</ol>
<p><strong>其他首部字段</strong></p>
<ul>
<li>X-Frame-Options</li>
<li>X-XSS-Protection</li>
<li>DNT</li>
<li>P3P</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="第_4_章_返回结果的_HTTP_状态码">第 4 章 返回结果的 HTTP 状态码</h2>]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://itangqi.me/tags/HTTP/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="HTTP" scheme="http://itangqi.me/categories/HTTP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《图解 HTTP》读书笔记（一）]]></title>
    <link href="http://itangqi.me/2016/04/04/the-notes-of-learning-illustrating-http-one/"/>
    <id>http://itangqi.me/2016/04/04/the-notes-of-learning-illustrating-http-one/</id>
    <published>2016-04-03T16:00:00.000Z</published>
    <updated>2016-04-19T08:59:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>由于最近一段时间在找实习，所以陆陆续续面试了几家公司，可结果都跪了….</p>
<p>总结失败的原因有很多，如果要进行个排名的话，<strong>网络</strong>一定能进前三。每每被面试官问到网络相关知识的时候，我都是一脸懵逼样，支支吾吾说不出个所以然。</p>
<p>现在想想，做移动端也有些日子了，可网络知识这块居然只知胜少，究其原因就是自己不求上进，直到找工作的时候被现实打脸了才恍然醒悟。于是，痛定思痛，决定恶补下网络知识，一番 Google 后，决定以《图解 HTTP》作为入门书籍。当然好记性不如烂笔头，读书笔记是少不了的。</p>
<a id="more"></a> 
<hr>
<h2 id="第_1_章_了解_Web_及网络基础">第 1 章 了解 Web 及网络基础</h2><h3 id="1-1_使用_HTTP_协议访问_Web">1.1  使用 HTTP 协议访问 Web</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-1.1.jpg" alt=""></p>
<h4 id="1-1-1_从输入_URL_到页面加载完成的过程中都发生了什么事情？">1.1.1 从输入 URL 到页面加载完成的过程中都发生了什么事情？</h4><ol>
<li>在浏览器里输入网址</li>
<li>浏览器查找域名的 IP 地址</li>
<li>浏览器给 Web 服务器发送一个 HTTP 请求</li>
<li>Facebook 服务的永久重定向响应</li>
<li>浏览器跟踪重定向地址</li>
<li>服务器「处理」请求</li>
<li>服务器发回一个 HTML 响应</li>
<li>浏览器开始显示HTML</li>
<li>浏览器发送获取嵌入在 HTML 中的对象</li>
<li>浏览器发送异步（AJAX）请求</li>
</ol>
<p>详情参见：</p>
<ul>
<li><a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="external">当···时发生了什么？</a></li>
<li><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="external">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></li>
<li><a href="https://www.zhihu.com/question/34873227" target="_blank" rel="external">当在浏览器地址栏输入一个URL后回车，将会发生的事情？</a></li>
</ul>
<h3 id="1-2_HTTP_历史">1.2  HTTP 历史</h3><h4 id="1-2-1_HTTP_1-0_vs_HTTP_1-1">1.2.1  HTTP 1.0 vs HTTP 1.1</h4><ol>
<li>可扩展性</li>
<li>缓存</li>
<li>带宽优化</li>
<li>长连接</li>
<li>消息传递</li>
<li>Host 头域</li>
<li>错误提示</li>
<li>内容协商</li>
</ol>
<p>详情参见：</p>
<ul>
<li><a href="http://stackoverflow.com/questions/246859/http-1-0-vs-1-1" target="_blank" rel="external">HTTP 1.0 vs 1.1</a></li>
<li><a href="http://blog.csdn.net/forgotaboutgirl/article/details/6936982" target="_blank" rel="external">HTTP/1.1与HTTP/1.0的区别</a></li>
</ul>
<h4 id="1-2-2_HTTP_2-0">1.2.2  HTTP 2.0</h4><ol>
<li>二进制分帧</li>
<li>首部压缩</li>
<li>多路复用</li>
<li>并行双向字节流的请求和响应</li>
<li>请求优先级</li>
<li>服务器推送</li>
</ol>
<p>详情参见：</p>
<ul>
<li><a href="https://www.zhihu.com/question/34074946" target="_blank" rel="external">HTTP/2.0 相比1.0有哪些重大改进？</a></li>
<li><a href="http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/" target="_blank" rel="external">HTTP 2.0 的奇妙日常</a></li>
</ul>
<h3 id="1-3_网络基础_TCP/IP">1.3  网络基础 TCP/IP</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-1.3.jpg" alt=""></p>
<p>图：TCP/IP 是互联网相关的各类协议族的总称</p>
<h4 id="1-3-1_TCP/IP_的分层管理">1.3.1 TCP/IP 的分层管理</h4><ul>
<li><p>应用层：决定了向用户提供应用服务时通信的活动</p>
</li>
<li><p>传输层：对上层应用层，提供处于网络连接中的两台计算机之间的数据传输</p>
</li>
<li><p>网络层（又名网络互连层）：用来处理在网络上流动的数据包</p>
</li>
<li><p>链路层（又名数据链路层，网络接口层）：用来处理连接网络的硬件部分</p>
</li>
</ul>
<h4 id="1-3-2_TCP/IP_通信传输流">1.3.2  TCP/IP 通信传输流</h4><p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-1.3.2.jpg" alt=""></p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。</p>
<h3 id="1-4_与_HTTP_关系密切的协议：IP、TCP_和_DNS">1.4  与 HTTP 关系密切的协议：IP、TCP 和 DNS</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-1.4.1.jpg" alt=""></p>
<h4 id="1-4-1_负责传输的_IP_协议">1.4.1  负责传输的 IP 协议</h4><p>在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</p>
<h4 id="1-4-2_确保可靠性的_TCP_协议">1.4.2  确保可靠性的 TCP 协议</h4><p>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-1.4.2.jpg" alt=""></p>
<h5 id="1-4-2-1_为何要三次握手">1.4.2.1  为何要三次握手</h5><ol>
<li><p>为了防止已失效的连接请求报文段（上一个 TCP 连接）突然又传送到了服务端，因而产生错误（服务端白白等待）</p>
</li>
<li><p>也可假设想场景：两个人打电话</p>
</li>
</ol>
<h5 id="1-4-2-2_为何要四次分手">1.4.2.2 为何要四次分手</h5><ol>
<li><p>保证 TCP 协议的全双工连接能够可靠关闭</p>
</li>
<li><p>保证这次连接的重复数据段从网络中消失</p>
</li>
<li><p>TCP 连接是全双工的，这就意味着，当主机 1 发出 FIN 报文段时，只是表示主机 1 已经没有数据要发送了，但是，这个时候主机 1 还是可以接受来自主机 2 的数据；当主机 2 返回 ACK 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可以发送数据到主机 1 的；当主机 2 也发送了 FIN 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接</p>
</li>
</ol>
<p>详情参见：</p>
<ul>
<li><a href="http://www.jellythink.com/archives/705" target="_blank" rel="external">简析TCP的三次握手与四次分手</a></li>
</ul>
<h5 id="1-4-2-3_为什么最后还要等待两个时间周期呢？">1.4.2.3 为什么最后还要等待两个时间周期呢？</h5><h3 id="1-5_负责域名解析的_DNS_服务">1.5  负责域名解析的 DNS 服务</h3><p>DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。</p>
<h3 id="1-6_各种协议与_HTTP_协议的关系">1.6 各种协议与 HTTP 协议的关系</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-1.6.jpg" alt=""></p>
<h3 id="1-7_URI_和_URL">1.7  URI 和 URL</h3><p>URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。<br>URL 是 URI 的子集。<br>区别就是 URI 定义资源，而 URL 不单定义这个资源，还定义了如何找到这个资源（既访问资源的方式）。</p>
<p>详情参见：</p>
<ul>
<li><a href="http://www.cnblogs.com/youmeng/p/4891788.html" target="_blank" rel="external">Http权威指南笔记(一) URI URL URN 关系</a></li>
</ul>
<hr>
<h2 id="第_2_章_简单的_HTTP_协议">第 2 章  简单的 HTTP 协议</h2><h3 id="2-1_HTTP_请求和响应报文格式">2.1  HTTP 请求和响应报文格式</h3><p>HTTP 请求报文由请求行、请求头部、空行和请求包体 4 个部分组成，如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-2.1.1.jpg" alt=""></p>
<p>HTTP 响应报文由状态行、响应头部、空行和响应包体 4 个部分组成，如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-2.1.2.jpg" alt=""></p>
<p>详情参见：</p>
<ul>
<li><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/28/2612910.html" target="_blank" rel="external">HTTP请求报文和HTTP响应报文</a></li>
</ul>
<h3 id="2-2_告知服务器意图的_HTTP_方法">2.2  告知服务器意图的 HTTP 方法</h3><p>表 2-1：HTTP/1.0 和 HTTP/1.1 支持的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">支持的 HTTP 协议版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td style="text-align:center">获取资源</td>
<td style="text-align:center">1.0、1.1</td>
</tr>
<tr>
<td>POST</td>
<td style="text-align:center">传输实体主体</td>
<td style="text-align:center">1.0、1.1</td>
</tr>
<tr>
<td>PUT</td>
<td style="text-align:center">传输文件</td>
<td style="text-align:center">1.0、1.1</td>
</tr>
<tr>
<td>HEAD</td>
<td style="text-align:center">获得报文首部</td>
<td style="text-align:center">1.0、1.1</td>
</tr>
<tr>
<td>DELETE</td>
<td style="text-align:center">删除文件</td>
<td style="text-align:center">1.0、1.1</td>
</tr>
<tr>
<td>OPTIONS</td>
<td style="text-align:center">询问支持的方法</td>
<td style="text-align:center">1.1</td>
</tr>
<tr>
<td>TRACE</td>
<td style="text-align:center">追踪路径</td>
<td style="text-align:center">1.1</td>
</tr>
<tr>
<td>CONNECT</td>
<td style="text-align:center">要求用隧道协议连接代理</td>
<td style="text-align:center">1.1</td>
</tr>
<tr>
<td>LINK</td>
<td style="text-align:center">建立和资源之间的联系</td>
<td style="text-align:center">1.0</td>
</tr>
<tr>
<td>UNLINK</td>
<td style="text-align:center">断开连接关系</td>
<td style="text-align:center">1.0</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="第_3_章_HTTP_报文内的_HTTP_信息">第 3 章  HTTP 报文内的 HTTP 信息</h2><h3 id="3-1_编码提升传输速率">3.1  编码提升传输速率</h3><h4 id="3-1-1_压缩传输的内容编码">3.1.1  压缩传输的内容编码</h4><p>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-3.1.1.jpg" alt=""></p>
<p>常用的内容编码有以下几种：</p>
<ol>
<li>gzip（GNU zip）</li>
<li>compress（UNIX 系统的标准压缩）</li>
<li>deflate（zlib）</li>
<li>identity（不进行编码）</li>
</ol>
<h4 id="3-1-2_分割发送的分块传输编码">3.1.2  分割发送的分块传输编码</h4><p>在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/http-3.1.2.jpg" alt=""></p>
<h3 id="3-2_获取部分内容的范围请求">3.2  获取部分内容的范围请求</h3><p>执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。</p>
<p>针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>由于最近一段时间在找实习，所以陆陆续续面试了几家公司，可结果都跪了….</p>
<p>总结失败的原因有很多，如果要进行个排名的话，<strong>网络</strong>一定能进前三。每每被面试官问到网络相关知识的时候，我都是一脸懵逼样，支支吾吾说不出个所以然。</p>
<p>现在想想，做移动端也有些日子了，可网络知识这块居然只知胜少，究其原因就是自己不求上进，直到找工作的时候被现实打脸了才恍然醒悟。于是，痛定思痛，决定恶补下网络知识，一番 Google 后，决定以《图解 HTTP》作为入门书籍。当然好记性不如烂笔头，读书笔记是少不了的。</p>]]>
    
    </summary>
    
      <category term="HTTP" scheme="http://itangqi.me/tags/HTTP/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="HTTP" scheme="http://itangqi.me/categories/HTTP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从 NSURLConnection 到 NSURLSession]]></title>
    <link href="http://itangqi.me/2016/04/01/from-nsurlconnection-to-nsurlsession/"/>
    <id>http://itangqi.me/2016/04/01/from-nsurlconnection-to-nsurlsession/</id>
    <published>2016-03-31T16:00:00.000Z</published>
    <updated>2016-04-19T08:53:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>现如今的移动应用开发，网络模块几乎成了标配。如果你是早期 iOS 开发者的话，那么你对 <code>NSURLConnection</code>一定不会陌生。但其操作起来有许多不便，这也使得大家更愿意使用第三方库的解决方案，比如大名鼎鼎的 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a> 你一定有所耳闻。正是因为这一点，苹果随着 iOS 7 的发布，也为开发者带来了改进后的原生网络库支持，那就是 NSURLSession。</p>
<p>今天，就让我来给你道一道从 <code>NSURLConnection</code> 到 <code>NSURLSession</code> 那些你知道和不知道的事。 </p>
<a id="more"></a>
<hr>
<h2 id="NSURLConnection">NSURLConnection</h2><p><code>NSURLConnection</code> 作为 Core Foundation / CFNetwork 框架的 API 之上的一个抽象，在 2003 年，随着第一版的 Safari 的发布就发布了。<code>NSURLConnection</code> 这个名字，实际上是指代的 Foundation 框架的 URL 加载系统中一系列相关联的组件：<code>NSURLRequest</code>、<code>NSURLResponse</code>、<code>NSURLProtocol</code>、 <code>NSURLCache</code>、 <code>NSHTTPCookieStorage</code>、<code>NSURLCredentialStorage</code> 以及同名类 <code>NSURLConnection</code>。</p>
<p><code>NSURLRequest</code> 被传递给 <code>NSURLConnection</code>。被委托对象（遵守以前的非正式协议 <code>&lt;NSURLConnectionDelegate&gt;</code> 和 <code>&lt;NSURLConnectionDataDelegate&gt;</code>）异步地返回一个 <code>NSURLResponse</code> 以及包含服务器返回信息的 <code>NSData</code>。</p>
<p>在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据策略（policy）以及可用性（availability）的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应以便将来的请求可以使用。</p>
<p>在把请求发送给服务器的过程中，服务器可能会发出鉴权查询（authentication challenge），这可以由共享的 cookie 或机密存储（credential storage）来自动响应，或者由被委托对象来响应。发送中的请求也可以被注册的 <code>NSURLProtocol</code> 对象所拦截，以便在必要的时候无缝地改变其加载行为。</p>
<h3 id="使用步骤">使用步骤</h3><h4 id="概览">概览</h4><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/from-nsurlconnection-to-nsurlsession-003.png" alt="">（<a href="http://hayageek.com/ios-nsurlsession-example/" target="_blank" rel="external">图片来自</a>）</p>
<h4 id="NSURL">NSURL</h4><p>创建一个 <code>NSURL</code> 对象，设置请求路径：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"协议://主机地址/路径?参数&amp;参数"</span>];</span><br></pre></td></tr></table></figure>
<p>解释如下：</p>
<ul>
<li>协议：不同的协议，代表着不同的资源查找方式、资源传输方式，比如常用的 HTTP、FTP 等</li>
<li>主机地址：存放资源的主机的 IP 地址（域名）</li>
<li>路径：资源在主机中的具体位置</li>
<li>参数：参数可有可无，也可以多个。如果带参数的话，用 “?” 号后面接参数，多个参数的话之间用 “&amp;” 隔开</li>
</ul>
<h4 id="NSURLRequest">NSURLRequest</h4><p>创建一个 <code>NSURLRequest</code> 对象并传入 <code>NSURL</code>，设置请求头和请求体：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url cachePolicy:<span class="built_in">NSURLRequestUseProtocolCachePolicy</span> timeoutInterval:<span class="number">15.0</span>];</span><br></pre></td></tr></table></figure>
<p>参数解释如下：</p>
<ul>
<li>requestWithURL：资源路径</li>
<li>cachePolicy：缓存策略（无论使用哪种缓存策略，都会在本地缓存数据），类型为枚举类型，取值如下：<ul>
<li>NSURLRequestUseProtocolCachePolicy = 0 // 默认的缓存策略，使用协议的缓存策略</li>
<li>NSURLRequestReloadIgnoringLocalCacheData = 1 // 每次都从网络加载</li>
<li>NSURLRequestReturnCacheDataElseLoad = 2 // 返回缓存否则加载，很少使用</li>
<li>NSURLRequestReturnCacheDataDontLoad = 3 // 只返回缓存，没有也不加载，很少使用</li>
</ul>
</li>
<li>timeoutInterval：超时时长，默认 60s</li>
</ul>
<p>另外，还可以设置其它一些信息，比如请求头，请求体等等，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 告诉服务器数据为 JSON 类型</span></span><br><span class="line">[request setValue:<span class="string">@"application/json"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>]; </span><br><span class="line"><span class="comment">// 设置请求体（JSON类型）</span></span><br><span class="line"><span class="built_in">NSData</span> *jsonData = [<span class="built_in">NSJSONSerialization</span> dataWithJSONObject:@&#123;<span class="string">@"userid"</span>:<span class="string">@"123456"</span>&#125; options:<span class="built_in">NSJSONWritingPrettyPrinted</span> error:<span class="literal">nil</span>];</span><br><span class="line">request<span class="variable">.HTTPBody</span> = jsonData;</span><br></pre></td></tr></table></figure>
<p>注意，上面的 request 应为 <code>NSMutableURLRequest</code>，即可变类型。（使用 POST 请求的话，那么就必须的使用 <code>NSMutableURLRequest</code>）</p>
<h4 id="NSURLConnection-1">NSURLConnection</h4><p>使用 <code>NSURLConnection</code> 发送请求，通过返回 <code>NSURLResponse</code> 实例和 <code>NSError</code> 实例分析结果，接受服务器返回数据。</p>
<p><code>NSURLConnection</code> 默认的请求类型为 GET，下面分异步和同步介绍 GET 的使用（POST 会在 <code>NSURLSession</code> 中介绍）。</p>
<h5 id="异步请求">异步请求</h5><p>异步是指：在发送请求之后，一边在子线程中接收返回数据，一边执行之后的代码，当返回数据接收完毕后，采用回调的方式通知主线程做处理。同时，异步请求有两种实现方式。</p>
<p>1.使用 block：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[[<span class="built_in">NSOperationQueue</span> alloc] init] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line">    <span class="comment">// 有的时候，服务器访问正常，但是会没有数据</span></span><br><span class="line">    <span class="comment">// 以下的 if 是比较标准的错误处理代码</span></span><br><span class="line">    <span class="keyword">if</span> (connectionError != <span class="literal">nil</span> || data == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//给用户的提示信息</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"网络不给力"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>参数说明如下：</p>
<ul>
<li>completionHandler:请求响应后（或者请求超时）执行的代码，queue 为代码添加到的队列，即 block执行的线程<ul>
<li>NSURLResponse 为服务器的响应，真实类型为 NSHTTPURLResponse，通常只在「下载」功能时，才会使用；下面是协议头的参数：<ul>
<li>URL：响应的 URL，有的时候，访问一个 URL 地址，服务器可能会出现重定向，会定位到新的地址</li>
<li>MIMEType（Content-Type）：服务器告诉客户端，可以用什么软件打开二进制数据。网络之所以丰富多采，是因为有丰富的客户端软件。栗子：Windows 上提示安装 Flash 插件</li>
<li>expectedContentLength：预期的内容长度，要下载的文件长度，下载文件时非常有用</li>
<li>suggestedFilename：「建议」的文件名，方便用户直接保存，很多时候，用户并不关心要保存成什么名字</li>
<li>textEncodingName：文本的编码名称 @”UTF8”，大多数都是 UTF8</li>
<li>statusCode：状态码，在做下载操作的时候，需要判断一下</li>
<li>allHeaderFields：所有的响应头字典时候，用户并不关心要保存成什么名字</li>
</ul>
</li>
</ul>
</li>
<li>NSData：服务器返回的数据，例如：JSON、XML</li>
<li>NSError：网络访问错误码</li>
</ul>
<p>2.使用代理（Delegate）:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()&lt;<span class="title">NSURLConnectionDataDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> * url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://itangqi.me"</span>];</span><br><span class="line"><span class="built_in">NSURLRequest</span> * request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line">[<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>];</span><br></pre></td></tr></table></figure>
<p>使用代理可以监测下载过程：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123;</span><br><span class="line">    <span class="comment">// 开始接收数据</span></span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="comment">// 正在接收数据(会调用多次)</span></span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    <span class="comment">// 接收数据失败</span></span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection &#123;</span><br><span class="line">    <span class="comment">// 接收数据完成(成功|失败)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="同步">同步</h5><p>同步是指：数据的请求在主线程来执行，一旦发送同步请求，直至服务器返回数据完成，才可以进行下一步操作，而网络数据加载需要一个时间过程，这样的话就会堵塞主线程，当然这种使用场景很少。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步请求，代码会阻塞在这里一直等待服务器返回，如果 data 为 nil 则请求失败，当获取少量数据时可以使用此方法。</span></span><br><span class="line"><span class="comment">// request 参数同上。</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="NSURLSession">NSURLSession</h2><p>不管怎样，<code>NSURLConnection</code> 作为网络基础架构，已经服务了成千上万的 iOS 和 Mac OS 程序，并且做的还算相当不错。但是这些年，一些用例——尤其是在 iPhone 和 iPad 上面——已经对 <code>NSURLConnection</code> 的几个核心概念提出了挑战，让苹果有理由对它进行重构。</p>
<p>在 2013 的 WWDC 上，苹果推出了 <code>NSURLConnection</code> 的继任者：<code>NSURLSession</code>。</p>
<p>和 <code>NSURLConnection</code> 一样，<code>NSURLSession</code> 指的也不仅是同名类 <code>NSURLSession</code>，还包括一系列相互关联的类。<code>NSURLSession</code> 包括了与之前相同的组件，<code>NSURLRequest</code> 与 <code>NSURLCache</code>，但是把 <code>NSURLConnection</code> 替换成了 <code>NSURLSession</code>、<code>NSURLSessionConfiguration</code> 以及 <code>NSURLSessionTask</code> 的 3 个子类：<code>NSURLSessionDataTask</code>，<code>NSURLSessionUploadTask</code>，<code>NSURLSessionDownloadTask</code>。</p>
<p>与 <code>NSURLConnection</code> 相比，<code>NSURLsession</code> 最直接的改进就是可以配置每个 session 的缓存，协议，cookie，以及证书策略（credential policy），甚至跨程序共享这些信息。这将允许程序和网络基础框架之间相互独立，不会发生干扰。每个 <code>NSURLSession</code> 对象都由一个 <code>NSURLSessionConfiguration</code> 对象来进行初始化，后者指定了刚才提到的那些策略以及一些用来增强移动设备上性能的新选项。</p>
<p><code>NSURLSession</code> 中另一大块就是 session task。它负责处理数据的加载以及文件和数据在客户端与服务端之间的上传和下载。<code>NSURLSessionTask</code> 与 <code>NSURLConnection</code> 最大的相似之处在于它也负责数据的加载，最大的不同之处在于所有的 task 共享其创造者 <code>NSURLSession</code> 这一公共委托者（common delegate）。</p>
<p>我们先来深入探讨 task，过后再来讨论 <code>NSURLSessionConfiguration</code>。</p>
<h3 id="概览-1">概览</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/from-nsurlconnection-to-nsurlsession-002.png" alt="">（<a href="http://hayageek.com/ios-nsurlsession-example/" target="_blank" rel="external">图片来自</a>）</p>
<h3 id="Sessions">Sessions</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用静态的 sharedSession 的方法，该类使用共享的 seesion，该 seesion 使用全局的 Cache，Cookie 和证书</span></span><br><span class="line">+ (<span class="built_in">NSURLSession</span> *)sharedSession;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 NSURLSessionConfiguration 创建对应配置的 seesion</span></span><br><span class="line">+ (<span class="built_in">NSURLSession</span> *)sessionWithConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 也是根据 NSURLSessionConfiguration 创建对应配置的 seesion，并且可以指定 seesion 的委托和委托所处的队列</span></span><br><span class="line">+ (<span class="built_in">NSURLSession</span> *)sessionWithConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration delegate:(<span class="keyword">id</span> &lt;<span class="built_in">NSURLSessionDelegate</span>&gt;)delegate delegateQueue:(<span class="built_in">NSOperationQueue</span> *)queue;</span><br></pre></td></tr></table></figure>
<h3 id="NSURLSessionTask">NSURLSessionTask</h3><p><code>NSURLSession</code> 本身是不会进行请求的，而是通过创建 task 的形式进行网络请求，同一个 NSURLSession 可以创建多个 task，并且这些 task 之间的 cache 和 cookie 是共享的。那么我们就来看看 NSURLSession 都能创建哪些 task 吧。</p>
<p>Task 可以翻译为任务，那么在和网络请求相关的任务中，我们可以理解为：数据请求任务、下载任务、上传任务等。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/from-nsurlconnection-to-nsurlsession-001.png" alt=""></p>
<p>其实从类名就能猜出它们各自的用途：</p>
<ol>
<li><p><code>NSURLSessionDataTask</code>：使用这个 task 来调用 HTTP GET 方式请求，从服务器获取数据到内存。返回的数据格式是 NSData，可根据需要自行转换成 XML、JSON 等数据格式</p>
</li>
<li><p><code>NSURLSessionUploadTask</code>：使用这个 task 来上传磁盘文件到 web 服务器，典型地通过 HTTP POST 或者 PUT 方式</p>
</li>
<li><p><code>NSURLSessionDownloadTask</code>：使用这个 task 来从远程服务器下载文件到临时文件地址</p>
</li>
<li><p><code>NSURLSessionStreamTask</code>：使用这个 task 来执行异步的读和写</p>
</li>
</ol>
<p>你也能暂停，恢复（开始）和取消 tasks。</p>
<h4 id="NSURLSessionDataTask_POST">NSURLSessionDataTask POST</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  简单 Post 请求，POST 和 GET 请求在于对 request 的处理不同，其余和 GET 相同</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)postWithSharedSession &#123;</span><br><span class="line">  <span class="comment">// 获取默认 Session</span></span><br><span class="line">  <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line">  <span class="comment">// 创建 URL</span></span><br><span class="line">  <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://120.25.226.186:32812/login"</span>];</span><br><span class="line">  <span class="comment">// 创建 request</span></span><br><span class="line">  <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">  <span class="comment">// 请求方法</span></span><br><span class="line">  request<span class="variable">.HTTPMethod</span> = <span class="string">@"POST"</span>;</span><br><span class="line">  <span class="comment">// 请求体</span></span><br><span class="line">  request<span class="variable">.HTTPBody</span> = [<span class="string">@"username=1234&amp;pwd=4321"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">  <span class="comment">// 创建任务 task</span></span><br><span class="line">  <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">  <span class="comment">// 获取数据后解析并输出</span></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]);</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="comment">// 启动任务</span></span><br><span class="line">  [task resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NSURLSessionDataDelegate_代理方法">NSURLSessionDataDelegate 代理方法</h4><p><code>NSURLSession</code> 提供了 block 的方式处理返回的数据，但是如果我们想要在接收数据的过程中处理数据，我们可以使用 <code>NSURLSessionDataDelegate</code> 的代理方法，分为接收响应、接收数据和请求完成三个阶段。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)sessionDataDelegate &#123;</span><br><span class="line"> <span class="comment">// 创建带有代理方法的自定义 session</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 创建任务</span></span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://120.25.226.186:32812/login?username=1234&amp;pwd=4321"</span>]]];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 启动任务</span></span><br><span class="line">[task resume];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1. 接受到服务器的响应</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span>))completionHandler &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"任务完成"</span>);</span><br><span class="line">  <span class="comment">// 必须设置对响应进行允许处理才会执行后面两个操作。</span></span><br><span class="line">  completionHandler(<span class="built_in">NSURLSessionResponseAllow</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2. 接收到服务器的数据（可能调用多次）</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">  <span class="comment">// 处理每次接收的数据</span></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3. 请求成功或者失败（如果失败，error有值）</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    <span class="comment">// 请求完成,成功或者失败的处理</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"SessionTask %s"</span>,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSURLSessionConfiguration">NSURLSessionConfiguration</h3><p><code>NSURLSessionConfiguration</code> 对象用于对 <code>NSURLSession</code> 对象进行初始化。从指定可用网络，到 cookie，安全性，缓存策略，再到使用自定义协议，启动事件的设置，以及用于移动设备优化的几个新属性，你会发现使用 <code>NSURLSessionConfiguration</code> 可以找到几乎任何你想要进行配置的选项。其有三个类工厂方法：</p>
<ol>
<li><p>默认模式（+defaultSessionConfiguration）：返回一个标准的 configuration，工作模式类似于 NSURLConnection，可以使用缓存的 Cache，Cookie，证书（credential）</p>
</li>
<li><p>及时模式（+ephemeralSessionConfiguration）: 临时 session 配置，与默认配置相比，这个配置不会使用缓存的 Cache，Cookie，证书，只会存在内存里，所以当程序退出时，所有的数据都会消失，这对于实现像秘密浏览这种功能来说是很理想的</p>
</li>
<li><p>后台模式（+backgroundSessionConfiguration）：它会创建一个后台 session。后台 session 不同于常规的，普通的 session，它甚至可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的守护进程（daemon）提供上下文</p>
</li>
</ol>
<p>除了这三种预设的模式之外 <code>NSURLSessionConfiguration</code> 还可以进行很多的配置。 <code>timeoutIntervalForRequest</code> 和 <code>timeoutIntervalForResource</code> 可以控制网络操作的超时时间。 <code>allowsCellularAccess</code> 属性可以控制是否允许使用无线网络。<code>HTTPAdditionalHeaders</code> 可以指定 HTTP 请求头。</p>
<p><code>NSURLSessionConfiguration</code> 几乎可以完成网络操作的大多数配置功能，并且这些配置都绑定到当前的 Session 中，我们一旦用配置好的 <code>NSURLSessionConfiguration</code> 初始化 <code>NSURLSession</code> 实例后，就不能修改这个 <code>NSURLSession</code> 相关的配置了。所以，一切的配置操作都放在初始化 <code>NSURLSession</code> 之前。</p>
<hr>
<h2 id="iOS_9">iOS 9</h2><ol>
<li><p>在 iOS 7 后，苹果推荐使用 <code>NSURLSession</code>，并在 iOS 9 中废弃了 <code>NSURLConnection</code> </p>
</li>
<li><p>iOS 9 所有网络连接默认为 HTTPS 服务，为此推出 App Transport Security，详情可参见：<a href="https://developer.apple.com/videos/play/wwdc2015/711/" target="_blank" rel="external">Networking with NSURLSession</a></p>
</li>
</ol>
<hr>
<h2 id="NSURLConnection_vs-_NSURLSession">NSURLConnection vs. NSURLSession</h2><ol>
<li><p>后台上传和下载：只需在创建 <code>NSURLSession</code> 的时候配置一个选项，就能得到后台网络的所有好处。这样可以延长电池寿命，并且还支持 UIKit 的多 task，在进程间使用相同的委托模型</p>
</li>
<li><p>能够暂停和恢复网络操作：使用 NSURLSession API 能够暂停，停止，恢复所有的网络任务，再也完全不需要子类化 NSOperation</p>
</li>
<li><p>可配置的容器：对于 <code>NSURLSession</code> 里面的 requests 来说，每个<code>NSURLSession</code> 都是可配置的容器。举个例来说，假如你需要设置 HTTP header 选项，你只用做一次，session 里面的每个 request 就会有同样的配置</p>
</li>
<li><p>提高认证处理：认证是在一个指定的连接基础上完成的。在使用 <code>NSURLConnection</code> 时，如果发出一个访问，会返回一个任意的 request。此时，你就不能确切的知道哪个 request 收到了访问。而在 NSURLSession 中，就能用代理处理认证</p>
</li>
<li><p>丰富的代理模式：在处理认证的时候，<code>NSURLConnection</code> 有一些基于异步的 block 方法，但是它的代理方法就不能处理认证，不管请求是成功或是失败。在 <code>NSURLSession</code> 中，可以混合使用代理和 block 方法处理认证</p>
</li>
<li><p>上传和下载通过文件系统：它鼓励将数据（文件内容）从元数据（URL 和 settings）中分离出来</p>
</li>
</ol>
<h2 id="要点">要点</h2><ol>
<li><p>请求的缓存策略使用 <code>NSURLRequestReloadIgnoringCacheData</code>，忽略本地缓存</p>
</li>
<li><p>服务器响应结束后，要记录 Etag，服务器内容和本地缓存对比是否变化的重要依据</p>
</li>
<li><p>在发送请求时，设置 If-None-Match，并且传入 etag</p>
</li>
<li><p>连接结束后，要判断响应头的状态码，如果是 304，说明本地缓存内容没有发生变化，此时可以使用本地缓存来加载数据，如果缓存文件被意外删除，程序依然运行但会报错，加载数据也失败</p>
</li>
<li><p>GET 缓存的数据会保存在 Cache 目录中 /bundleId 下，Cache.db 中</p>
</li>
</ol>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLConnection_Class/" target="_blank" rel="external">NSURLConnection Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/" target="_blank" rel="external">NSURLSession Class Reference</a></li>
<li><a href="https://www.objc.io/issues/5-ios7/from-nsurlconnection-to-nsurlsession/" target="_blank" rel="external">From NSURLConnection to NSURLSession</a></li>
<li><a href="http://www.cnblogs.com/mddblog/p/5134783.html" target="_blank" rel="external">iOS网络1——NSURLConnection使用详解</a></li>
<li><a href="http://blog.qiji.tech/archives/6454" target="_blank" rel="external">[iOS] NSURLSession</a></li>
<li><a href="http://swiftcafe.io/2015/12/20/nsurlsession/" target="_blank" rel="external">NSURLSession 网络库 - 原生系统送给我们的礼物</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>现如今的移动应用开发，网络模块几乎成了标配。如果你是早期 iOS 开发者的话，那么你对 <code>NSURLConnection</code>一定不会陌生。但其操作起来有许多不便，这也使得大家更愿意使用第三方库的解决方案，比如大名鼎鼎的 <a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a> 你一定有所耳闻。正是因为这一点，苹果随着 iOS 7 的发布，也为开发者带来了改进后的原生网络库支持，那就是 NSURLSession。</p>
<p>今天，就让我来给你道一道从 <code>NSURLConnection</code> 到 <code>NSURLSession</code> 那些你知道和不知道的事。 </p>]]>
    
    </summary>
    
      <category term="NSURLConnection" scheme="http://itangqi.me/tags/NSURLConnection/"/>
    
      <category term="NSURLSession" scheme="http://itangqi.me/tags/NSURLSession/"/>
    
      <category term="Networking" scheme="http://itangqi.me/tags/Networking/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 多线程编程之 NSOperation]]></title>
    <link href="http://itangqi.me/2016/03/28/the-notes-of-learning-nsoperation/"/>
    <id>http://itangqi.me/2016/03/28/the-notes-of-learning-nsoperation/</id>
    <published>2016-03-27T16:00:00.000Z</published>
    <updated>2016-04-19T08:48:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>我们在<a href="http://itangqi.me/2016/03/15/the-notes-of-learning-of-gcd/">《Objective-C 高级编程》读书笔记之 GCD</a> 中，已经学习了多线程编程技术之一 GCD，其简洁易用的特性，我相信你一定深有体会。但即使这样，GCD 也很难满足现实中所有的需求。不过你不用担心，苹果早已为我们提供了另一多线程编程技术，那就是 NSOperation。</p>
<a id="more"></a> 
<hr>
<h2 id="NSOperation">NSOperation</h2><p>以下摘自苹果官方文档：</p>
<blockquote>
<p>The NSOperation class is an abstract class you use to encapsulate the code and data associated with a single task. Because it is abstract, you do not use this class directly but instead subclass or use one of the system-defined subclasses (NSInvocationOperation or NSBlockOperation) to perform the actual task…</p>
</blockquote>
<p>这里只摘录了部分，更详细的内容请移步：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/" target="_blank" rel="external">NSOperation Class Reference</a>。</p>
<p><code>NSOperation</code> 是一个抽象类，你可以用它来封装一个任务的相关代码和数据。因为它是个抽象类，所以你不能直接使用它，而是需要继承并实现其子类或者使用系统内置的两个子类（<code>NSInvocationOperation</code> 和 <code>NSBlockOperation</code>）来执行实际的线程任务。</p>
<p>一个操作（operation）对象是一个<strong>一次性</strong>对象，也就是说，它包含的任务只能执行一次，执行完毕之后就不能再执行了。通常情况下，你只需要把需要执行的 operations 加入到一个操作队列（operation queue - 它是 <code>NSOperationQueue</code> 类的一个实例）即可执行。一个 operation queue 要么直接在二级线程（secondary threads）执行 operations，要么间接的使用 libdispatch 库（熟知的 GCD）来执行 operations。</p>
<p>如果不想使用 operation queue，你也可以在代码中通过直接调用 <code>Operation</code> 自己的 <code>start</code> 方法来执行。手动执行 operations 通常会加重代码负担，因为执行一个不在准备状态（ready state）的 operation 会触发异常，这个 <code>ready</code> 属性就是来反应这个 operation 是否准备就绪的。</p>
<hr>
<h2 id="NSOperationQueue">NSOperationQueue</h2><p>以下摘自苹果官方文档：</p>
<blockquote>
<p>The NSOperationQueue class regulates the execution of a set of NSOperation objects. After being added to a queue, an operation remains in that queue until it is explicitly canceled or finishes executing its task. Operations within the queue (but not yet executing) are themselves organized according to priority levels and inter-operation object dependencies and are executed accordingly. An application may create multiple operation queues and submit operations to any of them…</p>
</blockquote>
<p>更详细的内容请移步：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperationQueue_class/" target="_blank" rel="external">NSOperationQueue Class Reference</a>。</p>
<p><code>NSOperationQueue</code> 类管理着一组 <code>NSOperation</code> 对象的执行，当一个 operation 对象被加入到队列后，它会始终保留在队列中，直到它已经明确的被取消或者完成执行任务。Operations 在队列内（但尚未执行），它们是根据优先级和互相依赖进行组织的，相应的去执行。一个应用可以创建多个操作队列（operation queues）并提交操作（operations）到其中任何一个中。</p>
<p>我相信，熟悉 GCD 的同学，一定不会对<strong>队列</strong>感到陌生，现在看 <code>NSOperationQueue</code> 有木有很亲切~哈哈</p>
<h2 id="使用">使用</h2><p>NSOperation 的基本使用非常简单和易于理解：</p>
<ol>
<li>创建 NSOperation 对象（使用子类），定义需要的操作</li>
<li>创建 NSOperationQueue 对象（操作队列）</li>
<li>将任务添加到操作队列中</li>
</ol>
<p>此时，操作队列会立刻在一条新线程中开始自动执行操作。</p>
<p>创建操作队列和添加任务：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建操作队列</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line"><span class="comment">// 添加任务</span></span><br><span class="line">[queue addOperation:operation];</span><br><span class="line"><span class="comment">// 直接添加任务到队列</span></span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="comment">// 任务</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> <code>NSOperation</code> 类自身有个 <code>– (void)start</code> 方法，调用后也会执行操作，但是它会默认在当前线程同步执行，一般我们不会这么使用，而是添加到 <code>NSOperationQueue</code> 中。</p>
<h3 id="NSInvocationOperation">NSInvocationOperation</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 NSInvocationOperation 对象，task 为调用方法，object 为方法参数</span></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *invocationOperation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(task) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)task&#123;</span><br><span class="line">    <span class="comment">// 具体操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSBlockOperation">NSBlockOperation</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 NSBlockOperation 对象</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="comment">// 具体操作</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>NSBlockOperation 拥有一个 <code>addExecutionBlock:</code> 的实例方法，可以给指定的 NSBlockOperation 对象添加多个执行用 Block，这些 Block 将会并发执行（其他线程中执行）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 addExecutionBlock: 方法添加操作</span></span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">    <span class="comment">// 具体操作</span></span><br><span class="line">&#125;];</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">    <span class="comment">// 具体操作</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="NSOperation_vs-_GCD">NSOperation vs. GCD</h2><p>GCD 是一个低层次的 C API，能让开发者并行执行任务。与之相对，Operation queues 是对队列模型的高层级抽象，NSOperation 是在 Cocoa 框架下基于 GCD 的封装，相对于 GCD 来说可控性更强，并且加入了一些方便的功能（取消任务、设置依赖、设置最大并发等等）。GCD 中的关键概念 —— 任务和队列，正好对应了 <code>NSOperation</code> 和 <code>NSOperationQueue</code> 两个类，因此在开始 NSOperation 的学习之前，我建议先对 GCD 的基本思想和核心概念有所掌握。</p>
<p>同时，我也知道，NSOperation 是对 GCD 更高层次的封装，所以它有着一些 GCD 无法实现（或者至少说很难实现）的特性，下面就让我们一起来看一看：</p>
<h3 id="取消任务">取消任务</h3><p>当一个 operation 开始执行后，它会一直执行它的任务直到完成或被取消为止。我们可以在任意时间点取消一个 operation ，甚至是在它还未开始执行之前。为了让我们自定义的 operation 能够支持取消事件，我们需要在代码中定期地检查 isCancelled 方法的返回值，一旦检查到这个方法返回 YES ，我们就需要立即停止执行接下来的任务。根据苹果官方的说法，isCancelled 方法本身是足够轻量的，所以就算是频繁地调用它也不会给系统带来太大的负担。</p>
<blockquote>
<p>The isCancelled method itself is very lightweight and can be called frequently without any significant performance penalty.</p>
</blockquote>
<p>通常来说，当我们自定义一个 operation 类时，我们需要考虑在以下几个关键点检查 isCancelled 方法的返回值：</p>
<ul>
<li>在真正开始执行任务之前；</li>
<li>至少在每次循环中检查一次，而如果一次循环的时间本身就比较长的话，则需要检查得更加频繁；</li>
<li>在任何相对来说比较容易中止 operation 的地方。</li>
</ul>
<p>看到这里，我想你应该可以意识到一点，那就是尽管 operation 是支持取消操作的，但却并不是立即取消的，而是在你调用了 operation 的 cancel 方法之后的下一个 isCancelled 的检查点取消的。</p>
<p>也就是说，通过调用 NSOperation 类的 cancel 方法来实现对 operation 的取消。你取消任何 operation 的时候，会是下面三种场景之一：</p>
<ol>
<li>你的 operation 已经完成了，这种情况下 cancel 方法没有任何效果</li>
<li>你的 operation 正在被执行的过程中，这种情况下系统不会强制停止你的 operation 代码，而是将 cancelled 属性置为 true</li>
<li>你的 operation 还在队列中等待被执行，这种情况下你的 operation 就不会被执行</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///  支持取消操作</span></span><br><span class="line">- (<span class="keyword">void</span>)main &#123;</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Start executing %@ with data: %@, mainThread: %@, currentThread: %@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd), <span class="keyword">self</span><span class="variable">.data</span>, [<span class="built_in">NSThread</span> mainThread], [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Loop %@"</span>, @(i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Finish executing %@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span>(<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Exception: %@"</span>, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置依赖">设置依赖</h3><p>通过依赖我们可以设置不同任务间的关系，并确定它们的执行顺序。不过需要注意的是，不正确地设置依赖关系，很可能会出现循环依赖，导致死锁。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> 假设现在有 2 个下载任务：downloadOperation1、downloadOperation2</span><br><span class="line"> 另有一编辑任务：editOperation</span><br><span class="line"> 编辑任务需要等所有下载完成后开始执行，那么可以进行如下设置</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// 依赖关系如下设置</span></span><br><span class="line">[editOperation addDependency:downloadOperation1];</span><br><span class="line">[editOperation addDependency:downloadOperation2];</span><br></pre></td></tr></table></figure>
<p>既然可以设置依赖，当然也可以移除依赖，只要使用<code>removeDependency:</code> 方法即可。</p>
<h3 id="设置优先级">设置优先级</h3><p>在 GCD 中，队列具有优先级（共有 4 级），而任务（block）则没有优先级的概念。NSOperation 则正好与之相反，我们可以设置 operation 的优先级。</p>
<p><code>NSOperation</code> 有一个 <code>NSOperationQueuePriority</code> 枚举类型的属性 <code>queuePriority</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSOperationQueuePriority</span>) &#123;</span><br><span class="line">true<span class="built_in">NSOperationQueuePriorityVeryLow</span> = -<span class="number">8</span>L,</span><br><span class="line">true<span class="built_in">NSOperationQueuePriorityLow</span> = -<span class="number">4</span>L,</span><br><span class="line">true<span class="built_in">NSOperationQueuePriorityNormal</span> = <span class="number">0</span>,</span><br><span class="line">true<span class="built_in">NSOperationQueuePriorityHigh</span> = <span class="number">4</span>,</span><br><span class="line">true<span class="built_in">NSOperationQueuePriorityVeryHigh</span> = <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSOperationQueuePriority</span> queuePriority;</span><br></pre></td></tr></table></figure>
<h3 id="设置并发数">设置并发数</h3><p>NSOperationQueue 的属性表示当前队列中最多可运行的线程数。默认为 -1，即不限数，由系统内存和 CPU 决定线程数量。设为 1 的话就相当于 GCD 的串行队列。如需自定义，作为移动端开发，一般以 3 以内为宜，因为虽然任务是在子线程进行处理的，但是 CPU 处理这些过多的子线程可能会影响 UI，让 UI 变卡。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置最大并发数为 5</span></span><br><span class="line">[queue setMaxConcurrentOperationCount:<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="补充">补充</h2><h3 id="任务完成回调">任务完成回调</h3><p>如果我们想在一个 NSOperation 任务执行完毕后做一些后续操作，可以调用 NSOperation 的 <code>completionBlock</code> 属性来实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点语法</span></span><br><span class="line">operation<span class="variable">.completionBlock</span> = ^() &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"任务执行完毕"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 消息语法</span></span><br><span class="line">[operation setCompletionBlock:^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"任务执行完毕"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="-_(void)start;"><code>- (void)start;</code></h3><p>官方文档中有提到过，当我们不想使用 <code>NSOperationQueue</code> 执行任务时，可以调用 <code>- (void)start;</code> 方法（尽管并不建议这么做），但仍然有些要点需要你知道：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;        </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Execute task one in %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Execute task two in %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Execute task three in %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">[blockOperation addExecutionBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Execute task four in %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line">[blockOperation start];</span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3.0</span>];</span><br></pre></td></tr></table></figure>
<p>以上代码会得到这样的执行结果：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Execute task one <span class="keyword">in</span> &lt;<span class="built_in">NSThread</span>: <span class="number">0x100606090</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">Execute task four <span class="keyword">in</span> &lt;<span class="built_in">NSThread</span>: <span class="number">0x100100730</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">Execute task two <span class="keyword">in</span> &lt;<span class="built_in">NSThread</span>: <span class="number">0x100102370</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line">Execute task three <span class="keyword">in</span> &lt;<span class="built_in">NSThread</span>: <span class="number">0x100104630</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>所以，通过直接调用 <code>- (void)start;</code> 方法所执行的 operation，其任务会在<strong>主线程</strong>中执行，而随后通过 <code>addExecutionBlock:</code> 方法添加的任务（block）则是并发执行的。</p>
<h3 id="Block_循环引用">Block 循环引用</h3><p>通常，我们在控制器中会声明并延迟加载一个 NSOperationQueue 对象而非在需要时临时创建（这样可能会多次创建影响性能）。这时如果以 Block 的方式定制任务，比如下面代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span><span class="variable">.queue</span> addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="comment">// 定义任务</span></span><br><span class="line">    <span class="comment">// 返回主队列执行更新 UI 操作</span></span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">        [<span class="keyword">self</span> update<span class="built_in">UIOperation</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>self 即控制器，其对 Block 产生了强引用，而 Block 中由于调用了 self 的方法也指向了 self，这样就出现了循环引用的问题。</p>
<p>我们的解决方案是使用 <code>__weak</code> 创建一个 self 的弱指针对象：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 self 即控制器的弱指针对象，避免 Block 中的循环引用</span></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.queue</span> addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="comment">// 定义任务</span></span><br><span class="line">    <span class="comment">// 返回主队列执行更新UI操作</span></span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">        [weakSelf update<span class="built_in">UIOperation</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这里要特别提到 <code>completionBlock</code> 这个 Block，前面介绍到它是当 NSOperation 对象执行完毕时调用，此时 NSOperation 对象已经从 self 指向的队列中移除，自然也不会出现循环引用。所以在 <code>completionBlock</code> 中请使用 self 而非它的弱指针对象。</p>
<h3 id="mainQueue">mainQueue</h3><p>通过</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [<span class="built_in">NSOperationQueue</span> mainQueue];</span><br></pre></td></tr></table></figure>
<p>方式创建的 queue 是<strong>串行</strong>的。</p>
<h3 id="Operation_Queue_vs-_Dispatch_Queue">Operation Queue vs. Dispatch Queue</h3><p>与 GCD 不同的是，Operation Queues 并不遵循先进先出（FIFO）的顺序。以下是 Operation Queues 和 Dispatch Queues 的不同：</p>
<ol>
<li><p>不遵循 FIFO（先进先出）：在 Operation Queues 中，你可以设置 operation（操作）的执行优先级，并且可以在 operation 之间添加依赖，这意味着你可以定义某些 operation，使得它们可以在另外一些 operation 执行完毕之后再被执行。这就是为什么它们不遵循先进先出的顺序。</p>
</li>
<li><p>默认情况下 Operation Queues 是并发执行：虽然你不能将其改成串行队列，但还是有一种方法，通过在 operation 之间添加相依性来让 Operation Queues 中的任务按序执行。</p>
</li>
<li><p>Operation Queues 是 NSOperationQueue 类的实例，任务被封装在 NSOperation 的实例中。</p>
</li>
</ol>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperation_class/" target="_blank" rel="external">NSOperation Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSOperationQueue_class/" target="_blank" rel="external">NSOperationQueue Class Reference</a></li>
<li><a href="http://www.appcoda.com/ios-concurrency/" target="_blank" rel="external">iOS Concurrency: Getting Started with NSOperation and Dispatch Queues</a></li>
<li><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></li>
<li><a href="http://blog.qiji.tech/archives/3713" target="_blank" rel="external">iOS中的多线程及NSOperation介绍</a></li>
<li><a href="https://bestswifter.com/multithreadconclusion/" target="_blank" rel="external">iOS多线程编程——GCD与NSOperation总结</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>我们在<a href="http://itangqi.me/2016/03/15/the-notes-of-learning-of-gcd/">《Objective-C 高级编程》读书笔记之 GCD</a> 中，已经学习了多线程编程技术之一 GCD，其简洁易用的特性，我相信你一定深有体会。但即使这样，GCD 也很难满足现实中所有的需求。不过你不用担心，苹果早已为我们提供了另一多线程编程技术，那就是 NSOperation。</p>]]>
    
    </summary>
    
      <category term="NSOperation" scheme="http://itangqi.me/tags/NSOperation/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SDWebImage 源码阅读笔记（四）]]></title>
    <link href="http://itangqi.me/2016/03/24/the-notes-of-learning-sdwebimage-four/"/>
    <id>http://itangqi.me/2016/03/24/the-notes-of-learning-sdwebimage-four/</id>
    <published>2016-03-23T16:00:00.000Z</published>
    <updated>2016-04-25T14:31:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>关于 SDWebImage 整体的架构可以参见下图：</p>
<a id="more"></a> 
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-sdwebimage-four-01.jpeg" alt=""></p>
<p>作为《SDWebImage 源码阅读笔记》系列文章的完结篇，最后想给大家列举几个拓展的知识点（也不知道有用没用=；=）。</p>
<hr>
<h2 id="WebP">WebP</h2><p>SDWebImage 有一特性便是支持 WebP，那 WebP 又是何方神圣呢？</p>
<p>WebP 是由 Google 推出的一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8。根据 Google 的测试，无损压缩后的 WebP 比 PNG 文件少了 45％ 的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少 28％ 的文件大小。</p>
<p>项目主页：<a href="https://developers.google.com/speed/webp/" target="_blank" rel="external">https://developers.google.com/speed/webp/</a></p>
<hr>
<h2 id="NSURLCache">NSURLCache</h2><h3 id="GET_网络请求缓存">GET 网络请求缓存</h3><p>首先要知道，POST 请求不能被缓存，只有 GET 请求能被缓存。因为从数学的角度来讲，GET 的结果是<code>幂等</code>的，就好像字典里的 key 与 value 就是幂等的，而 POST <code>不幂等</code> 。缓存的思路就是将查询的参数组成的值作为 key ，对应结果作为 value。从这个意义上说，一个文件的资源链接，也叫 GET 请求。</p>
<h3 id="80%_的缓存需求：两行代码就可满足">80% 的缓存需求：两行代码就可满足</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLCache</span> *urlCache = [[<span class="built_in">NSURLCache</span> alloc] initWithMemoryCapacity:<span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span> diskCapacity:<span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span> diskPath:<span class="literal">nil</span>];  </span><br><span class="line">[<span class="built_in">NSURLCache</span> setSharedURLCache:urlCache];</span><br></pre></td></tr></table></figure>
<p>不过呢：</p>
<p><strong>SDWebImage 中默认是不使用 <code>NSURLCache</code> 的，取而代之是使用自己实现的缓存逻辑….</strong></p>
<p><strong>而网络库方面大名鼎鼎的 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a> 则正是使用的 NSURLCache。</strong></p>
<p>至于孰优孰劣也就仁者见仁智者见智了。</p>
<p>更多详情：</p>
<ul>
<li><a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/02_Parse%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E4%B8%8E%E7%A6%BB%E7%BA%BF%E5%AD%98%E5%82%A8/iOS%E7%BD%91%E7%BB%9C%E7%BC%93%E5%AD%98%E6%89%AB%E7%9B%B2%E7%AF%87.md" target="_blank" rel="external">iOS网络缓存扫盲篇</a></li>
<li><a href="http://www.cnblogs.com/madpanda/p/4700741.html" target="_blank" rel="external">iOS网络——NSURLCache设置网络请求缓存</a></li>
<li><a href="https://github.com/rs/SDWebImage/wiki/How-is-SDWebImage-better-than-X%3F" target="_blank" rel="external">How is SDWebImage better than X?</a></li>
</ul>
<hr>
<h2 id="LRU">LRU</h2><p>在<a href="http://itangqi.me/2016/03/21/the-notes-of-learning-sdwebimage-two/">《SDWebImage 源码阅读笔记（二）》</a>中，我们知道，SDWebImage 的图片清理机制（磁盘）是，删除过期时间的缓存（每次一半的递归来移除那些过早的文件）。</p>
<p>在一次面试中，面试官问及是否可以提供其他的淘汰策略时，我提到了 LRU（近期最少使用算法），不过当要求说出算法的具体实现时，自己又懵逼了……</p>
<p>下面是来自 SDWebImage 的文档页截图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/CocoaDocs.org%20%20%20SDWebImage%20Referethe-notes-of-learning-sdwebimage-four-02.png" alt=""></p>
<p>可以看出，LRU 是没错的，下面就来关心下如何设计吧：</p>
<p>LRU 的典型实现是 Hash Map + Doubly Linked List，双向链表用于存储数据结点，并且它是按照结点最近被使用的时间来存储的。如果一个结点被访问了，我们有理由相信它在接下来的一段时间被访问的概率要大于其它结点。于是，我们把它放到双向链表的头部。当我们往双向链表里插入一个结点，我们也有可能很快就会使用到它，同样把它插入到头部。我们使用这种方式不断地调整着双向链表，链表尾部的结点自然也就是最近一段时间，最久没有使用到的结点。那么，当我们的 Cache 满了，需要替换掉的就是双向链表中最后的那个结点（不是尾结点，头尾结点不存储实际内容）。</p>
<p>哈希表的作用是什么呢？如果没有哈希表，我们要访问某个结点，就需要顺序地一个个找，时间复杂度是O(n)。使用哈希表可以让我们在 O(1) 的时间找到想要访问的结点，或者返回未找到。</p>
<p>更多详情：</p>
<ul>
<li><a href="http://www.hawstein.com/posts/lru-cache-impl.html" target="_blank" rel="external">如何用C++实现一个LRU Cache</a></li>
<li><a href="http://www.yufengof.com/2015/11/18/lru-and-linkedhashmap-source-code/" target="_blank" rel="external">剖析LRU算法及LinkedHashMap源码实现机制</a></li>
</ul>
<p>关于 iOS 中 Cache 的设计，推荐阅读 ibireme 的 <a href="http://blog.ibireme.com/2015/10/26/yycache/" target="_blank" rel="external">YYCache 设计思路</a> </p>
<hr>
<h2 id="图片解码">图片解码</h2><blockquote>
<p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p>
</blockquote>
<p>上段文字引用自 ibireme 的 <a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">iOS 保持界面流畅的技巧</a></p>
<p>而在 SDWebImage 中也的确将图片的解码放在了子线程中完成，目的就是为了提示读取缓存的效率。</p>
<hr>
<h2 id="总结">总结</h2><p>下面是对 SDWebImage 中涉及的技术点进行简短的总结：</p>
<ol>
<li><p><code>NSCache</code> 类：以 key-value 的形式进行存储，实现内存缓存</p>
</li>
<li><p>图片缓存清理策略：如果所有缓存文件的总大小超过这一大小，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间</p>
</li>
<li><p>对图片的解压缩操作：具体操作可以查看 SDWebImageDecoder.m 中 <code>+decodedImageWithImage</code> 方法的实现</p>
</li>
<li><p><code>dispatch_barrier_sync</code> 函数：该方法用于对操作设置屏幕，确保在执行完任务后才会执行后续操作，该方法常用于确保类的线程安全性操作</p>
</li>
<li><p><code>NSOperation</code> 与 <code>NSOperationQueue</code> 相结合：实现多线程并发操作，可实现取消任务、设置依赖关系、设置最大并发数等</p>
</li>
<li><p><code>NSMutableURLRequest</code> 与 <code>NSURLConnection</code> 相结合：实现网络请求与下载</p>
</li>
<li><p><code>Run Loop</code>：保证子线程进不断处理操作</p>
</li>
</ol>
<p>呼……总算写完了，不用想也知道有很多不足，感谢你阅读的同时也欢迎你指正不到之处：）</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>关于 SDWebImage 整体的架构可以参见下图：</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="SDWebImage" scheme="http://itangqi.me/tags/SDWebImage/"/>
    
      <category term="Source code" scheme="http://itangqi.me/tags/Source-code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SDWebImage 源码阅读笔记（三）]]></title>
    <link href="http://itangqi.me/2016/03/23/the-notes-of-learning-sdwebimage-three/"/>
    <id>http://itangqi.me/2016/03/23/the-notes-of-learning-sdwebimage-three/</id>
    <published>2016-03-22T16:00:00.000Z</published>
    <updated>2016-04-25T10:52:04.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>不知不觉，我们已经通过前面两篇文章的介绍（<a href="http://itangqi.me/2016/03/19/the-notes-of-learning-sdwebimage-one/">我是链接=;=</a>），对 SDWebImage 的工作流程有了较为清晰的认识，那么，今天就让我们把重点放在 <code>SDWebImageDownloader</code> 上，它到底做了哪些工作？又有哪些奇淫技巧？别着急，你慢慢往下看：）</p>
<a id="more"></a> 
<hr>
<h2 id="SDWebImageDownloaderOptions">SDWebImageDownloaderOptions</h2><p>在切入正题前，我们有必要来了解下 <code>SDWebImageDownloaderOptions</code>。</p>
<p>在下载的过程中，程序会根据设置的不同的下载选项，而执行不同的操作。下载选项由枚举 <code>SDWebImageDownloaderOptions</code> 定义，具体如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageDownloaderOptions) &#123;</span><br><span class="line">    SDWebImageDownloaderLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    SDWebImageDownloaderProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认情况下请求不使用 NSURLCache，如果设置该选项，则以默认的缓存策略来使用 NSURLCache</span></span><br><span class="line">    SDWebImageDownloaderUse<span class="built_in">NSURLCache</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 如果从 NSURLCache 缓存中读取图片，则使用 nil 作为参数来调用图片下载完成时 block </span></span><br><span class="line">    SDWebImageDownloaderIgnoreCachedResponse = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">true<span class="comment">// 在 iOS 4+ 系统上，允许程序进入后台后继续下载图片。该操作通过向系统申请额外的时间来完成后台下载。如果后台任务终止，则操作会被取消 </span></span><br><span class="line">    SDWebImageDownloaderContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 通过设置 NSMutableURLRequest.HTTPShouldHandleCookies = YES 来处理存储在 NSHTTPCookieStore 中的 cookie </span></span><br><span class="line">    SDWebImageDownloaderHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许不受信任的 SSL 证书，主要用于测试目的</span></span><br><span class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 将图片下载放到高优先级队列中  </span></span><br><span class="line">    SDWebImageDownloaderHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SDWebImage 的下载操作是按一定顺序来处理的，它定义了两种下载顺序，如下所示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, SDWebImageDownloaderExecutionOrder) &#123;</span><br><span class="line">  <span class="comment">// 以队列的方式，按照先进先出的顺序下载，这是默认的下载顺序</span></span><br><span class="line">  SDWebImageDownloaderFIFOExecutionOrder,</span><br><span class="line">  <span class="comment">// 以栈的方式，按照后进先出的顺序下载</span></span><br><span class="line">  SDWebImageDownloaderLIFOExecutionOrder</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="NSOperation_&amp;_NSOperationQueue">NSOperation &amp; NSOperationQueue</h2><p>什么？还不让我看下载的具体代码！！！</p>
<p>嘻嘻，不要急嘛，俗话说「心急吃不了热豆腐」，再容我向你介绍下 <code>NSOperation</code> 与 <code>NSOperationQueue</code>：</p>
<ul>
<li><p><code>NSOperation</code> 是一个抽象类，你可以用它来封装一个任务的相关代码和数据。因为它是个抽象类，所以你不能直接使用它，而是需要继承并实现其子类或者使用系统内置的两个子类（<code>NSInvocationOperation</code> 和 <code>NSBlockOperation</code>）来执行实际的线程任务</p>
</li>
<li><p><code>NSOperationQueue</code> 类管理着一组 <code>NSOperation</code> 对象的执行，当一个 operation 对象被加入到队列后，它会始终保留在队列中，直到它已经明确的被取消或者完成执行任务。Operations 在队列内（但尚未执行），它们是根据优先级和互相依赖进行组织的，相应的去执行。一个应用可以创建多个操作队列（operation queues）并提交操作（operations）到其中任何一个中</p>
</li>
</ul>
<p>SDWebImageDownloader 下载管理器是一个单例类，它主要负责图片的下载操作的管理。图片的下载是放在一个 <code>NSOperationQueue</code> 操作队列中来完成的，其声明如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSOperationQueue</span> *downloadQueue;</span><br></pre></td></tr></table></figure>
<p>默认情况下，队列最大并发数是 6。如果需要的话，我们可以通过 <code>SDWebImageDownloader</code> 类的 <code>maxConcurrentDownloads</code> 属性来修改。</p>
<p>所有下载操作的网络响应序列化处理是放在一个自定义的并行调度队列中来处理的，其声明及定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>) <span class="built_in">dispatch_queue_t</span> barrierQueue;  </span><br><span class="line">- (<span class="keyword">id</span>)init &#123;  </span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;  </span><br><span class="line">    ...  </span><br><span class="line">    _barrierQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageDownloaderBarrierQueue"</span>, DISPATCH_QUEUE_CONCURRENT);  </span><br><span class="line">    ...  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="downloadImageWithURL:">downloadImageWithURL:</h2><p>哇靠，又是 <code>downloadImageWithURL:</code>，这是什么鬼？</p>
<p>整个下载管理器对于下载请求的管理都是放在 <code>downloadImageWithURL:options:progress:completed:</code> 方法里面来处理的，而该方法又调用了 <code>addProgressCallback:andCompletedBlock:forURL:createCallback:</code> 方法来将请求的信息存入管理器中，同时在创建回调的 block 中创建新的操作，配置之后将其放入 downloadQueue 操作队列中，最后方法返回新创建的操作，具体实现如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^&#123;  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="comment">// 创建请求对象，并根据 options 参数设置其属性  </span></span><br><span class="line">    <span class="comment">// 为了避免潜在的重复缓存（NSURLCache + SDImageCache），如果没有明确告知需要缓存，则禁用图片请求的缓存操作  </span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUse<span class="built_in">NSURLCache</span> ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) timeoutInterval:timeoutInterval];  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="comment">// 创建 SDWebImageDownloaderOperation 操作对象，并进行配置  </span></span><br><span class="line">    <span class="comment">// 配置信息包括是否需要认证、优先级  </span></span><br><span class="line">    operation = [[wself<span class="variable">.operationClass</span> alloc] initWithRequest:request  </span><br><span class="line">                              options:options  </span><br><span class="line">                             progress:^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize) &#123;  </span><br><span class="line">                               <span class="comment">// 从管理器的 callbacksForURL 中找出该 URL 所有的进度处理回调并调用  </span></span><br><span class="line">                               ...  </span><br><span class="line">                               <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;  </span><br><span class="line">                                 SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];  </span><br><span class="line">                                 <span class="keyword">if</span> (callback) callback(receivedSize, expectedSize);  </span><br><span class="line">                               &#125;  </span><br><span class="line">                             &#125;  </span><br><span class="line">                            completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;  </span><br><span class="line">                               <span class="comment">// 从管理器的 callbacksForURL 中找出该 URL 所有的完成处理回调并调用  </span></span><br><span class="line">                               <span class="comment">// 如果 finished 为 YES，则将该 url 对应的回调信息从 URLCallbacks 中删除  </span></span><br><span class="line">                              ...  </span><br><span class="line">                              <span class="keyword">if</span> (finished) &#123;  </span><br><span class="line">                                [sself removeCallbacksForURL:url];  </span><br><span class="line">                              &#125;  </span><br><span class="line">                              <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;  </span><br><span class="line">                                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];  </span><br><span class="line">                                <span class="keyword">if</span> (callback) callback(image, data, error, finished);  </span><br><span class="line">                              &#125;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            cancelled:^&#123;  </span><br><span class="line">                              <span class="comment">// 取消操作将该 url 对应的回调信息从 URLCallbacks 中删除  </span></span><br><span class="line">                              SDWebImageDownloader *sself = wself;  </span><br><span class="line">                              <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;  </span><br><span class="line">                              [sself removeCallbacksForURL:url];  </span><br><span class="line">                            &#125;];  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="comment">// 将操作加入到操作队列 downloadQueue 中  </span></span><br><span class="line">    <span class="comment">// 如果是 LIFO 顺序，则将新的操作作为原队列中最后一个操作的依赖，然后将新操作设置为最后一个操作  </span></span><br><span class="line">    [wself<span class="variable">.downloadQueue</span> addOperation:operation];  </span><br><span class="line">    <span class="keyword">if</span> (wself<span class="variable">.executionOrder</span> == SDWebImageDownloaderLIFOExecutionOrder) &#123;  </span><br><span class="line">      [wself<span class="variable">.lastAddedOperation</span> addDependency:operation];  </span><br><span class="line">      wself<span class="variable">.lastAddedOperation</span> = operation;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="addProgressCallback:">addProgressCallback:</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock andCompletedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(<span class="built_in">NSURL</span> *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">true </span><br><span class="line">true<span class="comment">// 以 dispatch_barrier_sync 操作来保证同一时间只有一个线程能对 URLCallbacks 进行操作</span></span><br><span class="line">    dispatch_barrier_sync(<span class="keyword">self</span><span class="variable">.barrierQueue</span>, ^&#123;</span><br><span class="line">        <span class="built_in">BOOL</span> first = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url]) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url] = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">            first = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理同一 URL 的同步下载请求的单个下载</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</span><br><span class="line">        <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</span><br><span class="line">        [callbacksForURL addObject:callbacks];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.URLCallbacks</span>[url] = callbacksForURL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            createCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法会先查看这个 url 是否有对应的 callback，使用的是 downloader 持有的一个字典 <code>URLCallbacks</code>。</p>
<p>如果是第一次添加回调的话，就会执行 first = YES，这个赋值非常的关键，因为 first 不为 YES 那么 HTTP 请求就不会被初始化，图片也无法被获取。</p>
<p>然后，在这个方法中会重新修正在 <code>URLCallbacks</code> 中存储的回调块。</p>
<p>如果是第一次添加回调块，那么就会直接运行这个 createCallback 这个 block，而这个 block，就是我们在前一个方法 <code>downloadImageWithURL:options:progress:completed:</code> 中传入的回调块：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SDWebImageDownloader</span></span><br><span class="line"><span class="comment">// downloadImageWithURL:options:progress:completed: #4</span></span><br><span class="line">[<span class="keyword">self</span> addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^&#123; ... &#125;];</span><br></pre></td></tr></table></figure>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-sdwebimage-three-01.png" alt=""><a href="http://www.cnblogs.com/polobymulberry/p/5017995.html" target="_blank" rel="external">图片来自</a></p>
<hr>
<h2 id="SDWebImageDownloaderOperation">SDWebImageDownloaderOperation</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    	<span class="comment">// 管理下载状态，如果已取消，则重置当前下载并设置完成状态为 YES </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.isCancelled</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.finished</span> = <span class="literal">YES</span>;</span><br><span class="line">            [<span class="keyword">self</span> reset];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span></span><br><span class="line">        Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</span><br><span class="line">        <span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">        <span class="comment">// 开启后台下载</span></span><br><span class="line">        <span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">            __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</span><br><span class="line">            <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.backgroundTaskId</span> = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sself) &#123;</span><br><span class="line">                    [sself cancel];</span><br><span class="line"></span><br><span class="line">                    [app endBackgroundTask:sself<span class="variable">.backgroundTaskId</span>];</span><br><span class="line">                    sself<span class="variable">.backgroundTaskId</span> = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.executing</span> = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.connection</span> = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span><span class="variable">.request</span> delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.thread</span> = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.connection</span> start];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.connection</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.progressBlock</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.progressBlock</span>(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在主线程发通知</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:<span class="keyword">self</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (floor(<span class="built_in">NSFoundationVersionNumber</span>) &lt;= <span class="built_in">NSFoundationVersionNumber_iOS_5_1</span>) &#123;</span><br><span class="line">            <span class="built_in">CFRunLoopRunInMode</span>(k<span class="built_in">CFRunLoopDefaultMode</span>, <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 在默认模式下运行当前 Run Loop，直到调用 CFRunLoopStop 停止运行</span></span><br><span class="line">            <span class="built_in">CFRunLoopRun</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.isFinished</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.connection</span> cancel];</span><br><span class="line">            [<span class="keyword">self</span> connection:<span class="keyword">self</span><span class="variable">.connection</span> didFailWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorTimedOut</span> userInfo:@&#123;<span class="built_in">NSURLErrorFailingURLErrorKey</span> : <span class="keyword">self</span><span class="variable">.request</span><span class="variable">.URL</span>&#125;]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completedBlock</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.completedBlock</span>(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Connection can't be initialized"</span>&#125;], <span class="literal">YES</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span></span><br><span class="line">    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.backgroundTaskId</span> != <span class="built_in">UIBackgroundTaskInvalid</span>) &#123;</span><br><span class="line">        <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">        [app endBackgroundTask:<span class="keyword">self</span><span class="variable">.backgroundTaskId</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.backgroundTaskId</span> = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类就是处理 HTTP 请求，URL 连接的类，当这个类的实例被加入队列之后，<code>start</code> 方法就会被调用， 而 <code>start</code> 方法首先就会产生一个 <code>NSURLConnection</code>。</p>
<p><strong>广告时间：）</strong></p>
<p>如果你对 <code>NSURLConnection</code> 不了解，可以先看下我的文章：<a href="http://itangqi.me/2016/04/01/from-nsurlconnection-to-nsurlsession/#more">从 NSURLConnection 到 NSURLSession</a></p>
<p>————————————————————-华丽的分割线——————————————————————————</p>
<p>在 <code>start</code> 方法调用之后，就是 <code>NSURLConnectionDataDelegate</code> 中代理方法的调用：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response;</span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response;</span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)aConnection;</span><br></pre></td></tr></table></figure>
<p>在这三个代理方法中的前两个会不停回调 <code>progressBlock</code> 来提示下载的进度。</p>
<p>而最后一个代理方法会在图片下载完成之后调用 <code>completionBlock</code> 来完成最后 UIImageView.image 的更新。</p>
<p>而这里调用的 <code>progressBlock</code>、<code>completionBlock</code>、<code>cancelBlock</code> 都是在之前存储在 <code>URLCallbacks</code> 字典中的。</p>
<hr>
<h2 id="didReceiveData：">didReceiveData：</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">true<span class="comment">// 附加数据 </span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.imageData</span> appendData:data];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span><span class="variable">.options</span> &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; <span class="keyword">self</span><span class="variable">.expectedSize</span> &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">self</span><span class="variable">.completedBlock</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取已下载数据总大小 </span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> totalSize = <span class="keyword">self</span><span class="variable">.imageData</span><span class="variable">.length</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新数据源，我们需要传入所有数据，而不仅仅是新数据 </span></span><br><span class="line">        <span class="built_in">CGImageSourceRef</span> imageSource = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)<span class="keyword">self</span><span class="variable">.imageData</span>, <span class="literal">NULL</span>);</span><br><span class="line">truetruetrue<span class="comment">// 首次获取到数据时，从这些数据中获取图片的长、宽、方向属性值  </span></span><br><span class="line">        <span class="keyword">if</span> (width + height == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">CFDictionaryRef</span> properties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (properties) &#123;</span><br><span class="line">                <span class="built_in">NSInteger</span> orientationValue = -<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">CFTypeRef</span> val = <span class="built_in">CFDictionaryGetValue</span>(properties, k<span class="built_in">CGImagePropertyPixelHeight</span>);</span><br><span class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, k<span class="built_in">CFNumberLongType</span>, &amp;height);</span><br><span class="line">                val = <span class="built_in">CFDictionaryGetValue</span>(properties, k<span class="built_in">CGImagePropertyPixelWidth</span>);</span><br><span class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, k<span class="built_in">CFNumberLongType</span>, &amp;width);</span><br><span class="line">                val = <span class="built_in">CFDictionaryGetValue</span>(properties, k<span class="built_in">CGImagePropertyOrientation</span>);</span><br><span class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, k<span class="built_in">CFNumberNSIntegerType</span>, &amp;orientationValue);</span><br><span class="line">                <span class="built_in">CFRelease</span>(properties);</span><br><span class="line"></span><br><span class="line">              	<span class="comment">// 当绘制到 Core Graphics 时，我们会丢失方向信息，这意味着有时候由initWithCGIImage 创建的图片的方向会不对，所以在这边我们先保存这个信息并在后面使用</span></span><br><span class="line">                orientation = [[<span class="keyword">self</span> class] orientationFromPropertyValue:(orientationValue == -<span class="number">1</span> ? <span class="number">1</span> : orientationValue)];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">truetrue<span class="comment">// 图片还未下载完成  </span></span><br><span class="line">        <span class="keyword">if</span> (width + height &gt; <span class="number">0</span> &amp;&amp; totalSize &lt; <span class="keyword">self</span><span class="variable">.expectedSize</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用现有的数据创建图片对象，如果数据中存有多张图片，则取第一张 </span></span><br><span class="line">            <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef TARGET_OS_IPHONE</span></span><br><span class="line">            <span class="comment">// 适用于 iOS 变形图像的解决方案。我的理解是由于 iOS 只支持 RGB 颜色空间，所以在此对下载下来的图片做个颜色空间转换处理</span></span><br><span class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</span><br><span class="line">                <span class="keyword">const</span> size_t partialHeight = <span class="built_in">CGImageGetHeight</span>(partialImageRef);</span><br><span class="line">                <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">                <span class="built_in">CGContextRef</span> bmContext = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, width * <span class="number">4</span>, colorSpace, k<span class="built_in">CGBitmapByteOrderDefault</span> | k<span class="built_in">CGImageAlphaPremultipliedFirst</span>);</span><br><span class="line">                <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">                <span class="keyword">if</span> (bmContext) &#123;</span><br><span class="line">                    <span class="built_in">CGContextDrawImage</span>(bmContext, (<span class="built_in">CGRect</span>)&#123;<span class="variable">.origin</span><span class="variable">.x</span> = <span class="number">0.0</span>f, <span class="variable">.origin</span><span class="variable">.y</span> = <span class="number">0.0</span>f, <span class="variable">.size</span><span class="variable">.width</span> = width, <span class="variable">.size</span><span class="variable">.height</span> = partialHeight&#125;, partialImageRef);</span><br><span class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</span><br><span class="line">                    partialImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(bmContext);</span><br><span class="line">                    <span class="built_in">CGContextRelease</span>(bmContext);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</span><br><span class="line">                    partialImageRef = <span class="literal">nil</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">truetruetrue<span class="comment">// 对图片进行缩放、解码操作 </span></span><br><span class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</span><br><span class="line">                <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:partialImageRef scale:<span class="number">1</span> orientation:orientation];</span><br><span class="line">                <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span><span class="variable">.request</span><span class="variable">.URL</span>];</span><br><span class="line">                <span class="built_in">UIImage</span> *scaledImage = [<span class="keyword">self</span> scaledImageForKey:key image:image];</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldDecompressImages</span>) &#123;</span><br><span class="line">                    image = [<span class="built_in">UIImage</span> decodedImageWithImage:scaledImage];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    image = scaledImage;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">CGImageRelease</span>(partialImageRef);</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completedBlock</span>) &#123;</span><br><span class="line">                        <span class="keyword">self</span><span class="variable">.completedBlock</span>(image, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CFRelease</span>(imageSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.progressBlock</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.progressBlock</span>(<span class="keyword">self</span><span class="variable">.imageData</span><span class="variable">.length</span>, <span class="keyword">self</span><span class="variable">.expectedSize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的主要任务是接收数据。每次接收到数据时，都会用现有的数据创建一个 CGImageSourceRef 对象以做处理。在首次获取到数据时（width+height==0）会从这些包含图像信息的数据中取出图像的长、宽、方向等信息以备使用。而后在图片下载完成之前，会使用 CGImageSourceRef 对象创建一个图片对象，经过缩放、解压缩操作后生成一个 UIImage 对象供完成回调使用。当然，在这个方法中还需要处理的就是进度信息。如果我们有设置进度回调的话，就调用这个进度回调以处理当前图片的下载进度。</p>
<hr>
<h2 id="要点">要点</h2><ol>
<li>通知的接收所在的线程是基于发送通知所在的线程，如果通知是在主线程发出的，通知的接收也是在主线程，如果通知的发送是在子线程，通知的接收也是在子线程。（如果想回主线程，可使用 <code>dispatch_async(dispatch_get_main_queue(), ^</code>）</li>
</ol>
<p>关于 SDWebImage 的整体分析就到这里啦，我会在终结篇：<a href="">SDWebImage 源码阅读笔记（四）</a>中对某些知识点进行扩展，感兴趣的同学不妨去瞅瞅呗！</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="http://cocoadocs.org/docsets/SDWebImage/3.7.5/" target="_blank" rel="external">CocoaDocs - SDWebImage</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSCache_Class/" target="_blank" rel="external">NSCache Class Reference</a></li>
<li><a href="http://www.jianshu.com/p/c07df06c60be" target="_blank" rel="external">SDWebImage源码剖析（－）</a></li>
<li><a href="http://blog.csdn.net/xubinlxb/article/details/51136805" target="_blank" rel="external">SDWebImage源码解析（一）</a></li>
<li><a href="http://draveness.me/ios-yuan-dai-ma-jie-xi-sdwebimage/" target="_blank" rel="external">iOS 源代码分析—-SDWebImage</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>不知不觉，我们已经通过前面两篇文章的介绍（<a href="http://itangqi.me/2016/03/19/the-notes-of-learning-sdwebimage-one/">我是链接=;=</a>），对 SDWebImage 的工作流程有了较为清晰的认识，那么，今天就让我们把重点放在 <code>SDWebImageDownloader</code> 上，它到底做了哪些工作？又有哪些奇淫技巧？别着急，你慢慢往下看：）</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="SDWebImage" scheme="http://itangqi.me/tags/SDWebImage/"/>
    
      <category term="Source code" scheme="http://itangqi.me/tags/Source-code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SDWebImage 源码阅读笔记（二）]]></title>
    <link href="http://itangqi.me/2016/03/21/the-notes-of-learning-sdwebimage-two/"/>
    <id>http://itangqi.me/2016/03/21/the-notes-of-learning-sdwebimage-two/</id>
    <published>2016-03-20T16:00:00.000Z</published>
    <updated>2016-04-19T08:30:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>我们在第一篇文章<a href="">《SDWebImage 源码阅读笔记（一）》</a>中，已经了解到，当我们调用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[cell<span class="variable">.imageView</span> sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</span><br><span class="line">                  placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]];</span><br></pre></td></tr></table></figure>
<p>时，其实是通过 <code>SDWebImageManager</code> 类进行协调，调用 <code>SDImageCache</code> 与 <code>SDWebImageDownloader</code> 来实现图片的缓存查询与网络下载的。那么今天在第二篇中，就让我们来对 <code>SDImageCache</code> 一探究竟吧：）</p>
<a id="more"></a> 
<hr>
<h2 id="SDImageCache">SDImageCache</h2><p>在 <code>SDImageCache.h</code> 中你可以看到关于 SDImageCache 的描述：</p>
<blockquote>
<p>SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed asynchronous so it doesn’t add unnecessary latency to the UI.</p>
</blockquote>
<p>该类维护了一个内存缓存与一个可选的磁盘缓存。同时，磁盘缓存的写操作是异步的，所以它不会对 UI 造成不必要的影响。</p>
<p>每次查询图片时，首先会根据图片的 URL 对应的 key 值先检查内存中是否有对应的图片，如果有则直接返回；如果没有则在 ioQueue 中去磁盘中查找，其 key 是根据 URL 生成的 MD5 值，找到之后先将图片缓存在内存中，然后在把图片返回：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSOperation</span> *)queryDiskCacheForKey:(<span class="built_in">NSString</span> *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    <span class="keyword">if</span> (!doneBlock) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        doneBlock(<span class="literal">nil</span>, SDImageCacheTypeNone);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先检查内存缓存（查询是同步的），如果查找到，则直接回调 doneBlock 并返回</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (operation<span class="variable">.isCancelled</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建自动释放池，内存及时释放</span></span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        	<span class="comment">// 检查磁盘缓存（查询是异步的），如果查找到，则将其放到内存缓存，并调用 doneBlock 回调</span></span><br><span class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</span><br><span class="line">            <span class="keyword">if</span> (diskImage) &#123;</span><br><span class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                <span class="comment">// 缓存至内存（NSCache）中</span></span><br><span class="line">                [<span class="keyword">self</span><span class="variable">.memCache</span> setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line">truetruetrue<span class="comment">// 返回主线程设置图片</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="NSCache">NSCache</h3><blockquote>
<p>An NSCache object is a collection-like container, or cache, that stores key-value pairs, similar to the NSDictionary class. </p>
</blockquote>
<p>NSCache 是苹果官方提供的缓存类，用法与 NSMutableDictionary 的用法很相似，在 SDWebImage 和 AFNetworking 中，使用它来管理缓存。同样是以 key-value 的形式进行存储，那么 NSCache 与 NSMutableDictionary 等集合类的区别或者说优势又是哪些呢？</p>
<ol>
<li><p>NSCache 类结合了各种<strong>自动删除</strong>策略，以确保不会占用过多的系统内存。如果其它应用需要内存时，系统自动执行这些策略。当调用这些策略时，会从缓存中删除一些对象，以最大限度减少内存的占用</p>
</li>
<li><p>NSCache 是<strong>线程安全</strong>的，我们可以在不同的线程中添加、删除和查询缓存中的对象，而不需要锁定缓存区域</p>
</li>
<li><p>不像 NSMutableDictionary 对象，NSCache 对象并不会拷贝键（key），而是会强引用它</p>
</li>
</ol>
<h4 id="要点">要点</h4><ol>
<li><p>在开发者自己不编写加锁代码的前提下，多个线程便可以同时访问 NSCache</p>
</li>
<li><p>NSCache 对象不拷贝键的原因在于：很多时候，键都是由不支持拷贝操作的对象来充当的。所以说，在键不支持拷贝操作的情况下，该类用起来比字典更方便</p>
</li>
<li><p>可以给 NSCache 对象设置上限，用以限制缓存中的对象总个数及「总成本」，而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的「硬限制」，它们仅对 NSCache 起指导作用 </p>
</li>
<li><p>将 NSPurgeableData 与 NSCache 搭配使用，可实现自动清除数据的功能，也就是说，当 NSPurgeableData 对象所占内存为系统所丢弃时，该对象自身也会从缓存中移除</p>
</li>
<li><p>如果缓存使用得当，那么应用程序的响应速度就能提高。只有那种「重新计算起来很费事的」数据，才值得放入缓存，比如那些需要从网络获取或者从磁盘读取的数据</p>
</li>
<li><p>内存查询是同步，磁盘查询是异步</p>
</li>
</ol>
<hr>
<h3 id="磁盘">磁盘</h3><p>磁盘缓存的处理则是使用 NSFileManager 对象来实现的。默认以 <code>com.hackemist.SDWebImageCache.default</code> 为磁盘的缓存命名空间，程序运行后，可以在应用程序的文件夹 <code>Library/Caches/default/com.hackemist.SDWebImageCache.default</code> 下看到一些缓存文件。另外，SDImageCache 还定义了一个串行队列，来异步存储图片。</p>
<p>在磁盘查询的时候，会在后台将 NSData 转成 UIImage，并完成相关的解码工作:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)diskImageForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> sd_imageWithData:data];</span><br><span class="line">        image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.shouldDecompressImages</span>) &#123;</span><br><span class="line">            image = [<span class="built_in">UIImage</span> decodedImageWithImage:image];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="要点-1">要点</h4><ol>
<li>为何要进行 decode，参见：<a href="http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/" target="_blank" rel="external">Avoiding Image Decompression Sickness</a></li>
</ol>
<hr>
<h3 id="存储图片">存储图片</h3><p>当下载完图片后，会先将图片保存到 NSCache 中，并把图片像素大小作为该对象的 cost 值，同时如果需要保存到硬盘，会先判断图片的格式，PNG 或者 JPEG，并保存对应的 NSData 到缓存路径中，文件名为 URL 的 MD5 值：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)storeImage:(<span class="built_in">UIImage</span> *)image recalculateFromImage:(<span class="built_in">BOOL</span>)recalculate imageData:(<span class="built_in">NSData</span> *)imageData forKey:(<span class="built_in">NSString</span> *)key toDisk:(<span class="built_in">BOOL</span>)toDisk &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 内存缓存，将其存入 NSCache 中，同时传入图片的消耗值，cost 为像素值（当内存受限或者所有缓存对象的总代价超过了最大允许的值时，缓存会移除其中的一些对象）</span></span><br><span class="line">  [<span class="keyword">self</span><span class="variable">.memCache</span> setObject:image forKey:key cost:image<span class="variable">.size</span><span class="variable">.height</span> * image<span class="variable">.size</span><span class="variable">.width</span> * image<span class="variable">.scale</span> * image<span class="variable">.scale</span>];</span><br><span class="line">  <span class="keyword">if</span> (toDisk) &#123;</span><br><span class="line">    <span class="comment">// 如果确定需要磁盘缓存，则将缓存操作作为一个任务放入 ioQueue 中</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^&#123;</span><br><span class="line">      <span class="comment">// 构建一个 data，用来存储到 disk 中，默认值为 imageData</span></span><br><span class="line">      <span class="built_in">NSData</span> *data = imageData;</span><br><span class="line">      <span class="keyword">if</span> (image &amp;&amp; (recalculate || !data)) &#123;</span><br><span class="line"><span class="preprocessor">#if TARGET_OS_IPHONE</span></span><br><span class="line">        <span class="comment">// 需要确定图片是 PNG 还是 JPEG。PNG 图片容易检测，因为有一个唯一签名。PNG 图像的前 8 个字节总是包含以下值：137 80 78 71 13 10 26 10</span></span><br><span class="line">        <span class="comment">// 在 imageData 为 nil 的情况下假定图像为 PNG。我们将其当作 PNG 以避免丢失透明度。而当有图片数据时，我们检测其前缀，确定图片的类型</span></span><br><span class="line">        <span class="built_in">BOOL</span> imageIsPng = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">if</span> ([imageData length] &gt;= [kPNGSignatureData length]) &#123;</span><br><span class="line">          imageIsPng = ImageDataHasPNGPreffix(imageData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 image 是 PNG 格式，就是用 UIImagePNGRepresentation 将其转化为 NSData，否则按照 JPEG 格式转化，并且压缩质量为 1，即无压缩</span></span><br><span class="line">        <span class="keyword">if</span> (imageIsPng) &#123;</span><br><span class="line">          data = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          data = <span class="built_in">UIImageJPEGRepresentation</span>(image, (<span class="built_in">CGFloat</span>)<span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="preprocessor">#else</span></span><br><span class="line">        data = [<span class="built_in">NSBitmapImageRep</span> representationOfImageRepsInArray:image<span class="variable">.representations</span> usingType: <span class="built_in">NSJPEGFileType</span> properties:<span class="literal">nil</span>];</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建缓存文件并存储图片（使用 fileManager）</span></span><br><span class="line">      <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">          [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存 data 到指定的路径中</span></span><br><span class="line">        [_fileManager createFileAtPath:[<span class="keyword">self</span> defaultCachePathForKey:key] contents:data attributes:<span class="literal">nil</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="清理图片">清理图片</h3><p>SDImageCache 会在系统发出低内存警告时释放内存，并且在程序进入 UIApplicationWillTerminateNotification 时，清理<strong>磁盘缓存</strong>，清理磁盘的机制是：</p>
<ol>
<li><p>删除过期的图片，默认 7 天过期，可以通过 maxCacheAge 修改过期天数。</p>
</li>
<li><p>如果缓存的数据大小超过设置的最大缓存 maxCacheSize，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间，可以通过修改 maxCacheSize 来改变最大缓存大小。</p>
</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span><span class="variable">.diskCachePath</span> isDirectory:<span class="literal">YES</span>];</span><br><span class="line">        <span class="built_in">NSArray</span> *resourceKeys = @[<span class="built_in">NSURLIsDirectoryKey</span>, <span class="built_in">NSURLContentModificationDateKey</span>, <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该枚举器预先获取缓存文件的有用的属性</span></span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></span><br><span class="line">                                                                 errorHandler:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSDate</span> *expirationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-<span class="keyword">self</span><span class="variable">.maxCacheAge</span>];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *cacheFiles = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        <span class="built_in">NSUInteger</span> currentCacheSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举缓存文件夹中所有文件，该迭代有两个目的：移除比过期日期更老的文件；存储文件属性以备后面执行基于缓存大小的清理操作 </span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *urlsToDelete = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过文件夹 </span></span><br><span class="line">            <span class="keyword">if</span> ([resourceValues[<span class="built_in">NSURLIsDirectoryKey</span>] boolValue]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除早于有效期的老文件</span></span><br><span class="line">            <span class="built_in">NSDate</span> *modificationDate = resourceValues[<span class="built_in">NSURLContentModificationDateKey</span>];</span><br><span class="line">            <span class="keyword">if</span> ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储文件的引用并计算所有文件的总大小，以备后用 </span></span><br><span class="line">            <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">            currentCacheSize += [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line">            [cacheFiles setObject:resourceValues forKey:fileURL];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</span><br><span class="line">            [_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果磁盘缓存的大小大于我们配置的最大大小，则执行基于文件大小的清理，我们首先删除最早的文件 </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.maxCacheSize</span> &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span><span class="variable">.maxCacheSize</span>) &#123;</span><br><span class="line">            <span class="comment">// 以设置的最大缓存大小的一半作为清理目标</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span><span class="variable">.maxCacheSize</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按照最后修改时间来排序剩下的缓存文件 </span></span><br><span class="line">            <span class="built_in">NSArray</span> *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></span><br><span class="line">                                                            usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</span><br><span class="line">                                                                <span class="keyword">return</span> [obj1[<span class="built_in">NSURLContentModificationDateKey</span>] compare:obj2[<span class="built_in">NSURLContentModificationDateKey</span>]];</span><br><span class="line">                                                            &#125;];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除文件，直到缓存总大小降到我们期望的大小</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</span><br><span class="line">                    <span class="built_in">NSDictionary</span> *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">                    currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>关于 <code>SDImageCache</code> 的内容大致就这么多，接下来就让我们一起来看一下 <code>SDWebImageDownloader</code> 中都暗藏了哪些玄机吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>我们在第一篇文章<a href="">《SDWebImage 源码阅读笔记（一）》</a>中，已经了解到，当我们调用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[cell<span class="variable">.imageView</span> sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</span><br><span class="line">                  placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]];</span><br></pre></td></tr></table></figure>
<p>时，其实是通过 <code>SDWebImageManager</code> 类进行协调，调用 <code>SDImageCache</code> 与 <code>SDWebImageDownloader</code> 来实现图片的缓存查询与网络下载的。那么今天在第二篇中，就让我们来对 <code>SDImageCache</code> 一探究竟吧：）</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="SDWebImage" scheme="http://itangqi.me/tags/SDWebImage/"/>
    
      <category term="Source code" scheme="http://itangqi.me/tags/Source-code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SDWebImage 源码阅读笔记（一）]]></title>
    <link href="http://itangqi.me/2016/03/19/the-notes-of-learning-sdwebimage-one/"/>
    <id>http://itangqi.me/2016/03/19/the-notes-of-learning-sdwebimage-one/</id>
    <published>2016-03-18T16:00:00.000Z</published>
    <updated>2016-04-19T08:29:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>说来惭愧，我之前从事 Android 开发，用过许多著名的第三方库，不过仅仅停留在简单的调用 API 阶段，从未涉及到源码的阅读以了解其背后的实现原理，所以一直处于「知其然，而不知所以然」的状态。</p>
<p>如今转投 iOS 怀抱的我，决定将阅读优秀项目的源码作为学习的一部分，而且是带着<strong>疑问</strong>去阅读。由于在项目中使用及考虑到 SDWebImage 的普及程度，其顺理成章的成为了我第一个阅读的项目。</p>
<p>话不多说，让我们开始吧！</p>
<a id="more"></a> 
<hr>
<h2 id="简介">简介</h2><blockquote>
<p>Asynchronous image downloader with cache support as a UIImageView category.</p>
</blockquote>
<p>言简意赅：SDWebImage 以 UIImageView category（分类）的形式，来支持图片的异步下载与缓存。</p>
<p>其提供了以下功能：</p>
<ol>
<li>以 UIImageView 的分类，来支持网络图片的加载与缓存管理</li>
<li>一个异步的图片加载器</li>
<li>一个异步的内存 + 磁盘图片缓存</li>
<li>支持 GIF </li>
<li>支持 WebP</li>
<li>后台图片解压缩处理</li>
<li>确保同一个 URL 的图片不被多次下载</li>
<li>确保虚假的 URL 不会被反复加载</li>
<li>确保下载及缓存时，主线程不被阻塞</li>
<li>使用 GCD 与 ARC</li>
<li>支持 Arm64</li>
</ol>
<hr>
<h2 id="UIImageView+WebCache">UIImageView+WebCache</h2><p>首先，SDWebImage 最常见的使用场景想必如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;SDWebImage/UIImageView+WebCache.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *MyIdentifier = <span class="string">@"MyIdentifier"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];</span><br><span class="line">    <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</span><br><span class="line">        cell = [[[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span></span><br><span class="line">                                       reuseIdentifier:MyIdentifier] autorelease];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里，我们使用 UIImageView 分类提供的 sd_setImageWithURL: 方法来加载网络图片</span></span><br><span class="line">    [cell<span class="variable">.imageView</span> sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</span><br><span class="line">                      placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]];</span><br><span class="line"></span><br><span class="line">    cell<span class="variable">.textLabel</span><span class="variable">.text</span> = <span class="string">@"My Text"</span>;</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在使用 UITableView 时，往往需要在 Cell 上显示来自网络的图片，这里最关键的一行代码便是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[cell<span class="variable">.imageView</span> sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</span><br><span class="line">                  placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]];</span><br></pre></td></tr></table></figure>
<p>于是我们「CMD + 左键」来到了 <code>UIImageView+WebCache</code> 查看具体的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 根据 url、placeholder 与 custom options 为 imageview 设置 image</span><br><span class="line"> *</span><br><span class="line"> * 下载是异步的，并且被缓存的</span><br><span class="line"> *</span><br><span class="line"> * @param url            网络图片的 url 地址</span><br><span class="line"> * @param placeholder    用于预显示的图片</span><br><span class="line"> * @param options        一些定制化选项</span><br><span class="line"> * @param progressBlock  下载时的 Block，其定义为：typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize);</span><br><span class="line"> * @param completedBlock 下载完成时的 Block，其定义为：typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage *image, NSData *data, NSError *error, BOOL finished);</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="built_in">NSURL</span> *)url placeholderImage:(<span class="built_in">UIImage</span> *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</span><br><span class="line">    [<span class="keyword">self</span> sd_cancelCurrentImageLoad];</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.image</span> = placeholder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager<span class="variable">.sharedManager</span> downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                    wself<span class="variable">.image</span> = image;</span><br><span class="line">                    [wself setNeedsLayout];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">                        wself<span class="variable">.image</span> = placeholder;</span><br><span class="line">                        [wself setNeedsLayout];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:-<span class="number">1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</span><br><span class="line">            <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">                completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然代码只有几十行，但其中涉及到的知识点却可不少哦，不要急，让我们将迷雾一层层剥开：</p>
<hr>
<h2 id="UIView+WebCacheOperation">UIView+WebCacheOperation</h2><p>首先来看：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> sd_cancelCurrentImageLoad];</span><br></pre></td></tr></table></figure>
<p>「CMD + 左键」后带我们来到了 <code>UIView+WebCacheOperation</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sd_cancelImageLoadOperationWithKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">// 取消正在进行的下载队列</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *operationDictionary = [<span class="keyword">self</span> operationDictionary];</span><br><span class="line">    <span class="keyword">id</span> operations = [operationDictionary objectForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (operations) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([operations isKindOfClass:[<span class="built_in">NSArray</span> class]]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation <span class="keyword">in</span> operations) &#123;</span><br><span class="line">                <span class="keyword">if</span> (operation) &#123;</span><br><span class="line">                    [operation cancel];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([operations conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)])</span>&#123;</span><br><span class="line">            [(<span class="keyword">id</span>&lt;SDWebImageOperation&gt;) operations cancel];</span><br><span class="line">        &#125;</span><br><span class="line">        [operationDictionary removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>框架中的所有操作实际上都是通过一个 operationDictionary（具体查看 UIView+WebCacheOperation）来管理的，而这个 Dictionary 实际上是通过动态的方式（详情可参见：<a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="external">Objective-C Associated Objects 的实现原理</a>）添加到 UIView 上的一个属性，至于为什么添加到 UIView 上, 主要是因为这个 operationDictionary 需要在 UIButton 和 UIImageView 上重用，所以需要添加到它们的根类上。</p>
<p>当执行 <code>sd_setImageWithURL:</code> 函数时，首先会 cancel 掉 operationDictionary 中已经存在的 operation，并重新创建一个新的 SDWebImageCombinedOperation 对象来获取 image，该 operation 会被存入 operationDictionary 中。</p>
<p>这样来保证每个 UIImageView 对象中永远只存在一个 operation，当前只允许一个图片网络请求，该 operation 负责从缓存中获取 image 或者是重新下载 image。</p>
<p><strong><code>SDWebImageCombinedOperation</code> 的 cancel 操作同时会 cacel 掉缓存查询的 operation 以及 downloader 的 operation</strong></p>
<hr>
<h2 id="dispatch_main_sync_safe_&amp;_dispatch_main_async_safe_宏定义">dispatch_main_sync_safe &amp; dispatch_main_async_safe 宏定义</h2><p>再来看：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_main_async_safe(^&#123;</span><br><span class="line">           <span class="keyword">self</span><span class="variable">.image</span> = placeholder;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码中的 <code>dispatch_main_sync_safe</code> 与 <code>dispatch_main_async_safe</code> 均为宏定义, 点进去一看发现宏是这样定义的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#define dispatch_main_sync_safe(block)\</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> isMainThread]) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;\</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define dispatch_main_async_safe(block)\</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> isMainThread]) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;\</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>相信你通过这两个宏的名字就能猜到它们的作用了: 因为图像的绘制只能在主线程完成，所以<code>dispatch_main_sync_safe</code> 与 <code>dispatch_main_async_safe</code> 就是为了保证 block 能在主线程中执行。</p>
<hr>
<h2 id="SDWebImageManager">SDWebImageManager</h2><p>在 <code>SDWebImageManager.h</code> 中你可以看到关于 SDWebImageManager 的描述：</p>
<blockquote>
<p>The SDWebImageManager is the class behind the UIImageView+WebCache category and likes. It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache). You can use this class directly to benefit from web image downloading with caching in another context than a UIView.</p>
</blockquote>
<p>这个类就是隐藏在 <code>UIImageView+WebCache</code> 背后，用于处理异步下载和图片缓存的类，当然你也可以直接使用 SDWebImageManager 的上述方法 <code>downloadImageWithURL:options:progress:completed:</code> 来直接下载图片：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 如果在缓存中则直接返回，否则根据所给的 URL 下载图片</span><br><span class="line"> * </span><br><span class="line"> * @param url            网络图片的 url 地址</span><br><span class="line"> * @param options        一些定制化选项</span><br><span class="line"> * @param progressBlock  下载时的 Block，其定义为：typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize);</span><br><span class="line"> * @param completedBlock 下载完成时的 Block，其定义为：typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage *image, NSData *data, NSError *error, BOOL finished);</span><br><span class="line"> * @return 				 返回 SDWebImageOperation 的实例</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 前面省略 n 行，主要作了如下处理：</span><br><span class="line">     * 1. 判断 url 的合法性  </span><br><span class="line">     * 2. 创建 SDWebImageCombinedOperation 对象  </span><br><span class="line">     * 3. 查看 url 是否是之前下载失败过的  </span><br><span class="line">     * 4. 如果 url 为 nil，或者在不可重试的情况下是一个下载失败过的 url，则直接返回操作对象并调用完成回调 </span><br><span class="line">    */</span></span><br><span class="line">    <span class="comment">// 根据 URL 生成对应的 key，没有特殊处理为 [url absoluteString];</span></span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</span><br><span class="line">    <span class="comment">// 去缓存中查找图片（参见 SDImageCache）</span></span><br><span class="line">    operation<span class="variable">.cacheOperation</span> = [<span class="keyword">self</span><span class="variable">.imageCache</span> queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">/* ... */</span></span><br><span class="line">       <span class="comment">// 如果在缓存中没有找到图片，或者采用的 SDWebImageRefreshCached 选项，则从网络下载</span></span><br><span class="line">        <span class="keyword">if</span> ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span><span class="variable">.delegate</span> respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span><span class="variable">.delegate</span> imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                  <span class="comment">// 如果图片找到了，但是采用的 SDWebImageRefreshCached 选项，通知获取到了图片，并再次从网络下载，使 NSURLCache 重新刷新</span></span><br><span class="line">                     completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 下载选项设置 */</span> </span><br><span class="line">            <span class="comment">// 使用 imageDownloader 开启网络下载</span></span><br><span class="line">            <span class="keyword">id</span> &lt;SDWebImageOperation&gt; subOperation = [<span class="keyword">self</span><span class="variable">.imageDownloader</span> downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                <span class="comment">/* ... */</span></span><br><span class="line">               <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                     <span class="comment">// 下载完成后，先将图片保存到缓存中，然后主线程返回</span></span><br><span class="line">                     [<span class="keyword">self</span><span class="variable">.imageCache</span> storeImage:downloadedImage recalculateFromImage:<span class="literal">NO</span> imageData:data forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                        &#125;</span><br><span class="line">                     dispatch_main_sync_safe(^&#123;</span><br><span class="line">                            <span class="keyword">if</span> (!weakOperation<span class="variable">.isCancelled</span>) &#123;</span><br><span class="line">                                completedBlock(downloadedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">          <span class="comment">/* ... */</span></span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</span><br><span class="line">          <span class="comment">// 在缓存中找到图片了，直接返回</span></span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                <span class="keyword">if</span> (!weakOperation<span class="variable">.isCancelled</span>) &#123;</span><br><span class="line">                    completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更详细的注解可参见：<a href="http://www.jianshu.com/p/6ae6f99b6c4c" target="_blank" rel="external">SDWebImage源码解析之SDWebImageManager的注解</a></p>
<h3 id="要点">要点</h3><ol>
<li><p>在 SDWebImageManager 中管理了一个 failedURLs 的 NSMutableSet，里面下载失败的 url 会被存储下来。同时，可以通过 SDWebImageRetryFailed 来强制继续重试下载</p>
</li>
<li><p>查找缓存，若缓存中没有 image 则通过 SDWebImageDownloader 来进行下载，下载完成后通过 SDImageCache 进行缓存，会同时缓存到 memCache 和 diskCache 中</p>
</li>
</ol>
<hr>
<p>可以看到 SDWebImageManager 这个类的主要作用就是为 UIImageView+WebCache 和 SDWebImageDownloader，SDImageCache 之间构建一个桥梁，使它们能够更好的协同工作，在接下来的系列文章中，就让我们一探究竟：它是如何协调异步下载和图片缓存的？</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>说来惭愧，我之前从事 Android 开发，用过许多著名的第三方库，不过仅仅停留在简单的调用 API 阶段，从未涉及到源码的阅读以了解其背后的实现原理，所以一直处于「知其然，而不知所以然」的状态。</p>
<p>如今转投 iOS 怀抱的我，决定将阅读优秀项目的源码作为学习的一部分，而且是带着<strong>疑问</strong>去阅读。由于在项目中使用及考虑到 SDWebImage 的普及程度，其顺理成章的成为了我第一个阅读的项目。</p>
<p>话不多说，让我们开始吧！</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="SDWebImage" scheme="http://itangqi.me/tags/SDWebImage/"/>
    
      <category term="Source code" scheme="http://itangqi.me/tags/Source-code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Objective-C 高级编程》读书笔记之 GCD]]></title>
    <link href="http://itangqi.me/2016/03/15/the-notes-of-learning-gcd/"/>
    <id>http://itangqi.me/2016/03/15/the-notes-of-learning-gcd/</id>
    <published>2016-03-14T16:00:00.000Z</published>
    <updated>2016-04-17T03:53:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文作为《Objective-C 高级编程》读书笔记的第三篇，也是最后一篇，给大家带来的是关于 Grand Central Dispatch (GCD) 的知识点总结。</p>
<a id="more"></a> 
<hr>
<h2 id="概念">概念</h2><p>Grand Central Dispatch (GCD) 是异步执行任务的技术之一。开发者只需要定义想执行的任务并追加到适当的 Dispatch Queue 中，GCD 就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率。</p>
<p>以下摘自苹果的官方文档：</p>
<blockquote>
<p>Grand Central Dispatch (GCD) comprises language features, runtime libraries, and system enhancements that provide systemic, comprehensive improvements to the support for concurrent code execution on multicore hardware in iOS and OS X.</p>
<p>The BSD subsystem, CoreFoundation, and Cocoa APIs have all been extended to use these enhancements to help both the system and your application to run faster, more efficiently, and with improved responsiveness. </p>
</blockquote>
<p>一句话总结就是：<strong>GCD 用我们难以置信的非常简洁的记述方法，实现了极为复杂繁琐的多线程编程，可以说这是一项划时代的技术。</strong></p>
<hr>
<h2 id="多线程编程">多线程编程</h2><p>在讲多线程之前，首先来复习下相关概念：</p>
<ul>
<li><p><strong>进程</strong>：一个具有一定独立功能的程序关于某个数据集合的一次运行活动，进程是系统进行资源分配和调度的一个独立单位，可以理解成一个运行中的应用程序。</p>
</li>
<li><p><strong>线程</strong>：进程的一个实体，是 CPU 调度和分派的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
</li>
<li><p><strong>上下文切换（Context Switch）</strong>：当一个进程中有多个线程来回切换时，Context Switch 用来记录执行状态，这样的进程和一般的多线程进程没有太大差别，但会产生一些额外的开销。</p>
</li>
</ul>
<p>由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上去就好像 1 个 CPU 核能够并列地执行多个线程一样。而且在具有多个 CPU 核的情况下，就不是「看上去像」了，而是真的提供了多个 CPU 核并行执行多个线程的技术。</p>
<p>这种利用多线程编程的技术就被称为「多线程编程」。</p>
<h3 id="多线程编程的问题">多线程编程的问题</h3><p>但是，多线程编程实际上是一种易发生各种问题的编程技术。比如多个线程更新相同的资源会导致数据的不一致（数据竞争）、停止等待事件的线程会导致多个线程相互持续等待（死锁）、使用太多线程会消耗大量内存等。如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-gcd-001.png" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-gcd-002.png" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-gcd-003.png" alt=""></p>
<h3 id="多线程编程的优点">多线程编程的优点</h3><p>尽管极易发生各种问题，也应当使用多线程编程。这是为什么呢？因为使用多线程编程可以保证应用程序的响应性能。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-gcd-004.png" alt=""></p>
<p>使用多线程编程，在执行长时间的处理时仍可保证用户界面的响应性能。</p>
<p>GCD 大大简化了偏于复杂的多线程编程的实现。接下来我们就来看下 GCD 的 API。</p>
<hr>
<h2 id="GCD_的_API">GCD 的 API</h2><p>关于 GCD 相关 API 的详细讲解与使用案例，可以直接参见官方文档或者其他博客，本文仅对我在学习 GCD 过程中觉得难以理解的知识点进行简单总结。</p>
<h3 id="Dispatch_Queue">Dispatch Queue</h3><p>首先回顾一下苹果官方对 GCD 的说明：<strong>开发者要做的只是定义想执行的任务并追加到适当的 Dispatch Queue 中。</strong></p>
<p>那么「Dispatch Queue」是什么呢？</p>
<p>如其名称所示，是执行处理的等待队列。应用程序编程人员通过 dispatch_async 函数等 API，在 Block 语法中记述想执行的处理并将其追加到 Dispatch Queue 中。<strong>Dispatch Queue</strong> 按照追加的顺序（先进先出 FIFO，First-In-First-Out）执行处理。</p>
<p>GCD 提供两种 Dispatch Queue:</p>
<table>
<thead>
<tr>
<th>Dispatch Queue 的种类</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial Dispatch Queue</td>
<td style="text-align:center">等待现在执行中处理结束</td>
<td style="text-align:center">多个线程更新相同资源导致数据竞争时 </td>
</tr>
<tr>
<td>Concurrent Dispatch Queue</td>
<td style="text-align:center">不等待现在执行中处理结束</td>
<td style="text-align:center">并行执行不发生数据竞争等问题的处理时</td>
</tr>
</tbody>
</table>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-gcd-005.png" alt=""></p>
<h3 id="dispatch_sync/dispatch_async">dispatch_sync/dispatch_async</h3><p>关于同步异步、串行并行和线程的关系，下面通过一个表格来总结：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">同步</th>
<th style="text-align:center">异步</th>
</tr>
</thead>
<tbody>
<tr>
<td>主队列</td>
<td style="text-align:center">在主线程中执行</td>
<td style="text-align:center">在主线程中执行 </td>
</tr>
<tr>
<td>串行队列</td>
<td style="text-align:center">在当前线程中执行</td>
<td style="text-align:center">新建线程执行</td>
</tr>
<tr>
<td>并发队列</td>
<td style="text-align:center">在当前线程中执行</td>
<td style="text-align:center">新建线程执行</td>
</tr>
</tbody>
</table>
<h3 id="dispatch_queue_create/dispatch_retain/dispatch_release">dispatch_queue_create/dispatch_retain/dispatch_release</h3><p>Dispatch Queue 也像 Objective-C 的引用计数式内存管理一样，需要通过 dispatch_retain 函数和 dispatch_release 函数的引用计数来管理内存。</p>
<p><strong>如果你部署的最低目标低于 iOS 6.0 or Mac OS X 10.8</strong></p>
<ul>
<li>你应该自己管理 GCD 对象,使用 dispatch_retain/dispatch_release</li>
</ul>
<p><strong>如果你部署的最低目标是 iOS 6.0 or Mac OS X 10.8 或者更高</strong></p>
<ul>
<li>ARC 已经能够管理 GCD 对象了，这时候 GCD 对象就如同普通的 OC 对象一样，不用再 dispatch_retain/dispatch_release  </li>
</ul>
<h3 id="Main_Dispatch_Queue/Global_Dispatch_Queue">Main Dispatch Queue/Global Dispatch Queue</h3><p>实际上不用特意生成 Dispatch Queue 系统也会给我们提供几个，那就是 Main Dispatch Queue 和 Global Dispatch Queue：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">Dispatch Queue 的种类</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Main Dispatch Queue</td>
<td style="text-align:center">Serial Dispatch Queue</td>
<td style="text-align:center">主线程执行</td>
</tr>
<tr>
<td>Global Dispatch Queue（High Priority）</td>
<td style="text-align:center">Concurrent Dispatch Queue</td>
<td style="text-align:center">执行优先级：高（最高优先）</td>
</tr>
<tr>
<td>Global Dispatch Queue（Default Priority）</td>
<td style="text-align:center">Concurrent Dispatch Queue</td>
<td style="text-align:center">执行优先级：默认</td>
</tr>
<tr>
<td>Global Dispatch Queue（Low Priority）</td>
<td style="text-align:center">Concurrent Dispatch Queue</td>
<td style="text-align:center">执行优先级：低</td>
</tr>
<tr>
<td>Global Dispatch Queue（Background Priority）</td>
<td style="text-align:center">Concurrent Dispatch Queue</td>
<td style="text-align:center">执行优先级：后台</td>
</tr>
</tbody>
</table>
<h3 id="dispatch_set_target_queue">dispatch_set_target_queue</h3><p>将 Dispatch Queue 指定为 dispatch_set_target_queue 函数的参数，不仅可以变更 Dispatch Queue 的执行优先级。还可以作成 Dispatch Queue 的执行阶层。如果在多个 Serial Dispatch Queue 中用 dispatch_set_target_queue 函数指定目标为某一个 Serial Dispatch Queue，那么原先本应并行执行的多个 Serial Dispatch Queue，在目标 Serial Dispatch Queue 上只能同时执行一个处理。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-gcd-006.png" alt=""></p>
<p>在必须将可不并行执行的处理追加到多个 Serial Dispatch Queue 中时，如果使用 dispatch_set_target_queue 函数将目标指定为某一个 Serial Dispatch Queue，即可防止处理并行执行。</p>
<h3 id="dispatch_barrier_async">dispatch_barrier_async</h3><p>dispatch_barrier_async 函数会等待追加到 Concurrent Dispatch Queue 上的并行执行的处理全部结束后，再将指定的处理追加到该 Concurrent Dispatch Queue 中。然后在由 dispatch_barrier_async 函数追加的处理执行完毕后，Concurrent Dispatch Queue 才恢复为一般的动作，追加到该 Concurrent Dispatch Queue 的处理又开始并行执行。</p>
<p>使用方法非常简单，如图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-gcd-007.png" alt=""></p>
<h3 id="Dispatch_Semaphore">Dispatch Semaphore</h3><p>Dispatch Semaphore 是持有计数的信号，该计数是多线程编程中的计数类型信号。所谓信号，类似于过马路时常用的手旗。可以通过时举起手旗，不可通过时放下手旗。而 Dispatch Semaphore 中，使用计数来实现该功能。</p>
<p>信号量的具体做法是：当信号计数大于 0 时，每条进来的线程使计数减 1，直到变为 0，变为 0 后其他的线程将进不来，处于等待状态；执行完任务的线程释放信号，使计数加 1，如此循环下去。</p>
<hr>
<h2 id="要点">要点</h2><ol>
<li><p>多个 Serial Dispatch Queue 可并行执行，但生成过线程，就会消耗大量内存，引起大量的上下文切换，大幅度降低系统的响应性能</p>
</li>
<li><p>dispatch_afer 函数并不是在指定时间后执行处理，而只是在指定时间追加处理到 Dispatch Queue</p>
</li>
<li><p>无论向什么样的 Dispatch Queue 中追加处理，使用 Dispatch Group 都可监视这些处理执行的结束。一旦监测到所有处理执行结束，就可将结束的处理追加到 Dispatch Queue 中。这就是使用 Dispatch Group 的原因</p>
</li>
<li><p>关于 dispatch_sync，不得不提<strong>死锁</strong>，详情可参见：<a href="http://www.saitjr.com/ios/ios-gcd-deadlock.html" target="_blank" rel="external">GCD死锁</a> </p>
</li>
<li><p>Serial Dispatch Queue 与 Concurrent Dispatch Queue 都是遵循 FIFO 原则</p>
</li>
<li><p>dispatch_once 方法用 <code>dispatch_once_t</code> 来测试 Block 是否被执行过了。如果执行过了，那么就不在执行，<code>dispatch_once_t</code> 必须是全局或 static 变量</p>
</li>
<li><p>dispatch_create 函数生成的 Dispatch Queue 不管是 Serial Dispatch Queue 还是 Concurrent Dispatch Queue，都使用与默认优先级 Global Dispatch Queue 相同执行优先级的线程</p>
</li>
<li><p>并发与并行的区别：<a href="https://www.zhihu.com/question/33515481" target="_blank" rel="external">https://www.zhihu.com/question/33515481</a></p>
</li>
<li><p>实现 GCD 取消操作：<a href="https://github.com/Tinghui/HUIGCDDispatchAsync" target="_blank" rel="external">A simple wrapper around GCD dispatch_async() function to make easily cancellation.</a>  </p>
</li>
</ol>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/" target="_blank" rel="external">Grand Central Dispatch (GCD) Reference</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文作为《Objective-C 高级编程》读书笔记的第三篇，也是最后一篇，给大家带来的是关于 Grand Central Dispatch (GCD) 的知识点总结。</p>]]>
    
    </summary>
    
      <category term="GCD" scheme="http://itangqi.me/tags/GCD/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Objective-C 高级编程》读书笔记之 Blocks]]></title>
    <link href="http://itangqi.me/2016/03/13/the-notes-of-learning-blocks/"/>
    <id>http://itangqi.me/2016/03/13/the-notes-of-learning-blocks/</id>
    <published>2016-03-12T16:00:00.000Z</published>
    <updated>2016-04-14T07:19:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文作为《Objective-C 高级编程》读书笔记的第二篇，给大家带来的是关于 Blocks 的知识点总结。</p>
<a id="more"></a> 
<hr>
<h2 id="概念">概念</h2><p>Blocks 是 C 语言的扩充功能，可以用一句话来表示 Blocks 的扩充功能：带有自动变量（局部变量）的匿名函数。（Blocks 是闭包在 OC 语言中的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，只是名称不同而已）</p>
<hr>
<h2 id="优势">优势</h2><ol>
<li><p>可代替 Delegate 完成回调，而不需要像 Delegate 那样繁琐</p>
</li>
<li><p>在某些方面，可代替 selector（如 NSNotificationCenter 在 addObserver 的时候，可以使用 block，而不用单独定义方法）</p>
</li>
<li><p>延长对象的生命周期（Block 会自动持有对象）</p>
</li>
<li><p>提高代码的复用性和可读性</p>
</li>
<li><p>常用于：View 动画、GCD、网络异步请求</p>
</li>
</ol>
<hr>
<h2 id="语法">语法</h2><p>关于 Blocks 的语法，看下面一张图就可以啦：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/How%20Do%20I%20Declare%20A%20Block%20in%20Objective%20C%20.png" alt=""></p>
<hr>
<h2 id="Blocks_的实现">Blocks 的实现</h2><h3 id="Blocks_的数据结构">Blocks 的数据结构</h3><p><img src="http://www.galloway.me.uk/media/images/2013-05-26-a-look-inside-blocks-episode-3-block-copy/block_layout.png" alt=""></p>
<p>对应的结构体定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_descriptor &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Block_layout &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor *descriptor;</span><br><span class="line">    <span class="comment">/* Imported variables. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过该图，我们可以知道，一个 Block 实例实际上由 6 部分构成：</p>
<ol>
<li><p><strong>isa 指针</strong>: 所有对象都有该指针，用于实现对象相关的功能</p>
</li>
<li><p><strong>flags</strong>: 用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用；</p>
</li>
<li><p><strong>reserved</strong>: 保留变量；</p>
</li>
<li><p><strong>invoke</strong>: 函数指针，指向具体的 block 实现的函数调用地址；</p>
</li>
<li><p><strong>descriptor</strong>: 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针；</p>
</li>
<li><p><strong>variables</strong>: capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中；</p>
</li>
</ol>
<hr>
<h2 id="Block_存储域">Block 存储域</h2><h3 id="Objective-C_中的_Stack_和_Heap">Objective-C 中的 Stack 和 Heap</h3><p>首先所有的 Objective-C 对象都是分配在 Heap 的。 在 OC 最典型的内存分配与初始化就是这样的：</p>
<pre><code>NSObject *obj = <span class="comment">[<span class="comment">[NSObject alloc]</span> init]</span>;
</code></pre><p>一个对象在 alloc 的时候，就在 Heap 分配了内存空间。</p>
<p>Stack 对象通常有速度的优势，而且不会发生内存泄露问题。那么为什么 OC 的对象都是分配在 Heap 的呢？ 原因在于：</p>
<ul>
<li><p>Stack 对象的生命周期所导致的问题。例如一旦函数返回，则所在的 Stack Frame（栈帧）就会被销毁。那么此时返回的对象也会一并销毁。这个时候我们去 retain 这个对象是无效的。因为整个 Stack Frame 都已经被销毁了。简单而言，就是 Stack 对象的生命周期不适合 OC 的引用计数内存管理方法。</p>
</li>
<li><p>Stack 对象不够灵活，不具备足够的扩展性。创建时长度已经是固定的,而stack对象的拥有者也就是所在的 Stack Frame</p>
</li>
</ul>
<h3 id="Block_类型">Block 类型</h3><p>应用程序的内存分配：</p>
<p><img src="http://blogofzuoyebuluo.qiniudn.com/image_note57603_2.png" alt=""></p>
<p>在 OC 中，一共有 3 种类型的 Block：</p>
<h4 id="_NSConcreteGlobalBlock">_NSConcreteGlobalBlock</h4><p>_NSConcreteGlobalBlock：全局的静态 Block，不会访问任何外部变量。</p>
<p><img src="http://blogofzuoyebuluo.qiniudn.com/image_note57603_3.png" alt=""></p>
<h4 id="_NSConcreteStackBlock">_NSConcreteStackBlock</h4><p>_NSConcreteStackBlock：保存在栈中的 Block，当函数返回时会被销毁。（ARC 中系统实现了自动 copy, 将创建在栈上的 Block 自动拷贝到堆上，所以不存在此类型的 Block）</p>
<h4 id="_NSConcreteMallocBlock">_NSConcreteMallocBlock</h4><p>_NSConcreteMallocBlock：保存在堆中的 Block，当引用计数为 0 时会被销毁。（即成为正常的 OC 对象）</p>
<p><img src="http://blogofzuoyebuluo.qiniudn.com/image_note57603_4.png" alt=""></p>
<hr>
<h2 id="Block_循环引用">Block 循环引用</h2><p>如果在 Block 中使用附有 __strong 修饰符的对象类型自动变量，那么当 Block 从栈复制到堆时，该对象为 Block 所持有，于是便导致了循环引用的产生。</p>
<p>如图所示：self 持有 Block，Block 持有 self，这正是循环引用。</p>
<p><img src="http://blogofzuoyebuluo.qiniudn.com/image_note58470_2.png" alt=""></p>
<h3 id="MRC">MRC</h3><p>在 MRC 下，使用 __block 说明符来避免 Block 中的循环引用。</p>
<p>这是由于当 Block 从栈复制到堆时，若 Block 使用的变量为附有 <strong>block 说明符的 id 类型或对象类型的自动变量，不会被 retain；若 Block 使用的变量为没有 </strong>block 说明符的 id 类型或对象类型的自动变量，则被 retain；若 Block 使用的变量为没有 __block 说明符的 id 类型或对象类型的自动变量，则被 retain。</p>
<h3 id="ARC">ARC</h3><p>在 ARC 下，为了避免这种情况发生，可以在变量声明时用 <strong>weak 修饰符修饰变量 self，让 block 不强引用 self，从而破除循环。iOS4 和 Snow Leopard 由于对 weak 的支持不够完全，可以用 </strong>unsafe_unretained 代替。</p>
<p>使用 Block 成员变量避免循环引用：</p>
<p><img src="http://blogofzuoyebuluo.qiniudn.com/image_note58470_3.png" alt=""></p>
<h3 id="比较">比较</h3><p>下面对使用 <strong>block 变量避免循环引用的方法和使用 </strong>weak 修饰符及 __unsafe_unretained 修饰符避免循环引用的方法做个比较。</p>
<h4 id="使用___block_变量的优点如下：">使用 __block 变量的优点如下：</h4><ul>
<li>通过 <code>__block</code> 变量可控制对象的持有期间</li>
<li><p>在不能使用 <code>__weak</code> 修饰符的环境中不使用 <code>__unsafe_unretained</code> 修饰符即可（不必担心<a href="https://en.wikipedia.org/wiki/Dangling_pointer" target="_blank" rel="external">悬垂指针</a>）</p>
<p>  在执行 Block 时可动态地决定是否将 nil 或其他对象赋值在 <code>__block</code> 变量中。</p>
</li>
</ul>
<h4 id="使用___block_变量的缺点如下：">使用 __block 变量的缺点如下：</h4><ul>
<li><p>为避免循环引用必须执行 Block</p>
<p>  存在执行了 Block 语法，却不执行 Block 的路径时，无法避免循环引用。若由于 Block 引发了循环引用时，根据 Block 的用途选择使用 <code>__block</code> 变量、<code>__weak</code> 修饰符或 <code>__unsafe_unretained</code> 修饰符来避免循环引用。</p>
</li>
</ul>
<hr>
<h2 id="要点">要点</h2><ol>
<li><p>Block 执行的代码其实在编译的时候就已经准备好了</p>
</li>
<li><p>本身 Block 就是一个普通的 OC 对象。正因为它是对象，Block 可以被作为参数传递，可以作为返回值从一个方法返回，可以用来给变量赋值</p>
</li>
<li><p>__block 修饰符在 MRC 下不会进行引用计数加 1，而 ARC 下则会加 1</p>
</li>
<li><p>对于 Block 外的变量引用，Block 默认是将其复制到其数据结构中来实现访问的</p>
</li>
<li><p>对于用 __block 修饰的外部变量引用，Block 是复制其引用地址来实现访问的</p>
</li>
</ol>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html" target="_blank" rel="external">Working with Blocks</a></li>
<li><a href="http://goshdarnblocksyntax.com/" target="_blank" rel="external">How Do I Declare A Block in Objective-C?</a></li>
<li><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C block的实现</a></li>
<li><a href="https://github.com/100mango/zen/blob/master/Objective-C%20%E6%8B%BE%E9%81%97%EF%BC%9A%E4%BB%8EHeap%20and%20Stack%E5%88%B0Block%20/Objective-C%20%E6%8B%BE%E9%81%97%EF%BC%9A%E4%BB%8EHeap%20and%20Stack%E5%88%B0Block%20.md" target="_blank" rel="external">Objective-C 拾遗：从Heap and Stack到Block</a></li>
<li><a href="https://www.zybuluo.com/MicroCai/note/51116" target="_blank" rel="external">block没那么难（一）：block的实现</a></li>
<li><a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/" target="_blank" rel="external">正确使用Block避免Cycle Retain和Crash</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文作为《Objective-C 高级编程》读书笔记的第二篇，给大家带来的是关于 Blocks 的知识点总结。</p>]]>
    
    </summary>
    
      <category term="Blocks" scheme="http://itangqi.me/tags/Blocks/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Objective-C 高级编程》读书笔记之 ARC]]></title>
    <link href="http://itangqi.me/2016/03/10/the-notes-of-learning-arc/"/>
    <id>http://itangqi.me/2016/03/10/the-notes-of-learning-arc/</id>
    <published>2016-03-09T16:00:00.000Z</published>
    <updated>2016-04-13T09:36:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文作为《Objective-C 高级编程》读书笔记的第一篇，给大家带来的是关于 ARC（Automatic Reference Counting）自动引用计数的知识点总结。</p>
<a id="more"></a> 
<hr>
<h2 id="概念">概念</h2><p>顾名思义，ARC（Automatic Reference Counting）— 自动引用计数，是指内存管理中对引用采取自动计数的技术。以下摘自苹果的官方文档：</p>
<blockquote>
<p>Automatic Reference Counting (ARC) is a compiler feature that provides automatic memory management of Objective-C objects. Rather than having to think about retain and release operations, ARC allows you to concentrate on the interesting code, the object graphs, and the relationships between objects in your application.</p>
</blockquote>
<p>一句话总结就是：<strong>在 LLVM 编译器中设置 ARC 为有效状态，就无需再次键入 retain 或者是 release 代码。</strong></p>
<hr>
<h2 id="MRC">MRC</h2><p>在介绍 ARC 之前，不得不提 MRC (MannulReference Counting) — 手动引用计数，即指内存管理中对引用采取手动计数的技术。</p>
<h3 id="引用计数">引用计数</h3><p>我们需要知道 Objective-C 采用的是引用计数式的内存管理方式，这一方式的特点是：</p>
<ol>
<li><p>自己生成的对象自己持有。比如：NSObject * __strong object = [NSObject alloc] init];</p>
</li>
<li><p>非自己生成的对象，自己也能持有。比如：NSMutableArray * __strong array = [NSMutableArray array];</p>
</li>
<li><p>不再需要自己持有的对象时释放</p>
</li>
<li><p>非自己持有的对象自己无法释放</p>
</li>
</ol>
<p>具体可参见下表：</p>
<table>
<thead>
<tr>
<th>对象操作</th>
<th style="text-align:center">OC 中对应的方法</th>
<th style="text-align:center">对应的 retainCount 变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>生成并持有对象</td>
<td style="text-align:center">alloc/new/copy/mutableCopy等</td>
<td style="text-align:center">+1</td>
</tr>
<tr>
<td>持有对象</td>
<td style="text-align:center">retain</td>
<td style="text-align:center">+1</td>
</tr>
<tr>
<td>释放对象</td>
<td style="text-align:center">release</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td>废弃对象</td>
<td style="text-align:center">dealloc</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong>这些有关 OC 内存管理的方法，实际上不包括在该语言中，而是包含再 Cocoa 框架中用于 OS X、iOS 应用开发。Cocoa 框架中 Foundation 框架类库的 NSObject 类担负内存管理的职责。Objective-C 内存管理中的 alloc/retain/release/dealloc 方法分别指代 NSObject 类的 alloc 类方法、retain 实例方法、release 实例方法和 dealloc 实例方法。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-arc-05.jpeg" alt="">(<a href="http://www.ituring.com.cn/minibook/745" target="_blank" rel="external">图片来自</a>)</p>
<h3 id="alloc/retain/release/dealloc实现">alloc/retain/release/dealloc实现</h3><p>苹果的实现大概就是采用散列表（引用计数表）来管理引用计数，如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-arc-06.jpeg" alt="">(<a href="http://www.ituring.com.cn/minibook/745" target="_blank" rel="external">图片来自</a>)</p>
<p>通过引用计数表管理引用计数的好处如下：</p>
<ol>
<li>对用内存块的分配无需考虑内存块头部</li>
<li>引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块</li>
</ol>
<p>这里特别要说的是，第二条这一特性在调试时有着举足轻重的作用。即使出现故障导致对象占用的内存块损坏，但只要引用计数表没有被破坏，就能够确认各内存块的位置，如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-arc-07.jpeg" alt="">(<a href="http://www.ituring.com.cn/minibook/745" target="_blank" rel="external">图片来自</a>)</p>
<p>另外，在利用工具检测内存泄漏时，引用计数表的各记录也有助于检测各对象的持有者是否存在。</p>
<hr>
<h2 id="ARC">ARC</h2><p>当当当~~~今天的主角登场啦！！！</p>
<p>实际上<strong>引用计数式内存管理</strong>的本质部分在 ARC 中并没有改变。就像<strong>自动引用计数</strong>这个名称表示的那样，ARC 只是自动地帮助我们处理<strong>引用计数</strong>的相关部分。</p>
<h3 id="所有权修饰符">所有权修饰符</h3><p>Objective-C 编程中为了处理对象，可将变量类型定义为 id 类型或各种对象类型。</p>
<p>所谓对象类型就是指向 NSObject 这样的 Objective-C 类的指针，例如 NSObject <em> 。id 类型用于隐藏对象类型的类名部分，相当于 C 语言中常用的 void </em> 。</p>
<p>ARC 有效时，id 类型和对象类型同 C 语言其他类型不同，其类型上必须附加所有权修饰符。所有权修饰符一共有 4 种：</p>
<ul>
<li><code>__strong</code></li>
<li><code>__weak</code></li>
<li><code>__unsafe_unretained</code></li>
<li><code>__autoreleasing</code></li>
</ul>
<p>说到变量所有权修饰符，有人可能会跟属性修饰符搞混，这里做一个对照关系小结：</p>
<ul>
<li><code>assign</code> 对应的所有权类型是 <code>__unsafe_unretained</code></li>
<li><code>copy</code> 对应的所有权类型是 <code>__strong</code></li>
<li><code>retain</code> 对应的所有权类型是 <code>__strong</code></li>
<li><code>strong</code> 对应的所有权类型是 <code>__strong</code></li>
<li><code>unsafe_unretained</code> 对应的所有权类型是 <code>__unsafe_unretained</code></li>
<li><code>weak</code> 对应的所有权类型是 <code>__weak</code></li>
</ul>
<p>以上除了 <code>weak</code> 外，其他的属性修饰符在 MRC 模式下也是有效的。</p>
<p>另外，<code>__strong</code>、<code>__weak</code>、<code>__autoreleasing</code> 修饰的自动变量会自动初始化为 nil。</p>
<h4 id="__strong_修饰符">__strong 修饰符</h4><p><code>__strong</code> 表示强引用，对应定义 property 时用到的 <code>strong</code>。当对象没有任何一个强引用指向它时，它才会被释放。如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，需要保证所有指向对象强引用置为 nil。<code>__strong</code> 修饰符是 id 类型和对象类型默认的所有权修饰符。</p>
<h4 id="__weak_修饰符">__weak 修饰符</h4><p><code>__weak</code> 表示弱引用，对应定义 property 时用到的 <code>weak</code>。弱引用不会影响对象的释放，而当对象被释放时，所有指向它的弱引用都会自定被置为 nil，这样可以防止野指针。<code>__weak</code> 最常见的一个作用就是用来避免强引用循环。但是需要注意的是，<code>__weak</code> 修饰符只能用于 iOS 5 以上的版本，在 iOS 4 及更低的版本中使用 <code>__unsafe_unretained</code> 修饰符来代替。</p>
<h5 id="循环引用">循环引用</h5><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-arc-02.001.jpeg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-arc-03.png" alt=""></p>
<h5 id="__weak_实现">__weak 实现</h5><p>关于 runtime 如何实现 weak 属性，可参见：<a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#8-runtime-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-weak-%E5%B1%9E%E6%80%A7" target="_blank" rel="external">《招聘一个靠谱的 iOS》</a> 中的解答。</p>
<h4 id="__unsafe_unretained_修饰符">__unsafe_unretained 修饰符</h4><p>ARC 是在 iOS 5 引入的，而 <code>__unsafe_unretained</code> 这个修饰符主要是为了在 ARC 刚发布时兼容 iOS 4 以及版本更低的系统，因为这些版本没有弱引用机制。这个修饰符在定义 property 时对应的是  <code>unsafe_unretained</code>。<code>__unsafe_unretained</code> 修饰的指针纯粹只是指向对象，没有任何额外的操作，不会去持有对象使得对象的 retainCount + 1。而在指向的对象被释放时依然原原本本地指向原来的对象地址，不会被自动置为 nil，所以成为了野指针，非常不安全。</p>
<h4 id="__autoreleasing_修饰符">__autoreleasing 修饰符</h4><p>在 ARC 模式下，我们不能显示的使用 <code>autorelease</code> 方法了，但是 <code>autorelease</code> 的机制还是有效的，通过将对象赋给 <code>__autoreleasing</code> 修饰的变量就能达到在 MRC 模式下调用对象的 <code>autorelease</code> 方法同样的效果。</p>
<p>也就是说可以理解为，在 ARC 有效时，用 @autoreleasepool 块替代 NSAutoreleasePool 类，用附有 <code>__autoreleasing</code> 修饰符的变量替代 <code>autorelease</code> 方法，如图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-arc-04.001.png" alt=""></p>
<p>在 ARC 模式下，显式的使用 <code>__autoreleasing</code> 的场景很少见，但是 autorelease 的机制却依然在很多地方默默起着作用。我们来看看这些场景：</p>
<ol>
<li>方法返回值</li>
<li>访问 __weak 修饰的变量</li>
<li>id 的指针或对象的指针(id *)</li>
</ol>
<p>关于使用场景的具体讲解，感兴趣的同学可以自学搜索。</p>
<h5 id="Autorelease_Pool">Autorelease Pool</h5><p>在 ARC 下，我们并不需要手动调用 autorelease 有关的方法，甚至可以完全不知道 autorelease 的存在，就可以正确管理好内存。因为 Cocoa Touch 的 Runloop 中，每个 runloop circle 中系统都自动加入了 Autorelease Pool 的创建和释放。</p>
<p>Autorelase Pool 提供了一种可以允许你向一个对象延迟发送 <code>release</code> 消息的机制。当你想放弃一个对象的所有权，同时又不希望这个对象立即被释放掉（例如在一个方法中返回一个对象时），Autorelease Pool 的作用就显现出来了。</p>
<p>所谓的延迟发送 <code>release</code> 消息指的是，当我们把一个对象标记为 <code>autorelease</code> 时:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span>* str = [[[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"hello"</span>] autorelease];</span><br></pre></td></tr></table></figure>
<p>这个对象的 retainCount 会 + 1，但是并不会发生 release。当这段语句所处的 autoreleasepool 进行 drain 操作时，所有标记了 <code>autorelease</code> 的对象的 retainCount 会被 - 1。即 <code>release</code> 消息的发送被延迟到 pool 释放的时候了。</p>
<p>在 ARC 环境下，苹果引入了 <code>@autoreleasepool</code> 语法，不再需要手动调用 <code>autorelease</code> 和 <code>drain</code> 等方法。</p>
<h3 id="规则">规则</h3><p>在 ARC 有效的情况下编译源代码，必须遵守一定的规则。下面就是具体的 ARC 的规则：</p>
<ol>
<li><p>不能显式使用 retain/release/retainCount/autorelease</p>
</li>
<li><p>不能使用 NSAllocateObject/NSDeallocateObject</p>
</li>
<li><p>需要遵守内存管理的方法命名规则。在 ARC 模式和 MRC 模式下，以 alloc/new/copy/mutableCopy 开头的方法在返回对象时都必须返回给调用方所应当持有的对象。在 ARC 模式下，追加一条：以 init 开头的方法必须是实例方法并且必须要返回对象。返回的对象应为 id 类型或声明该方法的类的对象类型，或是该类的超类型或子类型。该返回的对象并不注册到 Autorelease Pool 中，基本上只是对 alloc 方法返回值的对象进行初始化处理并返回该对象。需要注意的是：- (void)initialize; 方法虽然是以 init 开头但是并不包含在上述规则中</p>
</li>
<li><p>不要显式调用 dealloc</p>
</li>
<li><p>使用 @autoreleasepool 块替代 NSAutoreleasePool</p>
</li>
<li><p>不能使用区域（NSZone）</p>
</li>
<li><p>对象型变量不能作为 C 语言结构体（struct/union）的成员</p>
</li>
<li><p>显式转换 id 和 void *</p>
</li>
</ol>
<h3 id="Toll-Free_Bridge">Toll-Free Bridge</h3><blockquote>
<p>There are a number of data types in the Core Foundation framework and the Foundation framework that can be used interchangeably. This capability, called toll-free bridging, means that you can use the same data type as the parameter to a Core Foundation function call or as the receiver of an Objective-C message. For example, NSLocale (see NSLocale Class Reference) is interchangeable with its Core Foundation counterpart, CFLocale (see CFLocale Reference). Therefore, in a method where you see an NSLocale * parameter, you can pass a CFLocaleRef, and in a function where you see a CFLocaleRef parameter, you can pass an NSLocale instance. You cast one type to the other to suppress compiler warnings, as illustrated in the following example.</p>
</blockquote>
<p>Toll-Free Briding 保证了在程序中，可以方便和谐的使用 Core Foundation 类型的对象和 Objective-C 类型的对象。</p>
<p>在 MRC 时代，由于 Objective-C 类型的对象和 Core Foundation 类型的对象都是相同的 release 和 retain 操作规则，所以 Toll-Free Bridging 的使用比较简单，但是自从切换到 ARC 后，Objective-C 类型的对象内存管理规则改变了，而 Core Foundation 依然是之前的机制，换句话说，Core Foundation 不支持 ARC。</p>
<p>这个时候就必须要要考虑一个问题了，在做 Core Foundation 与 Objective-C 类型转换的时候，用哪一种规则来管理对象的内存。显然，对于同一个对象，我们不能够同时用两种规则来管理，所以这里就必须要确定一件事情：哪些对象用 Objective-C（也就是 ARC）的规则，哪些对象用 Core Foundation 的规则（也就是 MRC）的规则。或者说要确定对象类型转换了之后，内存管理的 ownership 的改变。于是苹果在引入 ARC 之后对 Toll-Free Bridging 的操作也加入了对应的方法与修饰符，用来指明用哪种规则管理内存，或者说是内存管理权的归属。这些方法和修饰符分别是：</p>
<ul>
<li>__bridge（修饰符）</li>
<li>__bridge_retained（修饰符） or CFBridgingRetain（函数）</li>
<li>__bridge_transfer（修饰符） or CFBridgingRelease（函数）</li>
</ul>
<p>本文关于 Toll-Free Bridge 不做过多介绍，感兴趣的同学可以参见：<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html" target="_blank" rel="external">Toll-Free Bridge</a></p>
<hr>
<h2 id="要点">要点</h2><ol>
<li><p>ARC 是编译器提供的机制，而不是 GC (Garbage Collection) 这种运行时提供的机制</p>
</li>
<li><p>autorelease 实例方法的本质就是调用 NSAutoreleasePool 对象的 addObject 类方法</p>
</li>
</ol>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="external">Objective-C Automatic Reference Counting (ARC)</a></li>
<li><a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Transitioning to ARC Release Notes</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011-SW1" target="_blank" rel="external">Advanced Memory Management Programming Guide</a></li>
<li><a href="http://www.samirchen.com/ios-arc/" target="_blank" rel="external">iOS ARC 内存管理要点</a></li>
<li><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/MM.html" target="_blank" rel="external">Objective-C 中的内存分配</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文作为《Objective-C 高级编程》读书笔记的第一篇，给大家带来的是关于 ARC（Automatic Reference Counting）自动引用计数的知识点总结。</p>]]>
    
    </summary>
    
      <category term="ARC" scheme="http://itangqi.me/tags/ARC/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊 UITableView（三）]]></title>
    <link href="http://itangqi.me/2016/02/27/the-notes-of-learning-uitableview-three/"/>
    <id>http://itangqi.me/2016/02/27/the-notes-of-learning-uitableview-three/</id>
    <published>2016-02-26T16:00:00.000Z</published>
    <updated>2016-04-16T08:10:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>在本系列文章中，我将和大家聊一聊关于 UITableView 的种种，那些你知道的或者不知道的事。</p>
</blockquote>
<p>本文是系列文章《聊一聊 UITableView》的完结篇。</p>
<a id="more"></a> 
<p>第一篇：<a href="http://itangqi.me/2016/02/25/the-notes-of-learning-uitableview-one/">聊一聊 UITableView（一）</a><br>第二篇：<a href="http://itangqi.me/2016/02/26/the-notes-of-learning-uitableview-two/">聊一聊 UITableView（二）</a></p>
<hr>
<h2 id="实现">实现</h2><p>如果你有仔细阅读过本系列文章的前两篇（没看过的一定要去看看呀！），那么我想你基本上已经对实现的原理及流程有了清晰的认识。所以关于具体的实现，本文不做详细介绍，你可以参见下面两篇文章：</p>
<ul>
<li><a href="http://www.wugaojun.com/blog/2015/05/24/autolayoutshi-zhan-cellgao-du-bu-gu-ding-de-uitableview/" target="_blank" rel="external">AutoLayout实战:cell高度不固定的UITableView</a></li>
<li><a href="http://tutuge.me/2015/08/08/autolayout-example-with-masonry2/" target="_blank" rel="external">有趣的Autolayout示例2-Masonry实现</a></li>
</ul>
<hr>
<h2 id="那些坑">那些坑</h2><p>下面列举了几个在开发中比较常见的<strong>坑</strong>供大家学习：</p>
<h4 id="1-_UILabel_的_preferredMaxLayoutWidth">1. UILabel 的 <code>preferredMaxLayoutWidth</code></h4><p>定义如下:</p>
<blockquote>
<p>This property affects the size of the label when layout constraints are applied to it. During layout, if the text extends beyond the width specified by this property, the additional text is flowed to one or more new lines, thereby increasing the height of the label.</p>
</blockquote>
<p>如果我们要使用 Auto Layout 自动计算<strong>多行</strong> UILabel 的高度，这个属性就必须在运行时指定，要不然系统计算不出 UILabel 的宽度。这是因为 UILabel 需要知道 superview 的宽度才能<strong>折行</strong>，而 superview 的宽度还依仗着子 view 宽度的累加才能确定。</p>
<p>同时需要设置 UILabel 的 <code>numberOfLines</code> 属性为 0 以表示显示多行。</p>
<h4 id="2-_UITableView_的_estimatedRowHeight">2. UITableView 的 <code>estimatedRowHeight</code></h4><blockquote>
<p>我们知道，UITableView 是个 UIScrollView，就像平时使用 UIScrollView 一样，加载时指定 contentSize 后它才能根据自己的 bounds、contentInset、contentOffset 等属性共同决定是否可以滑动以及滚动条的长度。而 UITableView 在一开始并不知道自己会被填充多少内容，于是询问 data source 个数和创建 cell，同时询问 delegate 这些 cell 应该显示的高度，这就造成它在加载的时候浪费了多余的计算在屏幕外边的 cell 上。</p>
</blockquote>
<p>1.设置估算高度后，contentSize.height 根据“cell 估算值 x cell 个数”计算，这就导致滚动条的大小处于不稳定的状态，contentSize 会随着滚动从估算高度慢慢替换成真实高度，肉眼可见滚动条突然变化甚至“跳跃”。</p>
<p>2.若是有设计不好的下拉刷新或上拉加载控件，或是 KVO 了 contentSize 或 contentOffset 属性，有可能使表格滑动时跳动。</p>
<p>3.估算高度设计初衷是好的，让加载速度更快，那凭啥要去侵害滑动的流畅性呢，用户可能对进入页面时多零点几秒加载时间感觉不大，但是滑动时实时计算高度带来的卡顿是明显能体验到的，个人觉得还不如一开始都算好了呢（iOS8 更过分，即使都算好了也会边划边计算）</p>
<h4 id="3-_UITableView_的_heightForRowAtIndexPath:">3. UITableView 的 <code>heightForRowAtIndexPath:</code></h4><p>对于 Auto Layout 下的 cell，使用 <code>systemLayoutSizeFittingSize:</code> 计算 tableview.contentView 的 <code>UILayoutFittingCompressedSize</code> 返回的 CGSize 的高度是首选，但它同样是根据 <code>intrinsicContentSize</code> 来计算的，得出的高度其实是不包含 <code>UITextView</code> 这种 view 的，所以结果还需要<strong>加上</strong> UITextView 的高度即可。</p>
<h4 id="4-_iOS_8_算高机制">4. iOS 8 算高机制</h4><p>相同的代码在 iOS 7 和 iOS 8 上滑动顺畅程度完全不同，iOS8 莫名奇妙的卡。很大一部分原因是 iOS 8 上的算高机制大不相同，图片来自 <a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">sunnyxx</a>：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uitableview-three-01.jpg" alt=""></p>
<p>造成这样的原因：<br>1.不开启高度估算时，UITableView 上来就要对所有 cell 调用算高来确定 contentSize<br>2.<code>dequeueReusableCellWithIdentifier:forIndexPath:</code> 相比不带 “forIndexPath” 的版本会多调用一次高度计算<br>3.iOS 7 计算高度后有”缓存“机制，不会重复计算；而 iOS 8 不论何时都会重新计算 cell 高度（cell 被认为随时都可能改变高度（如从设置中调整动态字体大小），所以每次滑动出来后都要重新计算高度。）</p>
<hr>
<h2 id="那些优化">那些优化</h2><h4 id="1-_避免_cell_的重新布局">1. 避免 cell 的重新布局</h4><p>cell 的布局填充等操作比较耗时，一般可在创建时就布局好。如自定义 cell, 可重写其 <code>initWithStyle:</code> 方法，在其中将 cell 的布局设置完成。<br>创建 cell 完成之后，调用 <strong>相应方法</strong> 往其中填充内容即可，即将 cell 的布局及填充分开执行，且尽量将要填充的 data 提前准备好。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 UITableView 的 dequeueReusableCellWithIdentifier 方法时会通过这个方法初始化 Cell</span></span><br><span class="line">- (instancetype)initWithStyle:(<span class="built_in">UITableViewCellStyle</span>)style reuseIdentifier:(<span class="built_in">NSString</span> *)reuseIdentifier &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithStyle:style reuseIdentifier:reuseIdentifier];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    	<span class="comment">// 在这里！！！</span></span><br><span class="line">     	[<span class="keyword">self</span> initView];</span><br><span class="line">        [<span class="keyword">self</span> updateConstraints];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-_在_Model（Entity）中计算并保存_Cell_的高度">2. 在 Model（Entity）中计算并保存 Cell 的高度</h4><p>我们都知道，UITableView 是继承自 UIScrollView 的，需要先确定它的 contentSize 及每个 cell 的位置，然后才会把重用的 cell 放置到对应的位置。所以事实上，UITableView 的回调顺序是先多次调用 <code>tableView:heightForRowAtIndexPath:</code>以确定 contentSize 及 cell 的位置，然后才会调用 <code>tableView:cellForRowAtIndexPath:</code>，从而来显示在当前屏幕的 cell。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DataEntity</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始数据</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *content;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cell 高度</span></span><br><span class="line">@roperty(<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> cellHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这样，就不用在 <code>tableView:heightForRowAtIndexPath:</code> 中每次都计算了。</p>
<p>补充：同理可将 view 缓存起来的：比如每一个 cell 都需要用到的 UIImage, UIFont, NSDateFormatter 或者任何在绘制时需要的对象，推荐使用类层级的初始化方法中执行分配，并将其存储为静态变量。</p>
<h4 id="3-_滑动_UITableView_时，按需加载对应的内容">3. 滑动 UITableView 时，按需加载对应的内容</h4><p>从 UIScrollView 的角度出发，对 cell 进行按需加载, 即滚动很快时候, 只加载目标范围内的 cell.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (needLoadArr<span class="variable">.count</span>&gt;<span class="number">0</span> &amp;&amp; [needLoadArr indexOfObject:indexPath]==<span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">    [cell clear]; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定 3 行加载。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset&#123;</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *ip = [<span class="keyword">self</span> indexPathForRowAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y)];</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *cip = [[<span class="keyword">self</span> indexPathsForVisibleRows] firstObject];</span><br><span class="line">    <span class="built_in">NSInteger</span> skipCount = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> (labs(cip<span class="variable">.row</span>-ip<span class="variable">.row</span>)&gt;skipCount) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *temp = [<span class="keyword">self</span> indexPathsForRowsInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y, <span class="keyword">self</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.height</span>)];</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> arrayWithArray:temp];</span><br><span class="line">        <span class="keyword">if</span> (velocity<span class="variable">.y</span>&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp lastObject];</span><br><span class="line">            <span class="keyword">if</span> (indexPath<span class="variable">.row</span>+<span class="number">33</span>) &#123;</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath<span class="variable">.row</span>-<span class="number">3</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath<span class="variable">.row</span>-<span class="number">2</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath<span class="variable">.row</span>-<span class="number">1</span> inSection:<span class="number">0</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [needLoadArr addObjectsFromArray:arr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-_复用高开销的对象">4. 复用高开销的对象</h4><p>在 Objective-C 中有些对象的初始化过程很缓慢，比如：<code>NSDateFormatter</code> 和 <code>NSCalendar</code>，但是有些时候，你也不得不使用它们。为了这样的高开销的对象成为影响程序性能的重要因素，我们可以复用它们。</p>
<p>比如，我们在一个类里添加一个 <code>NSDateFormatter</code> 的对象，并使用懒加载机制来使用它，整个类只用到一个这样的对象，并只初始化一次：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in your .h or inside a class extension</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDateFormatter</span> *dateFormatter;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// inside the implementation (.m)</span></span><br><span class="line"><span class="comment">// When you need, just use self.dateFormatter</span></span><br><span class="line">- (<span class="built_in">NSDateFormatter</span> *)dateFormatter &#123;</span><br><span class="line">    <span class="keyword">if</span> (! _dateFormatter) &#123;</span><br><span class="line">        _dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        [_dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd a HH:mm:ss EEEE"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dateFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上面的代码在多线程环境下会有问题，所以我们可以改进如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no property is required anymore. The following code goes inside the implementation (.m)</span></span><br><span class="line">- (<span class="built_in">NSDateFormatter</span> *)dateFormatter &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *dateFormatter;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        [dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd a HH:mm:ss EEEE"</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dateFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就线程安全了。</p>
<h4 id="5-_尽量减少不必要的透明_View">5. 尽量减少不必要的透明 View</h4><p>透明图层对渲染性能会有一定的影响，系统必须将透明图层与下面的视图混合起来计算颜色，并绘制出来。减少透明图层并使用不透明的图层来替代它们，可以极大地提高渲染速度。</p>
<h4 id="6-_优化touch事件传递">6. 优化touch事件传递</h4><p>把不需要接受 touch 的 view 的 <code>userInteractionEnabled</code> 设为 0 </p>
<h4 id="7-_其他">7. 其他</h4><ul>
<li>选择合适的数据结构来承载数据，不同的数据结构对不同操作的开销是存在差异的；</li>
<li>如果 Cell 展示的内容来自网络，确保用异步加载的方式来获取数据，并且进行缓存，滚出可视范围的载入进程要 Cancel 掉；</li>
<li>尽量减少 subview 的数量，减少渲染工作；</li>
<li>异步获取数据：</li>
<li>启用 GZIP 数据压缩；</li>
</ul>
<hr>
<h2 id="写在最后">写在最后</h2><blockquote>
<p>纸上谈兵终觉浅 绝知此事要躬行</p>
</blockquote>
<p>好啦，不管怎样，亲自去实践才是获取与巩固知识的最佳办法！</p>
<h2 id="参考">参考</h2><ul>
<li><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">优化UITableViewCell高度计算的那些事</a></li>
<li><a href="http://blog.alchemistxxd.com/2015/12/05/Auto-Layout-dynamic-UITableViewCell/" target="_blank" rel="external">使用 Auto Layout 处理动态高度的 UITableViewCell 方法的归纳与心得 ⭕️</a></li>
<li><a href="http://tutuge.me/2015/02/19/%E6%8F%90%E5%8D%87UITableView%E6%80%A7%E8%83%BD-%E5%A4%8D%E6%9D%82%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96/" target="_blank" rel="external">提升UITableView性能-复杂页面的优化</a></li>
<li><a href="http://www.samirchen.com/ios-performance-optimization/" target="_blank" rel="external">iOS 程序性能优化</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>在本系列文章中，我将和大家聊一聊关于 UITableView 的种种，那些你知道的或者不知道的事。</p>
</blockquote>
<p>本文是系列文章《聊一聊 UITableView》的完结篇。</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="UITableView" scheme="http://itangqi.me/tags/UITableView/"/>
    
      <category term="UITableViewCell" scheme="http://itangqi.me/tags/UITableViewCell/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊 UITableView（二）]]></title>
    <link href="http://itangqi.me/2016/02/26/the-notes-of-learning-uitableview-two/"/>
    <id>http://itangqi.me/2016/02/26/the-notes-of-learning-uitableview-two/</id>
    <published>2016-02-25T16:00:00.000Z</published>
    <updated>2016-04-16T08:10:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>在本系列文章中，我将和大家聊一聊关于 UITableView 的种种，那些你知道的或者不知道的事。</p>
</blockquote>
<p>本文是系列文章《聊一聊 UITableView》的第二篇。</p>
<a id="more"></a> 
<p>第一篇：<a href="http://itangqi.me/2016/02/25/the-notes-of-learning-uitableview-one/">聊一聊 UITableView（一）</a></p>
<hr>
<h2 id="相关知识储备">相关知识储备</h2><h3 id="estimatedHeightForRowAtIndexPath:"><code>estimatedHeightForRowAtIndexPath:</code></h3><p>首先，丢张官方文档截图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-uitableviewcell-two-02.png" alt=""></p>
<p>在 iOS 7 上， 苹果为 <code>UITableViewDelegate</code> 带来了新方法 <code>estimatedHeightForRowAtIndexPath:</code>。此方法用于返回一个 cell 的预估高度，如果在程序中实现了这个方法，tableview 首次加载的时候就不会调用 <code>heightForRowAtIndexPath:</code> 方法，而是用 <code>estimatedHeightForRowAtIndexPath:</code> 返回的预估高度计算 tableview 的总高度，然后 tableview 就可以显示出来了，等到 cell 可见的时候，再去调用 <code>heightForRowAtIndexPath:</code> 获取 cell 的实际高度。</p>
<p>注意：除非行高极端变化并且你已经明显的觉察到了滚动时滚动条的“跳跃”现象，你才需要实现此方法；否则，直接用 tableView 的 estimatedRowHeight 属性即可。</p>
<p>而在 iOS 8 上，苹果为 UITableView 带来了 <a href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithSelf-SizingTableViewCells.html" target="_blank" rel="external">Self-Sizing</a> </p>
<p>首先，进行行高预估：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tableView<span class="variable">.rowHeight</span> = <span class="built_in">UITableViewAutomaticDimension</span>;</span><br><span class="line">tableView<span class="variable">.estimatedRowHeight</span> = <span class="number">85.0</span>;</span><br></pre></td></tr></table></figure></p>
<p>其次，在 <code>heightForRowAtIndexPath:</code> 中返回 UITableViewAutomaticDimension 即可：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifdef IOS_8_NEW_FEATURE_SELF_SIZING</span></span><br><span class="line">    <span class="comment">// iOS 8 的 Self-sizing 特性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UITableViewAutomaticDimension</span>;</span><br><span class="line"><span class="preprocessor">#else</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你没看错，就这么简单。好啦，你可以愉快的去玩耍了。</p>
<h3 id="systemLayoutSizeFittingSize:"><code>systemLayoutSizeFittingSize:</code></h3><p>没错，还是官方文档截图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-uitableviewcell-two-01.png" alt=""></p>
<p>如果要适配 iOS 8 以下，则要使用到 <code>stemLayoutSizeFittingSize:</code> 方法。 由于其需要 cell 的一个实例才能计算，所以这儿用字典专门存放 cell 的实列，这样就不需要每次计算 cell 高度的时候去动态生成实例，这样即方便也高效也少用内存，可谓一举三得。</p>
<p>首先，试图从字典中取出指定 cell:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// offscreenCells 为成员变量</span></span><br><span class="line">NoteListCell *_templateCell = [<span class="keyword">self</span><span class="variable">.offscreenCells</span> objectForKey:reuseIdentifier];</span><br></pre></td></tr></table></figure></p>
<p>如果为空，创建并存入字典：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!_templateCell) &#123;</span><br><span class="line">    _templateCell = [[NoteListCell alloc] init];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.offscreenCells</span> setObject:_templateCell forKey:reuseIdentifier];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，计算 cell 的实际高度：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充数据</span></span><br><span class="line">[_templateCell updateWithNote:note];</span><br><span class="line"><span class="comment">// 根据当前数据，计算 Cell 的高度，注意 +1</span></span><br><span class="line">note<span class="variable">.cellHeight</span> = [_templateCell<span class="variable">.contentView</span></span><br><span class="line"><span class="comment">// 使用 `UILayoutFittingCompressedSize` 参数可以得到适合 cell 中所有内容所需的最小尺寸  </span></span><br><span class="line">systemLayoutSizeFittingSize:<span class="built_in">UILayoutFittingCompressedSize</span>]<span class="variable">.height</span> + <span class="number">1.0</span>f;</span><br></pre></td></tr></table></figure></p>
<p>注意：由于是在 _templateCell.contentView 上调用这个方法，那么返回的值将是 contentView 的高度，UITableViewCell 的高度要比它的 contentView 要高 1, 也就是它的分隔线的高度。</p>
<h3 id="setNeedsLayout_vs-_setNeedsUpdateConstraints_and_layoutIfNeeded_vs_updateConstraintsIfNeeded"><code>setNeedsLayout</code> vs. <code>setNeedsUpdateConstraints</code> and <code>layoutIfNeeded</code> vs <code>updateConstraintsIfNeeded</code></h3><p>参见 <a href="http://stackoverflow.com/questions/20609206/setneedslayout-vs-setneedsupdateconstraints-and-layoutifneeded-vs-updateconstra" target="_blank" rel="external">stackoverflow</a> 上相关问题的解答：</p>
<ol>
<li>如果仅想要立即改变约束，调用 <code>setNeedsLayout</code>;</li>
<li>如果改变 view 的一些属性（如 offsets）可能会导致布局的改变，那么调用 <code>setNeedsUpdateConstraints</code>, 更多的时候后面需要加 <code>setNeedsLayout</code>;</li>
<li>如果想要立即改变布局，如会形成新的 frame, 那么需要在调用 <code>layoutIfNeeded</code>;</li>
</ol>
<h3 id="缓存行高">缓存行高</h3><p>如果上面提到的你都做了，但是 <code>tableView:heightForRowAtIndexPath:</code> 的性能仍然慢的不可接受。非常不幸，你需要给行高做一些缓存（这是苹果的工程师们给出的改进建议）。大体的思路是，第一次计算时让自动布局引擎解析约束条件，然后将计算出的行高缓存起来，以后所有对该cell 的高度的请求都返回缓存值。当然，关键还要确保任何会导致 cell 高度变化的情况发生时你都清除了缓存的行高——这通常发生在 cell 的内容变化时或其他重大事件发生时（比如用户调节了动态类型文本大小(Dynamic Type text size)的滑动条）。</p>
<p>未完待续……</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="http://www.ifun.cc/blog/2014/02/21/dong-tai-ji-suan-uitableviewcellgao-du-xiang-jie/" target="_blank" rel="external">动态计算UITableViewCell高度详解</a></li>
<li><a href="http://codingobjc.com/blog/2014/10/15/shi-yong-autolayoutshi-xian-uitableviewde-celldong-tai-bu-ju-he-ke-bian-xing-gao/" target="_blank" rel="external">使用Autolayout实现UITableView的Cell动态布局和高度动态改变</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>在本系列文章中，我将和大家聊一聊关于 UITableView 的种种，那些你知道的或者不知道的事。</p>
</blockquote>
<p>本文是系列文章《聊一聊 UITableView》的第二篇。</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="UITableView" scheme="http://itangqi.me/tags/UITableView/"/>
    
      <category term="UITableViewCell" scheme="http://itangqi.me/tags/UITableViewCell/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊 UITableView（一）]]></title>
    <link href="http://itangqi.me/2016/02/25/the-notes-of-learning-uitableview-one/"/>
    <id>http://itangqi.me/2016/02/25/the-notes-of-learning-uitableview-one/</id>
    <published>2016-02-24T16:00:00.000Z</published>
    <updated>2016-03-07T05:42:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>在本系列文章中，我将和大家聊一聊关于 UITableView 的种种，那些你知道的或者不知道的事。</p>
</blockquote>
<p>前几天正好看了关于 AutoLayout 与 UITableViewCell 高度动态计算的文章，于是便在 <a href="https://github.com/tangqi92/SuperNote" target="_blank" rel="external">SuperNote</a> 上践行了所学的知识，并做了相关笔记的总结，在此与大家进行分享。</p>
<a id="more"></a> 
<hr>
<h2 id="Auto_Layout">Auto Layout</h2><p>首先看官方文档<a href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/AutolayoutPG/" target="_blank" rel="external">《Auto Layout Guide》</a>中关于 Auto Layout 的描述：</p>
<blockquote>
<p>Auto Layout dynamically calculates the size and position of all the views in your view hierarchy, based on constraints placed on those views. For example, you can constrain a button so that it is horizontally centered with an Image view and so that the button’s top edge always remains 8 points below the image’s bottom. If the image view’s size or position changes, the button’s position automatically adjusts to match.</p>
<p>This constraint-based approach to design allows you to build user interfaces that dynamically respond to both internal and external changes.</p>
</blockquote>
<p>作为从 Android 阵营转过来的我，一路都是手撕页面布局的，当我面对要在 Storyboard 中拖拽各种约束时，我的内心是几乎是崩溃的（也许我该尝试下），直到我发现了 <a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">Masonry</a>，妈妈再也不用担心我写 Auto Layout 了。</p>
<p>Masonry 老少皆宜，非常容易上手，具体的使用可参见<strong>里脊串</strong>的文章：</p>
<ul>
<li><a href="http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/" target="_blank" rel="external">Masonry介绍与使用实践(快速上手Autolayout)</a></li>
</ul>
<hr>
<h2 id="UITableViewCell_重用机制">UITableViewCell 重用机制</h2><p>在讲 UITableViewCell 高度自适应前，首先简单介绍下 UITableViewCell 的重用机制：</p>
<ul>
<li><p>当用户滚动 UITableView 对象时，部分 UITableViewCell 对象会移出窗口。此时 UITableView 对象会将移出窗口的 UITableViewCell 对象放入 UITableViewCell <strong>对象池</strong>，等待重新利用。当 UITableView 对象要求数据源返回某个 UITableViewCell 对象时，数据源可以先查看对象池。如果有未使用的 UITableViewCell 对象，就可以用<strong>新的数据</strong>配置这个 UITableViewCell 对象，然后将其返回给 UITableView 对象，从而避免创建新对象。</p>
</li>
<li><p>这里还有一个问题：因为有时需要创建 UITableViewCell 的<strong>子类</strong>，用于实现特定的外观或特性，所以 UITableView 对象可能会拥有<strong>不同类型</strong>的 UITableViewCell 对象。如果 UITableViewCell 对象池中的对象创建自不同的子类，那么 UITableView 对象就有可能得到错误类型的 UITableViewCell 对象。鉴于上述原因，必须确保 UITableView 对象能够得到指定类型的 UITableViewCell 对象，这样才能确定返回的对象会拥有哪些属性和方法。</p>
</li>
<li><p>从 UITableViewCell 对象池获取对象时，无须关心取回的是否是某个特定的对象，因为无论取回的是哪个对象，都要重新设置数据。真正要关心的是取回的对象是否是某个<strong>特定</strong>的类型。每个 UITableViewCell 对象都有一个类型为 NSString 的 <strong>reuseIdentifier</strong> 属性。当数据源向 UITableView 对象获取可重用的 UITableViewCell 对象时，可传入一个字符串并要求 UITableView 对象返回相应的 UITableViewCell 对象，这些 UITableViewCell 对象的 reuseIdentifier 属性必须和传入的字符串相同。按照约定，应该将 UITableViewCell 或者 UITableViewCell 子类的类名用作 reuseIdentifier。</p>
</li>
</ul>
<p>上面讲得那么啰嗦，不如直接看下面的图： </p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-of-uitableviewcell-01.png" alt=""></p>
<p>情况 A: 所有 Cell 具有相同的类型</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  实现数据绑定</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// 根据标识符 identifier 从重用队列中取出一个 cell</span></span><br><span class="line">    NoteListCell *cell = [tableView dequeueReusableCellWithIdentifier:kCellReuseIdentifier];</span><br><span class="line">    <span class="comment">// 由于一开始重用队列是空的，所以取出的 cell 也是空的，if(!cell) 条件成立，就会去执行 &#123;&#125; 内的代码</span></span><br><span class="line">    <span class="keyword">if</span> (!cell) &#123;</span><br><span class="line">    	<span class="comment">// 创建 UITableViewCellStyleDefault类型的 cell，并将其标识为 identifier（@”cell”），这样一个 cell 就创建完成了</span></span><br><span class="line">        cell = [[NoteListCell alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:kCellReuseIdentifier];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定指定数据</span></span><br><span class="line">    VNNote *note = [<span class="keyword">self</span><span class="variable">.dataSource</span> objectAtIndex:indexPath<span class="variable">.row</span>];</span><br><span class="line">    note<span class="variable">.index</span> = indexPath<span class="variable">.row</span>;</span><br><span class="line">    [cell updateWithNote:note];</span><br><span class="line">    <span class="comment">// Make sure the constraints have been added to this cell, since it may have just been created from scratch</span></span><br><span class="line">    [cell setNeedsUpdateConstraints];</span><br><span class="line">    [cell updateConstraintsIfNeeded];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>情况 B: 具有多种类型的 Cell</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *cellIdentifier;</span><br><span class="line">    <span class="built_in">UITableViewCellStyle</span> cellStyle;</span><br><span class="line">    <span class="keyword">switch</span> ((indexPath<span class="variable">.row</span> + <span class="number">1</span>)%<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">            <span class="comment">//有标题和副标题，可选图片</span></span><br><span class="line">            cellIdentifier = <span class="string">@"Subtitle Style"</span>;</span><br><span class="line">            cellStyle = <span class="built_in">UITableViewCellStyleSubtitle</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            <span class="comment">//左边文字左对齐，右边文字右对齐，可选的图片</span></span><br><span class="line">            cellIdentifier = <span class="string">@"Value1 Style"</span>;</span><br><span class="line">            cellStyle = <span class="built_in">UITableViewCellStyleValue1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">            <span class="comment">//左边文字右对齐，蓝色字体。右边文字左对齐，黑色。没有图片</span></span><br><span class="line">            cellIdentifier = <span class="string">@"Value2 Style"</span>;</span><br><span class="line">            cellStyle = <span class="built_in">UITableViewCellStyleValue2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:&#123;</span><br><span class="line">            <span class="comment">//有标题，没有副标题，可选的图片</span></span><br><span class="line">            cellIdentifier = <span class="string">@"Default Style"</span>;</span><br><span class="line">            cellStyle = <span class="built_in">UITableViewCellStyleDefault</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSInteger</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">UITableViewCell</span> *myCell = [tableView dequeueReusableCellWithIdentifier:cellIdentifier];</span><br><span class="line">    <span class="keyword">if</span> (!myCell) &#123;</span><br><span class="line">        myCell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:cellStyle reuseIdentifier:cellIdentifier];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"创建%d次"</span>,++times);</span><br><span class="line">    &#125;</span><br><span class="line">    myCell<span class="variable">.textLabel</span><span class="variable">.text</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"第%d行%@"</span>,indexPath<span class="variable">.row</span>+<span class="number">1</span>, cellIdentifier];</span><br><span class="line">    myCell<span class="variable">.detailTextLabel</span><span class="variable">.text</span> = <span class="string">@"Subtitle Text"</span>;</span><br><span class="line">    <span class="keyword">if</span> (indexPath<span class="variable">.row</span> &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        myCell<span class="variable">.imageView</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"smile.png"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myCell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未完待续……</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="http://sharonhu1990.github.io/2015/10/28/%E6%B5%85%E6%9E%90UITableViewCell%E9%87%8D%E7%94%A8%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">浅析UITableViewCell重用机制</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>在本系列文章中，我将和大家聊一聊关于 UITableView 的种种，那些你知道的或者不知道的事。</p>
</blockquote>
<p>前几天正好看了关于 AutoLayout 与 UITableViewCell 高度动态计算的文章，于是便在 <a href="https://github.com/tangqi92/SuperNote">SuperNote</a> 上践行了所学的知识，并做了相关笔记的总结，在此与大家进行分享。</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="UITableView" scheme="http://itangqi.me/tags/UITableView/"/>
    
      <category term="UITableViewCell" scheme="http://itangqi.me/tags/UITableViewCell/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Text Kit 学习笔记]]></title>
    <link href="http://itangqi.me/2016/02/18/the-notes-of-learning-text-kit/"/>
    <id>http://itangqi.me/2016/02/18/the-notes-of-learning-text-kit/</id>
    <published>2016-02-17T16:00:00.000Z</published>
    <updated>2016-04-19T08:45:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>目前，我正在开发自己的第一款 iOS App: <a href="https://github.com/tangqi92/SuperNote" target="_blank" rel="external">SuperNote</a>, 作为一款笔记类应用，其最基础也是最核心的功能便是富文本的编辑。起初为了能快速地实现此功能，我直接使用了 <a href="https://github.com/ibireme/YYText" target="_blank" rel="external">YYText</a>, 照着其 Demo 改了改便基本实现了需求，虽然看似便捷但随后我便发现自己其实是「知其然，而不知其所以然」，对于其中的实现原理只知胜少。</p>
<p>于是决定对富文本编辑的实现原理进行一探究竟，而 <a href="https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html" target="_blank" rel="external">Text Kit</a> 便是今天的主角。</p>
<a id="more"></a> 
<hr>
<h2 id="简介">简介</h2><p>苹果在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html" target="_blank" rel="external">Text Programming Guide for iOS</a> 中对其做了如下解释:</p>
<blockquote>
<p>“Text Kit is a set of classes and protocols in the UIKit framework that provide high-quality typographical services which enable applications to store, lay out, and display text with all the characteristics of fine typesetting, such as kerning, ligatures, line-breaking, and justification.”</p>
</blockquote>
<p>一句话总结：<strong>Text Kit 就是为文字排版与渲染孕应而生的。</strong></p>
<h3 id="历史">历史</h3><p><strong>iOS 2</strong>：这是第一个公开的 SDK，包括一个简单的文本显示组件（UILabel），一个简单的文本输入组件（UITextField），以及一个简单的、可滚动、可编辑的并且支持更大量文本的组件：UITextView。这些组件都只支持纯文本，没有文本选择支持（仅支持插入点），除了设置字体和文本颜色外几乎没有其他可定制功能。</p>
<p><strong>iOS 3</strong>：新特性有复制和粘贴，以及复制粘贴所需要的文本选择功能。数据探测器（Data Detector）为文本视图提供了一个高亮电话号码和链接的方法。然而，除了打开或关闭这些特性外，开发者基本上没有什么别的事情可以做。</p>
<p><strong>iOS 3.2</strong>：iPad 的出现带来了 CoreText，一个低级文本布局和渲染引擎（从Mac OS X 10.5 移植过来的），以及 UITextInput，就是前面也提到的键盘存取协议。</p>
<p><strong>iOS 4</strong>：iOS 3.2 发布仅仅几个月后就发布了，文本方面没有一丁点新功能。</p>
<p><strong>iOS 5</strong>：文本方面没啥变化。</p>
<p><strong>iOS 6</strong>：有些动作了：属性文本编辑被加入了 UITextView。很不幸的是，它很难定制。默认的 UI 有粗体、斜体和下划线。用户可以设置字体大小和颜色。粗看起来相当不错，但还是没法控制布局或者提供一个便利的途径来定制文本属性。然而对于（文本编辑）开发者，有一个大的新功能：可以继承 UITextView 了，这样的话，除了以前版本提供的键盘输入外，开发者可以“免费”获得文本选择功能。而在这以前，开发者必须实现一个完全自定义的文本选择功能，这可能是很多非纯文本工具的开发半途而废的原因。</p>
<p><strong>iOS 7</strong>：终于等来了 TextKit。</p>
<h3 id="架构">架构</h3><p>在 <strong>iOS 6 之前</strong>，WebView 通常是呈现混合风格，如粗体，斜体，甚至颜色文本的最简单方法。</p>
<p>在 <strong>iOS 6 时代</strong>，文本控件如：UILabel、UITextField 和 UITextView 是基于 String Drawing 和 WebKit 构建的。其中 String Drawing 与 Core Graphics 直接通信。因此在iOS 7 之前文本控件也可以实现多种样式的文字排版，但是事实上是通过 WebKit 实现的。WebKit 是一种浏览器内核技术，使用它进行文字渲染会消耗掉比较多的内存，对应用的性能有一定的影响。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-01.png" alt=""></p>
<p>在 <strong>iOS 7 时代</strong>，Text Kit 是建立在 Core Text 之上的，它通过 Core Text 与 Core Graphics 进行交互。而文本控件如：UILabel、UITextField 和 UITextView，则构建于 Text Kit 之上，可见这些文本控件可以利用 Text Kit 提供的 API 来对文字进行排版和渲染处理。从下图可见，UIWebView 是基于 WebKit 的，它不能使用 Text Kit 提供的功能。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-02.png" alt=""></p>
<hr>
<h2 id="核心">核心</h2><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-04.png" alt=""></p>
<p>下面将对上图涉及到的核心类进行一一解释：</p>
<ol>
<li><p><code>UITextView</code>：<br>在 TextKit 中，有两个目的：第一，它是文本系统用来绘制的视图。文本视图它自己并不会做任何绘制；它仅仅提供一个供其它类绘制的区域。第二，处理所有的用户交互，具体来说，Text View 实现 UITextInput 的协议来处理键盘事件，它为用户提供了一种途径来设置一个插入点或选择文本。它并不对文本做任何实际上的改变，仅仅将这些改变请求转发给刚刚讨论的 Text Storage。</p>
</li>
<li><p><code>NSTextStorage</code>:<br>顾名思义，NSTextStorage 就是用来存储文本的字符和相关属性的，例如字体或段落信息等，因为它是 <code>NSMutableAttributedString</code> 的子类，这也就是为什么它来负责存储文本的属性。此外，当 NSTextStorage 中的字符或属性发生改变时，会通知 <code>NSLayoutManager</code>, 进而做到文本内容的显示更新。</p>
</li>
<li><p><code>NSLayoutManager</code>:<br>该类负责对文字进行编辑排版处理，将存储在 <code>NSTextStorage</code> 中的数据转换为可以在视图控件中显示的文本内容，并把字符编码映射到对应的字形上，然后将字形排版到 <code>NSTextContainer</code> 定义的区域中。</p>
</li>
<li><p><code>NSTextContainer</code>:<br>定义了文本可以排版的区域，默认情况下是矩形区域，如果是其他形状的区域，需要通过子类化 NSTextContainer 来创建。</p>
</li>
</ol>
<p>它们的关系可见下图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-06.png" alt=""></p>
<p><code>NSLayoutManager</code> 对象从 <code>NSTextStorage</code> 对象中取得文本内容，进行排版，然后把排版之后的文本放到 <code>NSTextContainer</code> 对象指定的区域上。最后再由一个文本控件从 <code>NSTextContainer</code> 中取出内容显示到屏幕中。</p>
<h3 id="使用场景">使用场景</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-09.png" alt=""></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-08.png" alt=""></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-07.png" alt=""></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-10.png" alt=""></p>
<h3 id="补充">补充</h3><ol>
<li><code>Core Text</code>: 没有直接包含在 TextKit 中，CoreText 是进行实际排版的库。对于布局管理器的每一步，CoreText 被这样或那样的方式调用。它提供了从字符到字形的翻译，用它们来填充行，以及建议断字点</li>
<li><code>NSAttributedString</code>: 就是用来设置文字的效果(颜色、字体、下划线等等)</li>
<li><p><code>NSMutableAttributedString</code>:是 NSAttributedString 的子类，可变类型的NSAttributedString</p>
<p> <img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-05.jpg" alt=""></p>
</li>
</ol>
<hr>
<h2 id="功能">功能</h2><ol>
<li>对文字进行分页或多列排版</li>
<li>支持文字的换行、折叠和着色等处理</li>
<li>可以调整字与字之间的距离、行间距、文字大小、指定特定的字体</li>
<li>支持富文本编辑，可以自定义文字截断</li>
<li>支持凸版印刷效果（letterpress）</li>
<li>支持数据类型的检测（例如链接、附件等）</li>
</ol>
<p>效果如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-11.png" alt=""></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-12.png" alt=""></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-text-kit-13.png" alt=""></p>
<p>本文并不会对具体功能的实现进行详细的阐述，毕竟本文重点是了解内在的实现原理而非具体实现。好啦，剩下的事情就交给你了！</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html" target="_blank" rel="external">Using Text Kit to Draw and Manage Text</a></li>
<li><a href="https://www.objc.io/issues/5-ios7/getting-to-know-textkit/" target="_blank" rel="external">Getting to Know TextKit</a></li>
<li><a href="https://www.raywenderlich.com/50151/text-kit-tutorial" target="_blank" rel="external">Text Kit Tutorial</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>目前，我正在开发自己的第一款 iOS App: <a href="https://github.com/tangqi92/SuperNote">SuperNote</a>, 作为一款笔记类应用，其最基础也是最核心的功能便是富文本的编辑。起初为了能快速地实现此功能，我直接使用了 <a href="https://github.com/ibireme/YYText">YYText</a>, 照着其 Demo 改了改便基本实现了需求，虽然看似便捷但随后我便发现自己其实是「知其然，而不知其所以然」，对于其中的实现原理只知胜少。</p>
<p>于是决定对富文本编辑的实现原理进行一探究竟，而 <a href="https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html">Text Kit</a> 便是今天的主角。</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自学 iOS 开发之旅]]></title>
    <link href="http://itangqi.me/2016/02/08/the-journey-of-learning-ios/"/>
    <id>http://itangqi.me/2016/02/08/the-journey-of-learning-ios/</id>
    <published>2016-02-07T16:00:00.000Z</published>
    <updated>2016-04-19T08:41:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>不知不觉，学习 iOS 开发已经有 3 个多月的时间了，我想，也是时候写篇文章作为总结与回顾了吧。</p>
</blockquote>
<a id="more"></a> 
<p>我相信，很多人都会有这样的经历：每当他在学习一门新语言时，都会阅读许多 <strong>XXX 自学必备资源</strong> 这类的文章，然后一股脑地买下推荐的书，收藏推荐的网站，下载推荐的视频，订阅推荐的邮箱，注册推荐的论坛等等，当时那个热血沸腾劲，心中一定默默地告诉自己：「来吧，我 XXX 要大干一场了！」</p>
<p>然而现实却是：在经过几天的热血过后，你会发现其实你并没有那么多精力与时间去学习去消化那么多资料，一方面的确是因为你时间有限，另一方面更因为并不是所有的都适合现阶段的你。一段时间过，你会发现有些收藏的网站你始终未打开过，有些订阅的邮件你从未阅读过，有些下载的视频你从未看过。</p>
<p>所以，凡事都不能心急与贪多，稳扎稳打方能在学习的道路上越走越远。文中所列出的资料（均以时间为顺序排列），都是到目前为止我所学习过的，并且我会定期更新文章，记录我一步步从小白到<strong>大牛</strong>的心路历程（真是不要脸啊！）。</p>
<hr>
<h2 id="书籍">书籍</h2><p><strong>1. <a href="http://book.douban.com/subject/19962787/" target="_blank" rel="external">Objective-C 编程</a></strong></p>
<p>  本书首先从基本的编程概念讲起（变量、条件语句、循环结构等），接着用浅显易懂的语言讲解 Objective-C 和 Foundation 的知识，包括 Objective-C 的基本语法、 Foundation 常用类 、内存管理、常用设计模式等。—— 本书内容浅显易懂，比较适合作为 OC 的入门书籍。</p>
<p><strong>2. <a href="http://book.douban.com/subject/26287812/" target="_blank" rel="external">iOS 编程（第4版）</a></strong></p>
<p>  本书涵盖了开发 iOS 应用的方方面面：从 Objective-C 基础知识到新增加的语言特性；从 AppKit 库到常见的 Cocoa 设计模式；从 Xcode 技巧到 Instruments 等。—— 本书手把手带你一步步完成一个完整的 iOS 应用，随着章节的深入，循序渐进地不断完善与优化，让你深切体会到开发一款应用所需了解的方方面面。</p>
<p><strong>3. <a href="http://book.douban.com/subject/26287173/" target="_blank" rel="external">iOS 开发进阶</a></strong></p>
<p>  本书分工具、实践、理论三大部分：第一部分介绍 iOS 开发的常用工具；第二部分介绍 iOS 开发中的一些常见的实践经验；第三部分介绍 iOS 开发中涉及的原理。—— 本书中绝大部分内容都能在作者的博客中找到，所谓「进阶」，我想作者更多的是在抛砖引玉吧。</p>
<p><strong>4. <a href="http://book.douban.com/subject/24284008/" target="_blank" rel="external">Objective-C 基础教程</a></strong></p>
<p>  本书全面系统地讲述了 Objective-C 的基础知识和面向对象编程的重要概念，结合实例介绍了 Cocoa 工具包的优秀特性及框架，以及继承、复合、对象初始化、类别、协议、内存管理和源文件组织等重要编程技术。—— 本想作为 OC 的进阶书籍阅读，但并没有预期中好。</p>
<p><strong>5. <a href="http://book.douban.com/subject/19967897/" target="_blank" rel="external">Objective-C 程序设计</a></strong></p>
<p>  本书是针对初学者编写的一个完整又循序渐进的 Objective-C 语言权威入门。阅读本书，不需要先学过 C 语言或其他面向对象语言。本书包含许多详细且实用的范例，用来告诉你如何在实践中运用Objective-C。本书完整展示如何利用 Foundation framework 所提供的丰富自带类库 (Library of classes)，并对 iOS 程序设计原理有所讲解。—— 与《Objective-C 编程》同样作为入门书籍，内容相对前者详实许多。</p>
<p><strong>6. <a href="http://book.douban.com/subject/24720270/" target="_blank" rel="external">Objective-C 高级编程</a></strong></p>
<p>  本书主要介绍 iOS 与 OS X 多线程和内存管理, 深入破析了苹果官方公布的源代码, 告诉你一些苹果公司官方文档中不会出现的知识。—— 真正的 OC 进阶书籍，满满的干货，值得反复阅读。</p>
<p><strong>7. <a href="http://book.douban.com/subject/25829244/" target="_blank" rel="external">Effective Objective-C 2.0</a></strong></p>
<p>  本书从语法、接口与 API 设计、内存管理、框架等 7 大方面总结和探讨了 Objective-C 编程中 52 个鲜为人知和容易被忽视的特性与陷阱。书中包含大量实用范例代码，为编写易于理解、便于维护、易于扩展和高效的 Objective-C  应用提供了解决方案。—— Effective 系列为进阶必备之书，但我认为应该在有一定的项目经验后回过头来阅读，才更能体会其中的精髓。</p>
<p><strong>8. <a href="http://producter.io/" target="_blank" rel="external">Producer</a> by <a href="http://weibo.com/kevinzhow" target="_blank" rel="external">周楷雯Kevin</a></strong></p>
<p>  本书主要涵盖了：设计原理、原型，动效，交互设计、iOS 开发与营销，这四个部分，以 <strong>小记</strong> 作为例子，完整的还原了一款产品从想法到编码，再到上架，以及营销的全过程。 —— 它会作为叩响你成为独立开发者大门的敲门砖。</p>
<p><strong>9. <a href="https://gumroad.com/l/JnWS" target="_blank" rel="external">A GUIDE TO IOS ANIMATION</a> by <a href="http://weibo.com/imapplegeeker" target="_blank" rel="external">KITTEN-YANG</a></strong></p>
<p>  动画小王子的力作 —— 如何你想学习动画，那么就选它作为入门吧。</p>
<hr>
<h2 id="视频">视频</h2><p><strong>1. <a href="https://itunes.apple.com/us/course/developing-ios-7-apps-for/id733644550" target="_blank" rel="external">Developing iOS 7 Apps for iPhone and iPad</a></strong></p>
<p>目前唯一看过的视频教程，老爷子讲得非常棒，如果你想学习 Swift ，可以搜索其相应的课程。我是一边看视频一边将课上所讲的例子都手敲实现了一遍，最后对 iOS 开发有了较全面的了解。</p>
<p><strong>2. <a href="https://developer.apple.com/videos/" target="_blank" rel="external">WWDC Session</a></strong></p>
<p>苹果自家的视频，内容相当多，计划之后空下来按系列来看。</p>
<hr>
<h2 id="开源项目">开源项目</h2><p><strong>1. <a href="https://github.com/dsxNiubility/SXNews" target="_blank" rel="external">SXNews</a></strong></p>
<p>  精仿网易新闻客户端 —— 学习 Android 时第一个仿写的应用便是网易新闻。</p>
<p><strong>2. <a href="https://github.com/hshpy/HPYZhiHuDaily" target="_blank" rel="external">HPYZhiHuDailly</a></strong></p>
<p>  采用 MVVM 的 OC 版知乎客户端 —— 第一个 Android 开源项目便是仿写知乎。</p>
<p><strong>3. <a href="https://github.com/liaojinxing/Voice2Note" target="_blank" rel="external">Voice2Note</a></strong></p>
<p>  懒人笔记客户端 —— 第一个完整的 iOS 应用便是以此为基础进行修修改改的。</p>
<p><strong>4. <a href="https://github.com/meilbn/MyOne-iOS" target="_blank" rel="external">MyOne</a></strong></p>
<p>  精仿「一个」iOS 客户端 —— 代码规范，难度适中，非常适合拿来当做练手的项目。目前希望能将其剩余未完成的功能完成。</p>
<p><strong>5. <a href="https://github.com/Coding/Coding-iOS" target="_blank" rel="external">Coding</a></strong></p>
<p>  Coding 官方 iOS 客户端 —— 官方源码，编写规范，文档较完整，且不断更新中，是个进阶学习的项目。</p>
<hr>
<h2 id="博客">博客</h2><p><strong>1. <a href="https://www.objc.io/" target="_blank" rel="external">objc</a></strong></p>
<pre><code>objc<span class="class">.io</span> 国外一个定期发布关于 Objective-c 的最佳实践以及进阶技术的网站，基本上是每月一期，每期关注一个技术主题，围绕这个主题，有几篇文章涉及到本主题的不同方面。
</code></pre><p>当然，我订阅了许多国内外大牛的技术博客，但是我觉得，如果不是系列性的文章，我更喜欢<strong>通过 Google 搜索关键字来快速寻找出最符合我当下要求的文章来阅读学习</strong>。</p>
<hr>
<h2 id="其他">其他</h2><p><strong><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md" target="_blank" rel="external">《招聘一个靠谱的 iOS》面试题参考答案</a></strong></p>
<p>  面试题来自 <a href="http://weibo.com/u/1364395395" target="_blank" rel="external">微博@我就叫Sunny怎么了</a> 的博文<a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/" target="_blank" rel="external">《招聘一个靠谱的 iOS》</a>，其中共 55 题，除第 1 题为纠错题外，其他 54 道均为简答题，答案为 <a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="external">微博@iOS程序犭袁</a> 整理。—— 由于有年后进行实习生面试的计划，所以，我每天都会来看上两题。当然，即使你不为面试，这里的题目也可以作为检验你学习成果的一个有效方法。</p>
<blockquote>
<p>未完待续……</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>不知不觉，学习 iOS 开发已经有 3 个多月的时间了，我想，也是时候写篇文章作为总结与回顾了吧。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Summary" scheme="http://itangqi.me/tags/Summary/"/>
    
      <category term="iOS" scheme="http://itangqi.me/tags/iOS/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
</feed>
